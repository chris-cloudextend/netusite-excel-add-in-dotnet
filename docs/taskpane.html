<!--
XAVI for NetSuite - Task Pane UI

Copyright (c) 2025 Celigo, Inc.
All rights reserved.

This source code is proprietary and confidential. Unauthorized copying,
modification, distribution, or use of this software, via any medium,
is strictly prohibited without the express written permission of Celigo, Inc.

For licensing inquiries, contact: legal@celigo.com
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAVI for NetSuite</title>
    <!-- Google Fonts: Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           BRAND COLORS
           Primary: Blue Light #004fb6, Deep Dive #09235c, Chrome #a8b1ce
           Secondary: Anenome #0ae2c1, Tidal Wave #0079ff, Barnacle #d3d8e6, Bottlenose #6b7b9d
           ============================================ */
        :root {
            --blue-light: #004fb6;
            --deep-dive: #09235c;
            --chrome: #a8b1ce;
            --anenome: #0ae2c1;
            --tidal-wave: #0079ff;
            --barnacle: #d3d8e6;
            --bottlenose: #6b7b9d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll - we scroll .content instead */
        }

        body {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            color: #333;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            height: 100%;
            box-shadow: 0 0 40px rgba(9, 35, 92, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: var(--deep-dive);
            color: white;
            padding: 16px 20px 0;
            position: relative;
            flex-shrink: 0;
        }

        .header-top {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .header-logo {
            display: flex;
            align-items: center;
        }

        .header-logo img {
            height: 26px;
            width: auto;
            object-fit: contain;
        }

        .header-menu {
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.8;
        }

        .header-menu:hover {
            opacity: 1;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 0;
            border-bottom: none;
        }

        .tab-nav button {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--chrome);
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }

        .tab-nav button:hover {
            color: white;
        }

        .tab-nav button.active {
            color: white;
        }

        .tab-nav button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--anenome);
            border-radius: 3px 3px 0 0;
        }

        .header .version-badge {
            display: inline-block;
            background: var(--anenome);
            color: var(--deep-dive);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            margin-top: 8px;
            font-weight: 600;
        }

        /* Green accent stripe */
        .accent-stripe {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(180deg, var(--anenome) 0%, #00c9a7 100%);
            z-index: 1000;
        }

        /* Tab Panels */
        .tab-panel {
            padding: 0;
        }

        /* Empty State for placeholder tabs */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 24px;
            text-align: center;
        }

        .empty-state .empty-icon {
            width: 64px;
            height: 64px;
            background: #f3f4f6;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .empty-state .empty-icon svg {
            width: 32px;
            height: 32px;
            stroke: var(--bottlenose);
        }

        .empty-state h3 {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .empty-state .coming-soon {
            margin-top: 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--anenome);
            background: rgba(10, 226, 193, 0.1);
            padding: 6px 16px;
            border-radius: 20px;
        }

        /* Collapsible Section Styles - Card Design */
        .collapsible-section {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 8px;
            overflow: hidden;
            background: white;
            transition: all 0.2s ease;
        }

        .collapsible-section:hover {
            border-color: var(--anenome);
            box-shadow: 0 2px 8px rgba(9, 35, 92, 0.08);
        }

        .collapsible-header {
            background: white;
            padding: 12px 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .collapsible-section:hover .collapsible-header,
        .collapsible-section[open] .collapsible-header {
            border-left-color: var(--anenome);
        }

        .collapsible-header:hover {
            background: #fafbfc;
        }

        .collapsible-header h3 {
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            margin: 0;
        }

        .collapsible-header .section-icon {
            width: 34px;
            height: 34px;
            background: #f3f4f6;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .collapsible-header .section-icon svg {
            width: 17px;
            height: 17px;
            stroke: var(--deep-dive);
            fill: none;
            stroke-width: 2;
        }

        .collapsible-header .icon {
            font-size: 18px;
        }

        .collapsible-header .header-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .collapsible-header .header-text .subtitle {
            font-size: 11px;
            font-weight: 400;
            color: #6b7280;
        }

        .collapsible-header .chevron {
            width: 20px;
            height: 20px;
            fill: #9ca3af;
            transition: transform 0.3s ease;
            flex-shrink: 0;
        }

        .collapsible-section[open] .chevron {
            transform: rotate(180deg);
        }

        .collapsible-content {
            padding: 14px;
            background: #fafbfc;
            border-top: 1px solid #e5e7eb;
        }

        /* Drag handle indicator */
        .collapsible-header .drag-handle {
            cursor: grab;
            padding: 4px;
            opacity: 0.3;
            transition: opacity 0.2s;
            display: flex;
            flex-direction: column;
            width: 16px;
            flex-shrink: 0;
            gap: 2px;
            margin-right: 6px;
        }

        .collapsible-header .drag-handle:hover {
            opacity: 0.7;
        }

        .collapsible-header .drag-handle span {
            display: block;
            width: 12px;
            height: 2px;
            background: #9ca3af;
            border-radius: 1px;
        }

        .collapsible-section.dragging {
            opacity: 0.5;
            border: 2px dashed var(--anenome);
        }

        .collapsible-section.drag-over {
            border-top: 3px solid var(--anenome);
        }

        details.collapsible-section > summary {
            list-style: none;
        }
        details.collapsible-section > summary::-webkit-details-marker {
            display: none;
        }

        /* Help Section Special Styles */
        .help-section {
            border-color: var(--anenome);
        }

        .help-section .collapsible-header {
            background: white;
        }

        .help-section .collapsible-header h3 {
            color: var(--deep-dive);
        }

        .help-tip {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.1) 0%, rgba(0, 121, 255, 0.05) 100%);
            border-left: 4px solid var(--anenome);
            padding: 12px 14px;
            border-radius: 0 8px 8px 0;
            margin: 12px 0;
        }

        .help-tip h4 {
            color: var(--deep-dive);
            font-size: 13px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .help-tip p {
            color: var(--bottlenose);
            font-size: 12px;
            line-height: 1.5;
        }

        .formula-example-box {
            background: var(--deep-dive);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .formula-example-box code {
            color: var(--anenome);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            display: block;
            margin-bottom: 4px;
        }

        .formula-example-box .result {
            color: var(--chrome);
            font-size: 11px;
        }

        .dynamic-demo {
            background: white;
            border: 2px solid var(--tidal-wave);
            border-radius: 8px;
            padding: 14px;
            margin: 12px 0;
        }

        .dynamic-demo h5 {
            color: var(--tidal-wave);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .excel-grid {
            display: grid;
            grid-template-columns: 40px repeat(3, 1fr);
            gap: 2px;
            font-size: 11px;
            margin: 10px 0;
        }

        .excel-cell {
            background: white;
            border: 1px solid var(--barnacle);
            padding: 6px 8px;
            text-align: center;
            min-height: 28px;
        }

        .excel-cell.header {
            background: var(--barnacle);
            font-weight: 600;
            color: var(--deep-dive);
        }

        .excel-cell.row-header {
            background: var(--barnacle);
            font-weight: 600;
            color: var(--deep-dive);
        }

        .excel-cell.formula {
            background: rgba(10, 226, 193, 0.1);
            color: var(--deep-dive);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 9px;
        }

        .excel-cell.formula.drag-indicator {
            background: rgba(10, 226, 193, 0.25);
            border: 1px dashed var(--seafoam);
            position: relative;
        }

        .excel-cell.value {
            background: rgba(0, 121, 255, 0.1);
            color: var(--blue-light);
            font-weight: 500;
        }

        .settings-btn {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: rgba(255, 255, 255, 0.8);
        }

        .settings-btn svg {
            width: 16px;
            height: 16px;
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.22);
            transform: rotate(90deg);
            color: white;
        }

        .settings-btn:active {
            transform: rotate(90deg) scale(0.92);
        }

        .settings-btn svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Help button in header */

        /* Guide Me Wizard */
        .guide-me-card {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .guide-me-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .guide-me-card h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .guide-me-card p {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .guide-me-btn {
            background: var(--anenome);
            color: var(--deep-dive);
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .guide-me-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(10, 226, 193, 0.4);
        }

        .guide-me-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .guide-me-btn .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: var(--deep-dive);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .guide-me-dismiss {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .guide-me-dismiss:hover {
            background: rgba(255,255,255,0.3);
        }

        .guide-me-progress {
            margin-top: 16px;
            font-size: 12px;
            opacity: 0.8;
        }

        .guide-me-hidden {
            display: none;
        }

        /* Pre-load Sheet Data Card */
        .preload-card {
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .preload-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .preload-card h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preload-card p {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .preload-card .instruction-box {
            background: rgba(255,255,255,0.15);
            border-radius: 10px;
            padding: 12px 14px;
            margin-bottom: 16px;
            font-size: 12px;
            line-height: 1.6;
        }

        .preload-card .instruction-box strong {
            color: #7dffb3;
        }

        .preload-btn {
            background: #7dffb3;
            color: #1a5a3e;
            border: none;
            padding: 14px 24px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }

        .preload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(125, 255, 179, 0.4);
        }

        .preload-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .preload-dismiss {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255,255,255,0.2);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preload-dismiss:hover {
            background: rgba(255,255,255,0.3);
        }

        .preload-hidden {
            display: none;
        }

        /* Pre-load Loading Overlay */
        .preload-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            text-align: center;
            padding: 30px;
            animation: fadeIn 0.3s ease;
        }

        .preload-overlay .history-section {
            margin-top: 30px;
            padding: 20px 24px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            max-width: 340px;
            text-align: center;
            min-height: 100px;
        }

        .preload-overlay .history-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 8px;
        }

        .preload-overlay .history-year {
            font-size: 24px;
            font-weight: 700;
            color: #7dffb3;
            margin-bottom: 6px;
        }

        .preload-overlay .history-fact {
            font-size: 14px;
            color: #c8ffdb;
            transition: opacity 0.3s ease;
            line-height: 1.5;
        }

        /* Guide Me Choice Cards */
        .guide-choice {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 14px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .guide-choice:hover {
            background: rgba(10, 226, 193, 0.25);
            border-color: var(--anenome);
            transform: translateX(4px);
        }
        
        .guide-choice-icon {
            font-size: 28px;
            margin-right: 14px;
            flex-shrink: 0;
        }
        
        .guide-choice-content {
            flex: 1;
        }
        
        .guide-choice-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            margin-bottom: 3px;
        }
        
        .guide-choice-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.4;
        }

        /* Guide Me Loading Overlay */
        .guide-me-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(9, 35, 92, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 60px;
            color: white;
            padding-left: 30px;
            padding-right: 30px;
            text-align: center;
            animation: fadeIn 0.3s ease;
        }

        .guide-me-overlay h2 {
            font-size: 22px;
            margin-bottom: 16px;
        }

        .guide-me-overlay .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: var(--anenome);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .guide-me-overlay .loading-subtitle {
            font-size: 13px;
            opacity: 0.7;
            margin-bottom: 24px;
            max-width: 400px;
            text-align: center;
            word-wrap: break-word;
        }

        .guide-me-overlay .progress-container {
            width: 100%;
            max-width: 320px;
            margin-bottom: 20px;
        }

        .guide-me-overlay .progress-bar-bg {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .guide-me-overlay .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--anenome), #06d6a0);
            border-radius: 4px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .guide-me-overlay .progress-text {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 8px;
        }

        .guide-me-overlay .loading-step {
            font-size: 14px;
            margin-top: 16px;
            color: var(--anenome);
            font-weight: 600;
            min-height: 40px;
        }

        .guide-me-overlay .loading-step-desc {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 6px;
            max-width: 400px;
            text-align: center;
            word-wrap: break-word;
        }

        .guide-me-overlay .tips-section {
            margin-top: 30px;
            padding: 20px 24px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            width: calc(100% - 48px);
            max-width: 450px;
        }

        .guide-me-overlay .tips-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 8px;
            text-align: center;
        }

        .guide-me-overlay .loading-tip {
            font-size: 14px;
            color: var(--anenome);
            transition: opacity 0.3s ease;
            font-weight: 500;
            line-height: 1.7;
            display: block;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            padding: 8px 0;
            min-height: 48px;
            max-height: 72px;
            overflow: hidden;
        }
        
        /* Success overlay for generated reports */
        .report-success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }
        
        .report-success-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            max-width: 360px;
            width: 100%;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .report-success-card .close-x {
            position: absolute;
            top: 10px;
            right: 12px;
            background: none;
            border: none;
            font-size: 20px;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .report-success-card .close-x:hover {
            color: #374151;
        }
        
        .report-success-card h2 {
            color: #059669;
            font-size: 16px;
            margin: 0 0 10px 0;
            padding-right: 24px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .report-success-card .summary {
            background: #f0fdf4;
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 10px;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .report-success-card .summary strong {
            color: #065f46;
        }
        
        .report-success-card .tip-box {
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 11px;
            line-height: 1.4;
        }
        
        .report-success-card .tip-box.warning {
            background: rgba(255, 193, 7, 0.15);
            border-left: 3px solid #FFC107;
        }
        
        .report-success-card .tip-box.info {
            background: rgba(10, 226, 193, 0.1);
            border-left: 3px solid var(--anenome);
        }
        
        .report-success-card .dismiss-btn {
            width: 100%;
            background: linear-gradient(135deg, var(--deep-dive) 0%, #1a365d 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: sticky;
            bottom: 0;
        }
        
        .report-success-card .dismiss-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(9, 35, 92, 0.3);
        }

        /* Settings Panel (inline view, not modal) */
        .settings-view {
            display: none;
            flex-direction: column;
            height: 100%;
            background: white;
        }

        .settings-view.active {
            display: flex;
        }

        .main-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .main-view.hidden {
            display: none;
        }

        .settings-panel {
            background: white;
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .settings-header {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .settings-header h2 {
            font-size: 18px;
            font-weight: 600;
            flex: 1;
        }

        .settings-back {
            background: rgba(10, 226, 193, 0.3);
            border: none;
            color: white;
            font-size: 18px;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .settings-back:hover {
            background: var(--anenome);
        }

        .settings-content {
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-indicator.checking {
            background: #fef3c7;
            color: #92400e;
        }

        .status-indicator.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-indicator.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.checking { background: #f59e0b; animation: pulse 1s infinite; }
        .status-dot.connected { background: #10b981; }
        .status-dot.error { background: #ef4444; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Subtle spreadsheet animation for tidying up step */
        .spreadsheet-animation {
            display: inline-block;
            animation: spreadsheet-bounce 1.2s ease-in-out infinite;
        }
        
        @keyframes spreadsheet-bounce {
            0%, 100% { 
                transform: translateY(0) scale(1);
            }
            25% { 
                transform: translateY(-2px) scale(1.05);
            }
            50% { 
                transform: translateY(0) scale(1);
            }
            75% { 
                transform: translateY(-1px) scale(1.02);
            }
        }

        .settings-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 8px;
            transition: border-color 0.2s;
        }

        .settings-input:focus {
            outline: none;
            border-color: #0066CC;
        }

        .settings-btn-action {
            background: var(--blue-light);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .settings-btn-action:hover {
            background: var(--deep-dive);
            transform: translateY(-1px);
        }

        .settings-btn-action.secondary {
            background: var(--bottlenose);
        }

        .settings-btn-action.secondary:hover {
            background: var(--deep-dive);
        }

        /* .content styling moved to bottom of CSS - see "CRITICAL: Content area" section */

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: transparent;
            color: #6b7280;
            padding: 8px 0;
            font-size: 12px;
            font-weight: 400;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .status-badge:hover {
            color: #374151;
        }

        .status-badge.connected {
            color: #374151;
        }

        .status-badge.disconnected {
            color: #dc2626;
        }

        .status-badge.checking {
            color: #d97706;
        }

        .status-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--anenome);
            border-radius: 50%;
        }

        .status-badge.disconnected::before {
            background: #dc2626;
        }
        
        .status-badge.checking::before {
            background: #d97706;
            animation: pulse 1s infinite;
        }

        .status-badge.checking::before {
            background: var(--deep-dive);
            animation: pulse-check 0.8s ease-in-out infinite;
        }

        @keyframes pulse-error {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        @keyframes pulse-check {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Primary action button */
        .btn-primary {
            background: linear-gradient(135deg, var(--blue-light) 0%, var(--tidal-wave) 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 79, 182, 0.35);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bottlenose);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn-secondary:hover {
            background: var(--deep-dive);
        }

        .btn-danger {
            background: #dc2626;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        .refresh-status {
            font-size: 12px;
            color: var(--anenome);
            text-align: center;
            margin-top: 10px;
            min-height: 20px;
            font-weight: 500;
        }

        .btn-hint {
            font-size: 11px;
            color: var(--bottlenose);
            margin: 4px 0 12px;
            line-height: 1.4;
        }

        /* ============================================
           DATA MANAGEMENT REDESIGN
           ============================================ */
        .data-mgmt-section .collapsible-header {
            background: white;
        }
        
        .data-mgmt-section .collapsible-header h3 {
            color: var(--deep-dive);
        }
        
        .data-mgmt-section .chevron {
            fill: var(--bottlenose);
        }
        
        .data-mgmt-content {
            padding: 0 !important;
            background: #f8f9fc;
        }
        
        .data-section {
            padding: 16px;
            border-bottom: 1px solid var(--barnacle);
        }
        
        .data-section:last-child {
            border-bottom: none;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .section-header h4 {
            font-size: 13px;
            font-weight: 600;
            color: var(--deep-dive);
            margin: 0;
        }
        
        /* Help Icon with Tooltip */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: var(--chrome);
            color: var(--deep-dive);
            border-radius: 50%;
            font-size: 11px;
            font-weight: 700;
            cursor: help;
            transition: all 0.2s;
            position: relative;
        }
        
        .help-icon:hover {
            background: var(--tidal-wave);
            color: white;
        }
        
        .help-icon.small {
            width: 14px;
            height: 14px;
            font-size: 9px;
        }
        
        /* Lightweight tooltip - smaller, lighter background, left-aligned */
        .help-icon[data-tip] {
            position: relative;
            cursor: help;
        }
        
        .help-icon[data-tip]:hover::after {
            content: attr(data-tip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            max-width: 280px;
            background: #1a365d;
            color: white;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 400;
            white-space: normal;
            line-height: 1.5;
            text-align: left;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            animation: tooltipFadeIn 0.15s ease-out;
            pointer-events: none;
        }
        
        /* Arrow pointing down from tooltip */
        .help-icon[data-tip]:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1a365d;
            z-index: 10001;
        }
        
        /* If tooltip would go off left edge, align left instead */
        .help-icon[data-tip].tip-left:hover::after {
            left: 0;
            transform: none;
        }
        
        /* If tooltip would go off right edge, align right instead */
        .help-icon[data-tip].tip-right:hover::after {
            left: auto;
            right: 0;
            transform: none;
        }
        
        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(4px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        /* Tooltip label styling */
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dotted currentColor;
        }
        
        /* Load Data Button */
        .btn-load-data {
            width: 100%;
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-load-data:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(26, 90, 62, 0.4);
        }
        
        .btn-load-data:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Checkbox Row */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            cursor: pointer;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--barnacle);
        }
        
        .checkbox-row:hover {
            border-color: var(--tidal-wave);
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--tidal-wave);
            cursor: pointer;
        }
        
        .checkbox-label {
            font-size: 13px;
            color: var(--deep-dive);
            flex: 1;
        }
        
        /* Action Grid */
        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 8px;
            border: 1px solid var(--barnacle);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .action-btn:hover {
            border-color: var(--tidal-wave);
            box-shadow: 0 2px 8px rgba(0, 121, 255, 0.15);
        }
        
        .action-btn .action-icon {
            font-size: 20px;
        }
        
        .action-btn .action-text {
            font-size: 11px;
            font-weight: 600;
            color: var(--deep-dive);
        }
        
        .action-btn .help-icon {
            position: absolute;
            top: 4px;
            right: 4px;
        }
        
        .action-btn.primary {
            background: linear-gradient(135deg, rgba(0, 79, 182, 0.08) 0%, rgba(0, 121, 255, 0.08) 100%);
            border-color: var(--tidal-wave);
        }
        
        .action-btn.primary:hover {
            background: linear-gradient(135deg, rgba(0, 79, 182, 0.15) 0%, rgba(0, 121, 255, 0.15) 100%);
        }
        
        .action-btn.warning {
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.08) 0%, rgba(245, 158, 11, 0.08) 100%);
            border-color: #d97706;
        }
        
        .action-btn.warning:hover {
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.15) 0%, rgba(245, 158, 11, 0.15) 100%);
            border-color: #b45309;
        }
        
        .action-btn.danger {
            grid-column: span 2;
        }
        
        .action-btn.danger:hover {
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
        }
        
        .preload-status {
            margin-top: 12px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
        }

        /* Filter Groups */
        .filter-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: end;
            margin-bottom: 12px;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 4px;
            grid-column: 1 / -1;
        }

        .filter-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--barnacle);
            border-radius: 8px;
            font-size: 13px;
            color: var(--deep-dive);
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--tidal-wave);
        }

        .btn-filter {
            background: var(--tidal-wave);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-filter:hover {
            background: var(--blue-light);
        }

        /* Account Search Styles */
        .search-input {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--barnacle);
            border-radius: 8px;
            font-size: 14px;
            color: var(--deep-dive);
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--anenome);
            box-shadow: 0 0 0 3px rgba(10, 226, 193, 0.15);
        }

        .search-input::placeholder {
            color: var(--chrome);
        }

        .search-hints {
            background: rgba(10, 226, 193, 0.08);
            border-radius: 8px;
            padding: 10px 12px;
            margin-top: 10px;
        }

        .search-hints code {
            background: var(--deep-dive);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* Footer */
        .footer {
            background: var(--deep-dive);
            color: var(--chrome);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            position: relative;
        }
        
        .footer-content {
            flex: 1;
        }
        
        .footer-content p {
            margin: 0;
            line-height: 1.4;
        }
        
        .footer-version {
            color: var(--anenome);
            font-weight: 500;
            margin-top: 2px !important;
        }

        .footer a {
            color: var(--anenome);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
        
        .intercom-chat-btn {
            background: linear-gradient(135deg, #0AE2C1 0%, #00C9A7 100%);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(10, 226, 193, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .intercom-chat-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(10, 226, 193, 0.5);
        }
        
        .intercom-chat-btn svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Compact Formula Card */
        .formula-card {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--barnacle);
            border-radius: 8px;
            margin-bottom: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .formula-card:hover {
            border-color: var(--tidal-wave);
        }
        
        .formula-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(168, 177, 206, 0.15) 0%, rgba(211, 216, 230, 0.25) 100%);
        }
        
        .formula-header:hover {
            background: linear-gradient(135deg, rgba(168, 177, 206, 0.25) 0%, rgba(211, 216, 230, 0.35) 100%);
        }
        
        .formula-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .formula-name {
            font-size: 13px;
            font-weight: 700;
            color: var(--blue-light);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            white-space: nowrap;
        }
        
        .formula-brief {
            font-size: 11px;
            color: var(--bottlenose);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .formula-expand-icon {
            width: 16px;
            height: 16px;
            color: var(--bottlenose);
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .formula-card.expanded .formula-expand-icon {
            transform: rotate(180deg);
        }

        .formula-description {
            font-size: 11px;
            color: var(--bottlenose);
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .formula-details {
            display: none;
            padding: 12px;
            border-top: 1px solid var(--barnacle);
            background: white;
        }
        
        .formula-card.expanded .formula-details {
            display: block;
        }

        .formula-syntax {
            background: var(--deep-dive);
            border-radius: 4px;
            padding: 8px 10px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 10px;
            color: var(--anenome);
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .parameters {
            margin-top: 8px;
        }

        .param-title {
            font-size: 9px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .param-item {
            font-size: 11px;
            color: var(--bottlenose);
            margin-bottom: 2px;
            padding-left: 8px;
            line-height: 1.3;
        }
        
        .param-name {
            font-weight: 600;
            color: var(--deep-dive);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
        }

        .example {
            background: rgba(10, 226, 193, 0.08);
            border-left: 2px solid var(--anenome);
            padding: 8px 10px;
            margin-top: 8px;
            border-radius: 3px;
        }
        
        .example-title {
            font-size: 9px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .example-code {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 10px;
            color: var(--deep-dive);
            background: var(--barnacle);
            padding: 3px 6px;
            border-radius: 3px;
            display: inline-block;
            margin: 1px 0;
        }
        
        .example-result {
            font-size: 10px;
            color: var(--bottlenose);
            font-style: italic;
            margin-left: 8px;
        }

        .example-result {
            font-size: 10px;
            color: var(--bottlenose);
            margin-left: 8px;
            font-style: italic;
        }


        /* Loading Overlay - Modern & Animated */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(9, 35, 92, 0.97) 0%, rgba(0, 79, 182, 0.97) 100%);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease-in-out;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
            color: white;
            max-width: 90%;
            width: 420px;
            padding: 40px 24px;
        }
        
        .loading-funfact {
            margin-top: 24px;
            padding: 16px 20px;
            background: rgba(10, 226, 193, 0.15);
            border-radius: 12px;
            border: 1px solid rgba(10, 226, 193, 0.3);
            text-align: left;
            display: flex;
            gap: 12px;
            align-items: flex-start;
            min-height: 80px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .funfact-icon {
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .funfact-text {
            font-size: 13px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.95);
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex: 1;
        }
        
        .funfact-text strong {
            color: var(--anenome);
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(168, 177, 206, 0.3);
            border-top: 4px solid var(--anenome);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 12px;
            color: white;
        }

        .loading-message {
            font-size: 14px;
            color: var(--chrome);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .loading-progress {
            background: rgba(168, 177, 206, 0.2);
            border-radius: 20px;
            height: 6px;
            overflow: hidden;
            margin-top: 20px;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--anenome), var(--tidal-wave));
            border-radius: 20px;
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(10, 226, 193, 0.5);
        }

        .loading-stats {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 15px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        
        .cancel-btn {
            margin-top: 20px;
            padding: 10px 24px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cancel-btn:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.02);
        }
        
        .cancel-btn:disabled {
            background: rgba(107, 114, 128, 0.5);
            cursor: not-allowed;
        }
        
        /* Floating status widget for special formulas */
        .floating-status {
            position: fixed;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background: linear-gradient(135deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 12px;
            padding: 14px 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .floating-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .floating-status-title {
            color: #93c5fd;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .floating-status-dismiss {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            line-height: 1;
        }
        
        .floating-status-dismiss:hover {
            color: white;
        }
        
        .floating-status-message {
            color: white;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .floating-status-detail {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .floating-status-progress {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .floating-status-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Drill-Down Status Widget */
        .drilldown-status {
            position: fixed;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background: linear-gradient(135deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            display: none;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .drilldown-status.success {
            background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
            border-color: rgba(16, 185, 129, 0.4);
        }
        
        .drilldown-status.error {
            background: linear-gradient(135deg, #7f1d1d 0%, #450a0a 100%);
            border-color: rgba(239, 68, 68, 0.4);
        }
        
        .drilldown-status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .drilldown-status-icon { font-size: 20px; }
        
        .drilldown-status-title {
            color: #93c5fd;
            font-size: 14px;
            font-weight: 600;
            flex: 1;
        }
        
        .drilldown-status.success .drilldown-status-title { color: #6ee7b7; }
        .drilldown-status.error .drilldown-status-title { color: #fca5a5; }
        
        .drilldown-status-dismiss {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 20px;
            padding: 0;
            line-height: 1;
        }
        
        .drilldown-status-dismiss:hover { color: white; }
        
        .drilldown-status-message {
            color: white;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .drilldown-status-detail {
            color: rgba(255,255,255,0.7);
            font-size: 12px;
        }
        
        .drilldown-status-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .drilldown-status.success .drilldown-status-spinner,
        .drilldown-status.error .drilldown-status-spinner { display: none; }

        /* ================================================================
           QUICK ACTIONS BAR - Always visible at bottom
           ================================================================ */
        .quick-actions-bar {
            /* NOT position: fixed - part of flex layout to prevent overlap */
            flex-shrink: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(139, 92, 246, 0.08) 100%);
            border-top: 1px solid rgba(59, 130, 246, 0.2);
            padding: 12px 12px 14px 12px;
            margin: 0;
            z-index: 900;
            box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.08);
        }
        
        .quick-actions-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .quick-action-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-action-btn.primary {
            background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%);
            color: var(--deep-dive);
        }
        
        .quick-action-btn.secondary {
            background: linear-gradient(135deg, var(--deep-dive) 0%, #1e3a5f 100%);
            color: white;
        }
        
        .quick-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .quick-action-btn:active {
            transform: translateY(0);
        }
        
        .quick-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .quick-actions-hint {
            display: flex;
            justify-content: center;
            gap: 16px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .quick-actions-hint span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .quick-action-help {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            background: rgba(255, 255, 255, 0.5);
            color: var(--deep-sea);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 4px;
        }
        
        .quick-action-help:hover {
            background: rgba(255, 255, 255, 0.8);
            color: var(--deep-dive);
            border-color: var(--tidal-wave);
        }
        
        .quick-action-help svg {
            width: 18px;
            height: 18px;
        }
        
        /* Formula count footer */
        .quick-actions-footer {
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 8px;
            margin-top: 8px;
            border-top: 1px solid rgba(59, 130, 246, 0.15);
            font-size: 11px;
            color: var(--bottlenose);
        }
        
        .quick-actions-footer.has-formulas {
            color: #047857;
            font-weight: 500;
        }
        
        /* Contextual Status Badge */
        .quick-actions-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 20px;
            font-size: 11px;
            color: var(--deep-sea);
            transition: all 0.3s;
            border: 1px solid rgba(59, 130, 246, 0.15);
        }
        
        .quick-actions-status.has-formulas {
            background: rgba(10, 226, 193, 0.2);
            color: #047857;
            border-color: rgba(10, 226, 193, 0.3);
        }
        
        .quick-actions-status.empty-sheet {
            background: rgba(251, 191, 36, 0.2);
            color: #92400e;
            border-color: rgba(251, 191, 36, 0.3);
        }
        
        .quick-actions-status.has-selection {
            background: rgba(59, 130, 246, 0.2);
            color: #1d4ed8;
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .quick-actions-status.calculating {
            background: rgba(139, 92, 246, 0.2);
            color: #6d28d9;
            border-color: rgba(139, 92, 246, 0.3);
        }
        
        .status-badge-icon {
            font-size: 12px;
        }
        
        .status-badge-text {
            font-weight: 500;
        }
        
        /* Button contextual states */
        .quick-action-btn.highlight {
            animation: pulse-highlight 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-highlight {
            0%, 100% { box-shadow: 0 0 0 0 rgba(10, 226, 193, 0.4); }
            50% { box-shadow: 0 0 0 6px rgba(10, 226, 193, 0); }
        }
        
        .quick-action-btn.ready {
            opacity: 1;
        }
        
        .quick-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .quick-action-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* ========================================
           CONTEXT-AWARE PARAMETER POPUP
           Shows filter when parameter cell selected
           Light theme with Tidal Wave accent for contrast with dark header
           ======================================== */
        .param-context-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            padding: 12px 16px;
            z-index: 1000;
            transform: translateY(-100%);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
            box-shadow: 0 4px 20px rgba(0, 121, 255, 0.15), 0 2px 8px rgba(0,0,0,0.1);
            border-bottom: 3px solid var(--tidal-wave);
        }
        
        .param-context-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        .param-context-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .param-context-title {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--deep-dive);
            font-weight: 600;
            font-size: 13px;
        }
        
        .param-context-title .param-icon {
            font-size: 16px;
        }
        
        .param-context-cell {
            background: var(--tidal-wave);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .param-context-close {
            background: rgba(0, 121, 255, 0.1);
            border: none;
            color: var(--tidal-wave);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .param-context-close:hover {
            background: var(--tidal-wave);
            color: white;
        }
        
        .param-context-body {
            display: flex;
            gap: 10px;
            align-items: center;
            min-width: 0; /* Allow flex children to shrink below content size */
        }
        
        .param-context-select {
            flex: 1 1 auto;
            min-width: 0; /* Critical: allows select to shrink */
            padding: 8px 12px;
            border: 2px solid var(--barnacle);
            border-radius: 6px;
            background: white;
            font-size: 13px;
            color: var(--deep-dive);
            cursor: pointer;
            transition: border-color 0.2s;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .param-context-select:focus {
            outline: none;
            border-color: var(--tidal-wave);
        }
        
        .param-context-input {
            flex: 1 1 auto;
            min-width: 80px; /* Minimum usable width for input */
            padding: 8px 12px;
            border: 2px solid var(--barnacle);
            border-radius: 6px;
            background: white;
            font-size: 13px;
            color: var(--deep-dive);
            transition: border-color 0.2s;
        }
        
        .param-context-input:focus {
            outline: none;
            border-color: var(--tidal-wave);
        }
        
        .param-context-btn {
            flex: 0 0 auto; /* Never shrink, never grow */
            background: var(--tidal-wave);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .param-context-btn:hover {
            background: #0066dd;
            transform: translateY(-1px);
        }
        
        .param-context-hint {
            margin-top: 8px;
            font-size: 11px;
            color: var(--bottlenose);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .param-context-hint code {
            background: rgba(0, 121, 255, 0.1);
            color: var(--tidal-wave);
            padding: 1px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Quick Actions Help Modal */
        .quick-help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .quick-help-modal.active {
            display: flex;
        }
        
        .quick-help-content {
            background: linear-gradient(135deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 16px;
            padding: 24px;
            max-width: 320px;
            width: 100%;
            position: relative;
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }
        
        .quick-help-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }
        
        .quick-help-close:hover {
            color: white;
        }
        
        .quick-help-content h3 {
            color: white;
            margin: 0 0 20px 0;
            font-size: 18px;
        }
        
        .quick-help-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .quick-help-item {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }
        
        .quick-help-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .quick-help-item strong {
            color: #93c5fd;
            display: block;
            font-size: 13px;
            margin-bottom: 4px;
        }
        
        .quick-help-item p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            line-height: 1.5;
            margin: 0;
        }
        
        .quick-help-tip {
            margin-top: 20px;
            padding: 12px;
            background: rgba(10, 226, 193, 0.1);
            border-radius: 8px;
            border-left: 3px solid var(--anenome);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
        }
        
        .quick-help-tip strong {
            color: var(--anenome);
        }

        /* ================================================================
           INTERACTIVE ONBOARDING WIZARD
           ================================================================ */
        .onboarding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 16px;
        }
        
        .onboarding-overlay.active {
            display: flex;
        }
        
        .onboarding-wizard {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            border-radius: 20px;
            padding: 24px 20px;
            max-width: 340px;
            width: calc(100% - 24px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .onboarding-progress {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            max-width: 200px;
        }
        
        .progress-bar-container .segment {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .progress-bar-container .segment.completed {
            background: #22c55e;
        }
        
        .progress-bar-container .segment.active {
            background: var(--anenome);
            box-shadow: 0 0 8px rgba(10, 226, 193, 0.4);
        }
        
        .progress-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
            white-space: nowrap;
        }
        
        .onboarding-exit-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .onboarding-exit-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
            transform: scale(1.1);
        }
        
        .onboarding-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .onboarding-restart {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            cursor: pointer;
        }
        
        .onboarding-restart:hover {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .overwrite-warning {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            margin: 12px 0;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.85);
            text-align: left;
        }
        
        .overwrite-warning strong {
            color: #fbbf24;
        }
        
        .onboarding-tip {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin: 12px 0;
            padding: 8px 10px;
            background: rgba(10, 226, 193, 0.1);
            border-radius: 6px;
            text-align: left;
        }
        
        .onboarding-tip strong {
            color: var(--anenome);
        }
        
        /* #BUSY notice for when formulas are loading */
        .busy-notice {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            margin: 12px 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .busy-notice.small {
            padding: 8px 12px;
            font-size: 11px;
        }
        
        .busy-notice .busy-icon {
            font-size: 14px;
        }
        
        .busy-notice strong {
            color: #fbbf24;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
        }
        
        .onboarding-step {
            display: none;
            text-align: center;
        }
        
        .onboarding-step.active {
            display: block;
            animation: fadeInUp 0.3s ease;
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .onboarding-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .onboarding-step h2 {
            color: white;
            font-size: 22px;
            margin: 0 0 8px 0;
            font-weight: 700;
        }
        
        /* Step type badges */
        .step-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .step-type-badge.action {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4);
        }
        
        .step-type-badge.tip {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.2) 0%, rgba(6, 214, 160, 0.2) 100%);
            color: var(--anenome);
            border: 1px solid var(--anenome);
        }
        
        .step-type-badge.celebrate {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        
        .onboarding-subtitle {
            color: var(--anenome);
            font-size: 14px;
            margin: 0 0 16px 0;
        }
        
        .onboarding-desc {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            line-height: 1.6;
            margin: 0 0 20px 0;
        }
        
        .onboarding-time {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            margin-bottom: 20px;
        }
        
        .onboarding-btn {
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        
        .onboarding-btn.primary {
            background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%);
            color: var(--deep-dive);
        }
        
        .onboarding-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(10, 226, 193, 0.3);
        }
        
        .onboarding-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .onboarding-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .onboarding-btn.text {
            background: none;
            color: rgba(255, 255, 255, 0.5);
            padding: 12px 16px;
        }
        
        .onboarding-btn.text:hover {
            color: white;
        }
        
        .onboarding-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .onboarding-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .onboarding-input:focus {
            outline: none;
            border-color: var(--anenome);
            background: rgba(10, 226, 193, 0.05);
        }
        
        .onboarding-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }
        
        .sample-accounts-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 16px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .sample-account-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .sample-account-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .sample-account-item .account-number {
            font-family: monospace;
            color: var(--anenome);
            font-weight: 600;
        }
        
        .sample-account-item .account-name {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            text-align: right;
            max-width: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .onboarding-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        
        .onboarding-highlight-box {
            background: rgba(10, 226, 193, 0.1);
            border: 1px solid rgba(10, 226, 193, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .formula-display {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: var(--anenome);
            margin-bottom: 8px;
            word-break: break-all;
        }
        
        .result-display {
            font-size: 20px;
            font-weight: 700;
            color: white;
        }
        
        .drag-demo-container {
            margin: 20px 0;
        }
        
        .drag-demo-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            position: relative;
        }
        
        .demo-cell {
            width: 100px;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
        }
        
        .demo-cell.filled {
            background: rgba(10, 226, 193, 0.2);
            border: 2px solid var(--anenome);
            color: var(--anenome);
        }
        
        .demo-cell.empty {
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.4);
        }
        
        .demo-arrow {
            position: absolute;
            right: -50px;
            top: 50%;
            transform: translateY(-50%);
            color: #fbbf24;
            font-size: 12px;
            font-weight: 600;
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(-50%) translateX(0); }
            50% { transform: translateY(-50%) translateX(5px); }
        }
        
        .drag-demo-visual.horizontal {
            flex-direction: row;
            gap: 6px;
        }
        
        .drag-demo-visual.horizontal .demo-cell {
            width: auto;
            padding: 8px 12px;
            font-size: 11px;
        }
        
        .demo-arrow-right {
            position: absolute;
            right: -45px;
            top: 50%;
            transform: translateY(-50%);
            color: #fbbf24;
            font-size: 12px;
            font-weight: 600;
            animation: bounceRight 1s infinite;
        }
        
        @keyframes bounceRight {
            0%, 100% { transform: translateY(-50%) translateX(0); }
            50% { transform: translateY(-50%) translateX(5px); }
        }
        
        .cheat-sheet {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            text-align: left;
        }
        
        .cheat-item {
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .cheat-item:last-child {
            border-bottom: none;
        }
        
        .cheat-item code {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 11px;
            color: var(--anenome);
            margin-bottom: 4px;
        }
        
        .cheat-item span {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .cheat-sheet.compact .cheat-item {
            padding: 6px 10px;
        }
        
        .cheat-sheet.compact .cheat-item code {
            font-size: 10px;
        }
        
        /* Onboarding Examples */
        .onboarding-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 12px 0;
        }
        
        .example-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .example-item code {
            color: var(--anenome);
            margin-right: 4px;
        }
        
        /* Steps List */
        .onboarding-steps-list {
            text-align: left;
            margin: 12px 0;
        }
        
        .step-item {
            padding: 6px 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .step-item code {
            background: rgba(10, 226, 193, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--anenome);
        }
        
        /* Dynamic Params */
        .dynamic-params-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin: 12px 0;
            text-align: left;
        }
        
        .param-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .param-label {
            background: rgba(59, 130, 246, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            color: #93c5fd;
            font-family: monospace;
            font-size: 11px;
        }
        
        /* Compact highlight box */
        .onboarding-highlight-box.compact {
            padding: 12px;
            margin: 10px 0;
        }
        
        .formula-display.small {
            font-size: 11px;
        }
        
        /* Drill Demo Box */
        .drill-demo-box {
            margin: 16px 0;
            padding: 14px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 10px;
            text-align: center;
        }
        
        .drill-demo-btn {
            background: linear-gradient(135deg, var(--tidal-wave) 0%, #60a5fa 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .drill-demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .drill-demo-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 10px;
            transition: all 0.3s;
        }
        
        /* Celebration Graphics */
        .onboarding-celebration {
            position: relative;
            height: 100px;
            margin-bottom: 10px;
        }
        
        .spreadsheet-party {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(2, 35px);
            gap: 4px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .cell-char {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            animation: cellPop 0.5s ease-out backwards;
        }
        
        .cell-a1 { animation-delay: 0.1s; }
        .cell-b1 { animation-delay: 0.2s; }
        .cell-c1 { animation-delay: 0.3s; }
        .cell-a2 { animation-delay: 0.4s; }
        .cell-b2 { animation-delay: 0.5s; }
        .cell-c2 { animation-delay: 0.6s; }
        
        @keyframes cellPop {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .confetti-container {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 80px;
            pointer-events: none;
        }
        
        .confetti {
            position: absolute;
            font-size: 16px;
            animation: confettiFall 3s ease-out infinite;
            opacity: 0;
        }
        
        .confetti:nth-child(1) { left: 10%; animation-delay: 0s; color: #fbbf24; }
        .confetti:nth-child(2) { left: 25%; animation-delay: 0.3s; color: #22c55e; }
        .confetti:nth-child(3) { left: 40%; animation-delay: 0.6s; color: #3b82f6; }
        .confetti:nth-child(4) { left: 55%; animation-delay: 0.2s; color: #ec4899; }
        .confetti:nth-child(5) { left: 70%; animation-delay: 0.5s; color: #8b5cf6; }
        .confetti:nth-child(6) { left: 85%; animation-delay: 0.8s; color: #14b8a6; }
        
        @keyframes confettiFall {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(80px) rotate(360deg); opacity: 0; }
        }
        
        .onboarding-desc.geeky {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: var(--anenome);
        }
        
        .celebration-btn {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace !important;
        }
        
        .more-formulas-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin: 12px 0 8px 0;
            padding: 8px 12px;
            background: rgba(59, 130, 246, 0.15);
            border-radius: 6px;
            border-left: 3px solid var(--tidal-wave);
        }
        
        .final-tip {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 12px;
            line-height: 1.5;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .final-tip code {
            background: rgba(255, 255, 255, 0.1);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
        }
        
        /* Onboarding Confirm Dialog */
        .onboarding-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 20px;
        }
        
        .onboarding-confirm-dialog {
            background: linear-gradient(135deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 16px;
            padding: 24px;
            max-width: 300px;
            text-align: center;
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }
        
        .onboarding-confirm-dialog h3 {
            color: white;
            margin: 0 0 12px 0;
            font-size: 18px;
        }
        
        .onboarding-confirm-dialog p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            line-height: 1.5;
            margin: 0 0 20px 0;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 10px;
        }
        
        .confirm-btn {
            flex: 1;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        
        .confirm-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .confirm-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .confirm-btn.ok {
            background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%);
            color: var(--deep-dive);
        }
        
        .confirm-btn.ok:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(10, 226, 193, 0.3);
        }

        /* ================================================================
           VIEW MODE TOGGLE - Progressive Disclosure
           ================================================================ */
        .view-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 0 -12px 12px -12px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .view-mode-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--deep-sea);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .view-mode-switch {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-mode-switch label {
            font-size: 11px;
            color: var(--bottlenose);
            cursor: pointer;
        }
        
        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: #cbd5e1;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle-switch.active {
            background: var(--anenome);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Section visibility for progressive disclosure */
        .collapsible-section.secondary-section {
            display: none;
        }
        
        .show-all-sections .collapsible-section.secondary-section {
            display: block;
        }
        
        /* Contextual section highlighting */
        .collapsible-section.contextual-highlight {
            border-left: 3px solid var(--anenome);
            background: rgba(10, 226, 193, 0.05);
        }

        /* ================================================================
           CRITICAL: Content area is the ONLY scrollable area
           Quick-actions-bar is now part of flex layout (not fixed)
           ================================================================ */
        .content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            padding-bottom: 20px;
        }
        
        .tab-panel {
            padding-bottom: 20px;
        }
        
        /* Ensure accordions have proper bottom spacing */
        .accordion:last-child {
            margin-bottom: 20px;
        }
        
        /* Collapsed content scrolls if too tall */
        .collapsible-content {
            padding-bottom: 16px;
            max-height: 500px;
            overflow-y: auto;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.1) 0%, rgba(0, 121, 255, 0.05) 100%);
            border: 1px solid var(--anenome);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
        }

        .info-box p {
            font-size: 12px;
            color: var(--deep-dive);
            line-height: 1.5;
        }

        .info-box strong {
            color: var(--blue-light);
        }

        .info-box code {
            background: var(--deep-dive);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 320px;
            pointer-events: none;
        }

        .toast {
            background: var(--deep-dive);
            border-radius: 10px;
            padding: 14px 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: toastSlideIn 0.3s ease-out;
            pointer-events: auto;
            border-left: 4px solid var(--anenome);
        }

        .toast.info { border-left-color: var(--tidal-wave); }
        .toast.success { border-left-color: #10b981; }
        .toast.warning { border-left-color: #f59e0b; }
        .toast.error { border-left-color: #ef4444; }
        .toast.error.persistent-error {
            border-left-width: 5px;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.25);
        }
        .toast.error.persistent-error .toast-title {
            color: #dc2626;
            font-weight: 600;
        }
        .toast.calculating { border-left-color: #8b5cf6; }

        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .toast-content {
            flex: 1;
            min-width: 0;
        }

        .toast-title {
            font-weight: 600;
            font-size: 13px;
            color: white;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 11px;
            color: var(--chrome);
            line-height: 1.4;
            word-break: break-word;
        }

        .toast-message code {
            background: rgba(10, 226, 193, 0.2);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            display: inline-block;
            margin-top: 4px;
            cursor: pointer;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--chrome);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .toast-close:hover {
            opacity: 1;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: toastSlideOut 0.3s ease-in forwards;
        }

        .toast-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-top: 2px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Context-Aware Parameter Popup -->
    <div class="param-context-popup" id="paramContextPopup">
        <div class="param-context-header">
            <div class="param-context-title">
                <span class="param-icon" id="paramContextIcon"></span>
                <span id="paramContextLabel">Subsidiary</span>
                <span class="param-context-cell" id="paramContextCell">Q3</span>
            </div>
            <button class="param-context-close" onclick="hideParamContextPopup()" title="Close"></button>
        </div>
        <div class="param-context-body">
            <select class="param-context-select" id="paramContextSelect" style="display: none;">
                <option value="">Loading...</option>
            </select>
            <input type="text" class="param-context-input" id="paramContextInput" placeholder="Enter value..." style="display: none;">
            <button class="param-context-btn" onclick="applyParamContextValue()">Apply</button>
        </div>
        <div class="param-context-hint" id="paramContextHint">
             <span id="paramContextHintText">Select a value and click Apply to update the cell</span>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-title" id="loadingTitle">Processing...</div>
            <div class="loading-message" id="loadingMessage">Please wait while we fetch data from NetSuite</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgressBar"></div>
            </div>
            <div class="loading-stats" id="loadingStats"></div>
            <button id="cancelRefreshBtn" class="cancel-btn" onclick="cancelRefresh()" style="display: none;">
                 Cancel Refresh
            </button>
            <div class="loading-funfact" id="loadingFunFact">
                <div class="funfact-icon"></div>
                <div class="funfact-text" id="funfactText"></div>
            </div>
        </div>
    </div>

    <!-- Floating Status Widget for Special Formulas -->
    <div class="floating-status" id="floatingStatus">
        <div class="floating-status-header">
            <span class="floating-status-title"> Background Processing</span>
            <button class="floating-status-dismiss" onclick="hideFloatingStatus()"></button>
        </div>
        <div class="floating-status-message" id="floatingStatusMessage">Processing special formulas...</div>
        <div class="floating-status-detail" id="floatingStatusDetail">You can continue working while these complete.</div>
        <div class="floating-status-progress">
            <div class="floating-status-progress-bar" id="floatingStatusProgressBar" style="width: 0%"></div>
        </div>
    </div>
    
    <!-- Drill-Down Status Widget -->
    <div class="drilldown-status" id="drilldownStatus">
        <div class="drilldown-status-header">
            <span class="drilldown-status-icon" id="drilldownIcon"></span>
            <span class="drilldown-status-title" id="drilldownTitle">Transaction Drill-Down</span>
            <button class="drilldown-status-dismiss" id="drilldownDismiss" onclick="hideDrilldownStatus()" style="display: none;"></button>
        </div>
        <div class="drilldown-status-message" id="drilldownMessage">Analyzing selected cell...</div>
        <div class="drilldown-status-detail" id="drilldownDetail"></div>
        <div class="drilldown-status-spinner" id="drilldownSpinner"></div>
    </div>

    <!-- Settings View (inline, replaces main content) -->
    <div class="settings-view" id="settingsView">
        <div class="settings-panel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeSettings()" title="Back to main">
                    
                </button>
                <h2> Settings</h2>
            </div>
            <div class="settings-content">
                <!-- Connection Status -->
                <div class="settings-section">
                    <h3> Connection Status</h3>
                    <div style="display: grid; gap: 8px; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: #f9fafb; border-radius: 6px;">
                            <span style="font-size: 12px; color: #4b5563; font-weight: 500;">Backend Server</span>
                            <div id="serverStatus" class="status-indicator checking" style="margin: 0; padding: 4px 10px; font-size: 11px;">
                        <span class="status-dot checking"></span>
                        Checking...
                    </div>
                        </div>
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: #f9fafb; border-radius: 6px;">
                            <span style="font-size: 12px; color: #4b5563; font-weight: 500;">Cloudflare Tunnel</span>
                            <div id="tunnelStatus" class="status-indicator checking" style="margin: 0; padding: 4px 10px; font-size: 11px;">
                                <span class="status-dot checking"></span>
                                Checking...
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="settings-btn-action" onclick="checkServerStatus()" style="flex: 1;">
                             Refresh
                        </button>
                        <button class="settings-btn-action secondary" onclick="reloadLookups()" style="flex: 1;">
                             Reload Lookups
                        </button>
                    </div>
                </div>

                <!-- NetSuite Account Info -->
                <div class="settings-section">
                    <h3> NetSuite Account</h3>
                    <button class="settings-btn-action" id="checkPermissionsBtn" style="width: 100%; margin-bottom: 12px;">
                         Test NetSuite
                    </button>
                    
                    <div id="permissionsResults" style="display: none;">
                        <!-- Status banner -->
                        <div id="permissionsStatus" style="padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; font-size: 12px; font-weight: 600;">
                    </div>
                    
                        <!-- Features section -->
                        <div id="featuresSection" style="margin-bottom: 12px;">
                        </div>
                        
                        <!-- Subsidiaries list -->
                        <div id="subsidiariesSection" style="display: none; margin-bottom: 12px;">
                            <h4 style="font-size: 11px; font-weight: 600; color: #374151; margin-bottom: 8px;"> Subsidiaries</h4>
                            <div id="subsidiariesList" style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 11px;">
                            </div>
                    </div>
                    
                        <!-- Table Permissions list -->
                        <div id="tablePermissionsSection" style="display: none; margin-bottom: 12px;">
                            <h4 style="font-size: 11px; font-weight: 600; color: #374151; margin-bottom: 8px;"> Table Permissions</h4>
                            <div id="permissionsList">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Cache Info -->
                <div class="settings-section">
                    <h3> Cache Status</h3>
                    <div id="cacheInfo" style="font-size: 12px; color: #4b5563;">
                        <p>LocalStorage: <span id="localStorageStatus">Checking...</span></p>
                        <p style="margin-top: 4px;">Cached accounts: <span id="cachedAccountsCount">-</span></p>
                    </div>
                </div>

                <!-- Version Info -->
                <div class="settings-section">
                    <h3> Version Info</h3>
                    <div style="font-size: 12px; color: #4b5563;">
                        <p>Add-in Version: <strong id="settingsVersion">loading...</strong></p>
                        <p style="margin-top: 4px;">Manifest Version: <strong>3.0.5.237</strong></p>
                        <p style="margin-top: 4px;">Proxy: <code style="font-size: 10px; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">netsuite-proxy.chris-corcoran.workers.dev</code></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Green accent stripe -->
    <div class="accent-stripe"></div>
    
    <div class="container">
        <!-- Settings View (inline, replaces main content when active) -->
        <div class="settings-view" id="settingsViewInline"></div>
        
        <!-- Main View (hidden when settings is active) -->
        <div class="main-view" id="mainView">
        <div class="header">
            <div class="header-top">
                <svg class="header-menu" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" onclick="openSettings()">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
                <div class="header-logo">
                    <img src="Updated_CloudExtend-Logo-WhitewithTealDash.png" alt="CloudExtend by Celigo" style="height: 26px; width: auto;">
                </div>
            </div>
            <div class="tab-nav">
                <button id="tabDataMgmt">Data Management</button>
                <button id="tabAnalytics">Analytics</button>
                <button class="active" id="tabFinancial">Financial Reporting</button>
            </div>
        </div>

        <div class="content">
            <!-- TAB PANEL: Data Management (placeholder) -->
            <div class="tab-panel" id="panelDataMgmt" style="display: none;">
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="3" y1="9" x2="21" y2="9"></line>
                            <line x1="9" y1="21" x2="9" y2="9"></line>
                        </svg>
                    </div>
                    <h3>Data Management</h3>
                    <p>Download to modify and update back to NetSuite</p>
                    <p class="coming-soon">Coming Soon</p>
                </div>
            </div>

            <!-- TAB PANEL: Analytics (placeholder) -->
            <div class="tab-panel" id="panelAnalytics" style="display: none;">
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                    </div>
                    <h3>Analytics</h3>
                    <p>Build charts and dashboards from your data</p>
                    <p class="coming-soon">Coming Soon</p>
                </div>
            </div>

            <!-- TAB PANEL: Financial Reporting -->
            <div class="tab-panel" id="panelFinancial" style="display: block;">
                <!-- TOP NOTIFICATION BANNER - Shows warnings/errors prominently -->
                <div id="topNotificationBanner" style="display: none;"></div>
                
                <div class="status-badge connected" id="connectionStatus" onclick="checkConnectionStatus()" title="Click to check connection">
                    <span id="connectionText">Checking connection...</span>
                </div>

                <!-- VIEW MODE TOGGLE - Progressive Disclosure Control -->
                <div class="view-mode-toggle">
                    <span class="view-mode-label">View Mode</span>
                    <div class="view-mode-switch">
                        <label onclick="toggleViewMode()">Show All Sections</label>
                        <div class="toggle-switch" id="viewModeToggle" onclick="toggleViewMode()"></div>
                    </div>
                </div>

                <!-- QUICK START - Accordion Section -->
            <details class="collapsible-section help-section" id="quickStartSection" data-section-id="quickStart" open>
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'quickStartSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon" style="background: var(--anenome);">
                            <svg viewBox="0 0 24 24" style="stroke: white;"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                        </div>
                        <div class="header-text">
                            <span>Quick Start</span>
                            <span class="subtitle">Build reports in seconds</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content" style="background: linear-gradient(135deg, rgba(9, 35, 92, 0.05) 0%, rgba(0, 79, 182, 0.05) 100%);">
                    
                    <!-- Interactive Tutorial -->
                    <div class="guide-choice" onclick="startOnboarding()" style="margin-bottom: 12px; background: rgba(255,255,255,0.8); border: 2px solid var(--deep-dive);">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: var(--deep-dive);">Interactive Tutorial</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">Learn by building  60 seconds on an empty sheet</div>
                        </div>
                        <span style="background: var(--anenome); color: var(--deep-dive); font-size: 9px; font-weight: 700; padding: 3px 8px; border-radius: 10px; margin-left: auto;">NEW</span>
                    </div>
                    
                    <p style="font-size: 11px; line-height: 1.5; color: var(--bottlenose); margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.1);">
                        Or jump straight into a pre-built report:
                    </p>
                    
                    <!-- Option 1: Sample Report -->
                    <div class="guide-choice" onclick="runGuideMe()" style="margin-bottom: 12px; background: rgba(255,255,255,0.8); border: 2px solid var(--deep-dive);">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: var(--deep-dive);">Sample Report</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">35 accounts with formulas you can study</div>
                        </div>
            </div>
                    
                    <!-- Option 2: CFO Flash Report -->
                    <div class="guide-choice" onclick="generateSummaryIncomeStatement()" style="background: rgba(255,255,255,0.8); border: 2px solid #10B981;">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: #10B981;">CFO Flash Report</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">High-level P&L with KPI cards  uses TYPEBALANCE formulas</div>
                        </div>
                    </div>
                    
                    <!-- Option 3: Full Income Statement -->
                    <div class="guide-choice" onclick="generateFullIncomeStatement()" style="margin-top: 12px; background: rgba(255,255,255,0.8); border: 2px solid var(--deep-dive);">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: var(--deep-dive);">Full Income Statement</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">Complete P&L with all accounts, sections, and totals</div>
                        </div>
                    </div>
                    
                    <!-- Option 4: Budget Report -->
                    <div class="guide-choice" onclick="generateBudgetReport()" style="margin-top: 12px; background: rgba(255,255,255,0.8); border: 2px solid #8B5CF6;">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: #8B5CF6;">Budget Report</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">Load existing budget from NetSuite with all accounts</div>
                        </div>
                    </div>
                    
                    <!-- Performance Tools Divider -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px dashed rgba(0,0,0,0.1);">
                        <div style="font-size: 11px; color: var(--bottlenose); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;"> Performance Tools</div>
                    </div>
                    
                    <!-- Option 5: Preload Balance Sheet (expandable) -->
                    <div class="guide-choice bs-preload-section" style="margin-top: 8px; background: linear-gradient(135deg, rgba(59,130,246,0.05), rgba(59,130,246,0.1)); border: 2px solid #3B82F6; cursor: default; flex-wrap: wrap;">
                        <div class="guide-choice-icon" style="margin-right: 8px;"></div>
                        <div class="guide-choice-content" style="min-width: 0; overflow: hidden;">
                            <div class="guide-choice-title" style="color: #3B82F6;">Preload Balance Sheet</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose); font-size: 11px;">Speed up BS account lookups</div>
                            
                            <!-- Smart Preload - scan sheet -->
                            <div style="margin-top: 10px;">
                                <button onclick="smartPreloadFromSheet()" 
                                        style="width: 100%; padding: 8px 12px; background: linear-gradient(135deg, #10B981, #059669); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; font-weight: 500;">
                                    <span></span> <span>Smart Preload (Scan Sheet)</span>
                                </button>
                                <div style="font-size: 9px; color: #888; margin-top: 4px; text-align: center;">
                                    Finds & preloads only BS accounts used on this sheet
                                </div>
                            </div>
                            
                            <!-- Manual Preload - all accounts -->
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ddd;">
                                <div style="font-size: 10px; color: #666; margin-bottom: 6px;">Or preload ALL BS accounts:</div>
                                <div style="display: flex; gap: 6px; align-items: center;">
                                    <label style="font-size: 10px; min-width: 45px;">Period:</label>
                                    <input type="text" id="bsPreloadPeriod1" placeholder="Dec 2024" value="Dec 2024" 
                                           style="flex: 1; min-width: 0; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 10px;">
                                </div>
                                <div style="display: flex; gap: 6px; align-items: center; margin-top: 4px;">
                                    <label style="font-size: 10px; min-width: 45px;">Period 2:</label>
                                    <input type="text" id="bsPreloadPeriod2" placeholder="optional" 
                                           style="flex: 1; min-width: 0; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 10px;">
                                </div>
                                <button onclick="preloadBalanceSheet()" 
                                        style="width: 100%; margin-top: 6px; padding: 6px 12px; background: #3B82F6; color: white; border: none; border-radius: 6px; font-size: 11px; cursor: pointer;">
                                     Preload All (~70s/period)
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="guide-me-progress" id="guideMeProgress" style="display: none; margin-top: 12px;"></div>
                </div>
            </details>

            <!-- GETTING STARTED HELP SECTION (Secondary - hidden by default) -->
            <details class="collapsible-section help-section secondary-section" id="helpSection" data-section-id="help">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'helpSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </div>
                        <div class="header-text">
                            <span>Getting Started Guide</span>
                            <span class="subtitle">Learn formulas and best practices</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <div class="help-tip">
                        <h4> Quick Start</h4>
                        <p>Type formulas directly in any Excel cell. Start with <code>=XAVI.BALANCE("4220", "Jan 2025", "Jan 2025")</code> to get account 4220's January balance!</p>
                        <p style="margin-top: 8px;"><strong>New:</strong> Use wildcards like <code>"4*"</code> to sum all revenue accounts at once!</p>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 16px 0 10px; font-size: 14px;">Available Formulas</h4>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE(account, startPeriod, endPeriod, [subsidiary], [dept], [location], [class])</code>
                        <span class="result">Returns: Account balance for the period</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.NAME(account)</code>
                        <span class="result">Returns: Account name (e.g., "Revenue - Products")</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.TYPE(account)</code>
                        <span class="result">Returns: Account type (e.g., "Income", "Expense")</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.PARENT(account)</code>
                        <span class="result">Returns: Parent account number</span>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 20px 0 10px; font-size: 14px;"> Making Formulas Dynamic</h4>
                    <p style="color: var(--bottlenose); font-size: 12px; line-height: 1.5; margin-bottom: 12px;">
                        The real power comes from using <strong>cell references</strong> instead of hardcoded values. This lets you drag formulas and build dynamic reports!
                    </p>
                    
                    <div class="dynamic-demo">
                        <h5>Example: Dynamic Income Statement</h5>
                        <div class="excel-grid" style="grid-template-columns: 40px repeat(2, 1fr);">
                            <div class="excel-cell header"></div>
                            <div class="excel-cell header">A</div>
                            <div class="excel-cell header">B</div>
                            
                            <div class="excel-cell row-header">1</div>
                            <div class="excel-cell value">Account</div>
                            <div class="excel-cell value">Jan 2025</div>
                            
                            <div class="excel-cell row-header">2</div>
                            <div class="excel-cell">4220</div>
                            <div class="excel-cell formula">=XAVI.BALANCE($A2, B$1, B$1)</div>
                            
                            <div class="excel-cell row-header">3</div>
                            <div class="excel-cell">5000</div>
                            <div class="excel-cell formula drag-indicator">=XAVI.BALANCE($A3, B$1, B$1)</div>
                            
                            <div class="excel-cell row-header">4</div>
                            <div class="excel-cell">6100</div>
                            <div class="excel-cell formula drag-indicator">=XAVI.BALANCE($A4, B$1, B$1)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px; margin-top: 10px; padding: 8px 10px; background: rgba(26, 90, 62, 0.1); border-radius: 6px;">
                            <span style="font-size: 16px;"></span>
                            <span style="font-size: 11px; color: var(--deep-dive);"><strong>Drag down</strong> to copy formula for all accounts</span>
                        </div>
                        <p style="font-size: 11px; color: var(--bottlenose); margin-top: 10px;">
                            <strong>The secret:</strong> <code>$A2</code> locks the column (A stays fixed), <code>B$1</code> locks the row (1 stays fixed). This lets you drag <strong>both directions</strong>  down for accounts, right for months!
                        </p>
                    </div>
                    
                    <div class="help-tip" style="margin-top: 16px;">
                        <h4> Pro Tip: Fast Data Entry</h4>
                        <p>1. Enter one formula in cell B2<br>
                        2. Drag <strong>down</strong> for all accounts (B2:B50)<br>
                        3. Then drag <strong>right</strong> for all months<br>
                        <strong>The add-in automatically batches requests!</strong></p>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 20px 0 10px; font-size: 14px;"> Wildcards: High-Level Summaries</h4>
                    <p style="color: var(--bottlenose); font-size: 12px; line-height: 1.5; margin-bottom: 12px;">
                        Use <code>*</code> to sum multiple accounts at once  perfect for executive summaries without listing every account!
                    </p>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("4*", "Jan 2025", "Dec 2025")</code>
                        <span class="result">Total Revenue (all 4xxx accounts)</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("5*", "2025", "2025")</code>
                        <span class="result">Total COGS (all 5xxx accounts)</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("6*", "Q1 2025", "Q1 2025")</code>
                        <span class="result">Total Operating Expenses (all 6xxx)</span>
                    </div>
                    
                    <div style="padding: 10px 12px; background: rgba(26, 90, 62, 0.08); border-radius: 6px; margin-top: 12px;">
                        <p style="font-size: 11px; color: var(--deep-dive); margin: 0; line-height: 1.5;">
                            <strong> CFO Dashboard Example:</strong><br>
                             Row 1: <code>=XAVI.BALANCE("4*",...)</code>  Total Revenue<br>
                             Row 2: <code>=XAVI.BALANCE("5*",...)</code>  Total COGS<br>
                             Row 3: <code>=Row1-Row2</code>  Gross Profit<br>
                             Row 4: <code>=XAVI.BALANCE("6*",...)</code>  OpEx<br>
                            <em>Build a full P&L summary in 4 formulas!</em>
                        </p>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 20px 0 10px; font-size: 14px;"> Using Filters (Optional)</h4>
                    <p style="color: var(--bottlenose); font-size: 12px; line-height: 1.5; margin-bottom: 12px;">
                        Filter by subsidiary, department, location, or class. You can use names OR IDs:
                    </p>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("4220", "Jan 2024", "Jan 2024", "Celigo Inc.")</code>
                        <span class="result">Filter by subsidiary name</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("4220", "Jan 2024", "Jan 2024", "", "Sales")</code>
                        <span class="result">Filter by department (leave subsidiary blank with "")</span>
                    </div>
                    
                    <div class="dynamic-demo" style="border-color: var(--anenome);">
                        <h5 style="color: var(--anenome);">Dynamic Filters with Cell References</h5>
                        <div class="excel-grid" style="grid-template-columns: 40px repeat(2, 1fr);">
                            <div class="excel-cell header"></div>
                            <div class="excel-cell header">A</div>
                            <div class="excel-cell header">B</div>
                            
                            <div class="excel-cell row-header">1</div>
                            <div class="excel-cell value">Subsidiary Context:</div>
                            <div class="excel-cell">Celigo Inc.</div>
                            
                            <div class="excel-cell row-header">2</div>
                            <div class="excel-cell value">Department:</div>
                            <div class="excel-cell">Sales</div>
                            
                            <div class="excel-cell row-header">4</div>
                            <div class="excel-cell">4220</div>
                            <div class="excel-cell formula" style="font-size: 8px;">=XAVI.BALANCE(A4, "Jan 2024", "Jan 2024", $B$1, $B$2)</div>
                        </div>
                        <p style="font-size: 11px; color: var(--bottlenose); margin-top: 8px;">
                            Reference filter values from cells using <code>$B$1</code> (fully locked) to change all formulas at once!
                        </p>
                    </div>
                </div>
            </details>

            <!-- DATA MANAGEMENT SECTION - Redesigned with integrated preload -->
            <details class="collapsible-section data-mgmt-section" id="dataMgmtSection" data-section-id="dataMgmt">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'dataMgmtSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon" style="background: #dbeafe;">
                            <svg viewBox="0 0 24 24" style="stroke: var(--blue-light);"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                        </div>
                        <div class="header-text">
                            <span>Refresh & Caching</span>
                            <span class="subtitle">Update formulas with fresh data</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content data-mgmt-content">
                    
                    <!-- REFRESH ACTIONS -->
                    <div class="data-section refresh-section">
                        <div class="section-header">
                            <h4> Refresh Options</h4>
                        </div>
                        
                        <div class="action-grid">
                            <button class="action-btn primary" onclick="refreshCurrentSheet()">
                                <span class="action-icon"></span>
                                <span class="action-text">Refresh All</span>
                                <span class="help-icon small" data-tip="Clears cache and refreshes ALL XAVI formulas on this sheet. Auto-detects P&L (fast ~30s/year) and Balance Sheet accounts (2-3 min). Use after posting transactions or to get fresh data.">?</span>
                            </button>
                            
                            <button class="action-btn secondary" onclick="refreshSelected()">
                                <span class="action-icon"></span>
                                <span class="action-text">Refresh Selected</span>
                                <span class="help-icon small" data-tip="Clears cache and refreshes ONLY the cells you've selected. Much faster than Refresh All for quick spot-checks.">?</span>
                            </button>
                            
                            <button class="action-btn warning" onclick="recalculateSpecialFormulas()">
                                <span class="action-icon"></span>
                                <span class="action-text">Recalculate Retained Earnings</span>
                                <span class="help-icon small" data-tip="Retained Earnings, Net Income, and CTA require full transaction history scan with currency consolidation (up to 5 min). Use after: journal entries, period close, or when values seem stale.">?</span>
                            </button>
                            
                            <button class="action-btn" onclick="formatCurrencies()" style="background: linear-gradient(135deg, #059669 0%, #10b981 100%);">
                                <span class="action-icon"></span>
                                <span class="action-text">Format Currencies</span>
                                <span class="help-icon small" data-tip="Applies currency formatting to XAVI.BALANCE cells based on each formula's subsidiary. Automatically detects USD, EUR, GBP, AUD, INR, etc.">?</span>
                            </button>
                        </div>
                    
                    <div class="refresh-status" id="refreshStatus"></div>
                    </div>
                    
                </div>
            </details>

            <!-- NETSUITE FILTERS SECTION (Secondary - hidden by default) -->
            <details class="collapsible-section secondary-section" id="filtersSection" data-section-id="filters">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'filtersSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
                        </div>
                        <div class="header-text">
                            <span>Filters</span>
                            <span class="subtitle">Class, Department, Location</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 14px; line-height: 1.5;">
                        <strong>Pro Tip:</strong> Make your worksheet dynamic by inserting filter fields in your worksheet and referencing the appropriate cells with your Excel formulas.
                    </p>
                    
                    <div class="filter-group">
                        <label class="filter-label">Subsidiary Context</label>
                        <select id="subsidiarySelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('subsidiary')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Department</label>
                        <select id="departmentSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('department')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Class</label>
                        <select id="classSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('class')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Location</label>
                        <select id="locationSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('location')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Accounting Book <span style="font-size:10px;color:#888;">(Multi-Book)</span></label>
                        <select id="accountingBookSelect" class="filter-select">
                            <option value="1">Primary Book (Default)</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('accountingBook')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Budget Category <span style="font-size:10px;color:#888;">(for XAVI.BUDGET)</span></label>
                        <select id="budgetCategorySelect" class="filter-select">
                            <option value="">All Categories</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('budgetCategory')">Insert</button>
                    </div>
                    
                    <div class="refresh-status" id="lookupStatus"></div>
                </div>
            </details>

            <!-- ACCOUNT SEARCH SECTION (Secondary - hidden by default) -->
            <details class="collapsible-section secondary-section" id="bulkAddSection" data-section-id="bulkAdd">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'bulkAddSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                        </div>
                        <div class="header-text">
                            <span>Bulk Add GL Accounts</span>
                            <span class="subtitle">Add multiple accounts at once</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                        Search by account number or type. Results insert at your cursor position.
                    </p>
                    
                    <input 
                        type="text" 
                        id="accountSearchInput" 
                        class="search-input"
                        placeholder="e.g., 4*, *income, expense"
                        onkeypress="if(event.key === 'Enter') searchAccounts()"
                    />
                    
                    <div class="search-hints">
                        <p style="color: var(--bottlenose); font-size: 11px; margin: 0; line-height: 1.6;">
                            <strong>By Number:</strong> <code>4*</code> <code>42*</code> <code>*</code><br>
                            <strong>By Type:</strong> <code>income</code> <code>expense</code> <code>bank</code> <code>asset</code>
                        </p>
                    </div>
                    
                    <button class="btn-primary" style="margin-top: 12px; background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%); color: var(--deep-dive);" onclick="searchAccounts()">
                        <span></span> Bulk Add GL Accounts
                    </button>
                    
                    <div class="refresh-status" id="searchStatus"></div>
                </div>
            </details>

            <!-- DRILL-DOWN SECTION (Secondary - hidden by default, available in Quick Actions) -->
            <details class="collapsible-section secondary-section" id="drillDownSection" data-section-id="drillDown">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'drillDownSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                        </div>
                        <div class="header-text">
                            <span>Transaction Drill-Down</span>
                            <span class="subtitle">View underlying transactions</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                        Select any cell with an XAVI.BALANCE formula to see the underlying NetSuite transactions with links to original records.
                    </p>
                    <button class="btn-secondary" style="background: var(--tidal-wave);" onclick="drillDownTransactions()">
                        View Transactions
                    </button>
                    <div class="refresh-status" id="drillStatus"></div>
                </div>
            </details>

            <!-- SHARE & EXPORT SECTION (Secondary - hidden by default) -->
            <details class="collapsible-section secondary-section" id="shareSection" data-section-id="share">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'shareSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>
                        </div>
                        <div class="header-text">
                            <span>Share & Export</span>
                            <span class="subtitle">PDF or Excel</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                        Export your report as PDF or Excel (with formulas converted to values for sharing).
                    </p>
                    
                    <!-- Scope Selection -->
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 11px; font-weight: 600; color: var(--deep-sea); display: block; margin-bottom: 6px;">SCOPE</label>
                        <div style="display: flex; gap: 8px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="radio" name="exportScope" value="worksheet" checked style="margin: 0;">
                                Current Sheet
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="radio" name="exportScope" value="workbook" style="margin: 0;">
                                Entire Workbook
                            </label>
                        </div>
                    </div>
                    
                    <!-- Format Selection -->
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 11px; font-weight: 600; color: var(--deep-sea); display: block; margin-bottom: 6px;">FORMAT</label>
                        <div style="display: flex; gap: 8px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="radio" name="exportFormat" value="pdf" checked style="margin: 0;">
                                PDF
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="radio" name="exportFormat" value="excel" style="margin: 0;">
                                Excel (values only)
                            </label>
                        </div>
                    </div>
                    
                    <!-- Action Buttons - Side by side -->
                    <div style="display: flex; gap: 8px; margin-top: 12px;">
                        <button class="btn-secondary" style="flex: 1; background: var(--tidal-wave);" onclick="prepareForDistribution()">
                            <span style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                Save for Distribution
                            </span>
                        </button>
                        <button class="btn-secondary" style="flex: 1; background: #9ca3af;" onclick="showEmailComingSoon()">
                            <span style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                                Email
                            </span>
                        </button>
                    </div>
                    
                    <div class="refresh-status" id="shareStatus"></div>
                </div>
            </details>

            <!-- FORMULA REFERENCE SECTION (Secondary - hidden by default) -->
            <details class="collapsible-section secondary-section" id="formulaRefSection" data-section-id="formulaRef">
                <summary class="collapsible-header" onclick="handleAccordionClick(event, 'formulaRefSection')">
                    <div class="drag-handle" draggable="true" title="Drag to reorder"><span></span><span></span><span></span></div>
                    <h3>
                        <div class="section-icon">
                            <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                        </div>
                        <div class="header-text">
                            <span>Formula Reference</span>
                            <span class="subtitle">All available formulas</span>
                        </div>
                    </h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
    
            <!-- XAVI.NAME -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">NAME</span>
                        <span class="formula-brief">Get account name</span>
                </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.NAME(accountNumber)</div>
                    <div class="param-item"><span class="param-name">accountNumber</span> - Account # or ID</div>
                <div class="example">
                    <div class="example-code">=XAVI.NAME(A4)</div>
                    <div class="example-code">=XAVI.NAME("4220")</div>
                    </div>
                </div>
            </div>

            <!-- XAVI.TYPE -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">TYPE</span>
                        <span class="formula-brief">Get account type</span>
                </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.TYPE(accountNumber)</div>
                    <div class="param-item"><span class="param-name">accountNumber</span> - Account # or ID</div>
                    <div class="example">
                        <div class="example-code">=XAVI.TYPE("4220")</div> <span class="example-result"> "Income"</span>
                    </div>
                </div>
            </div>

            <!-- XAVI.PARENT -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">PARENT</span>
                        <span class="formula-brief">Get parent account</span>
                    </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.PARENT(accountNumber)</div>
                    <div class="param-item"><span class="param-name">accountNumber</span> - Account # or ID</div>
                <div class="example">
                        <div class="example-code">=XAVI.PARENT("4220")</div> <span class="example-result"> "4210"</span>
                    </div>
                </div>
            </div>

            <!-- XAVI.BALANCE -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">BALANCE</span>
                        <span class="formula-brief">Account balance  Wildcards </span>
                </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.BALANCE(acct, from, to, [sub], [dept], [loc], [class])</div>
                    <div class="param-item"><span class="param-name">acct</span> - Account # or wildcard ("4*")</div>
                    <div class="param-item"><span class="param-name">from/to</span> - Period ("Jan 2025" or "2025")</div>
                    <div class="param-item"><span class="param-name">sub/dept/loc/class</span> - Optional filters</div>
                    <div class="example">
                        <div class="example-code">=XAVI.BALANCE("4010", "Jan 2025", "Dec 2025")</div>
                        <div class="example-code">=XAVI.BALANCE("4*", "2025", "2025")</div> <span class="example-result"> All 4xxx accounts</span>
                    </div>
                </div>
            </div>
    
            <!-- XAVI.BUDGET -->
            <!-- XAVI.BUDGET -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">BUDGET</span>
                        <span class="formula-brief">Budget amounts  Wildcards </span>
                    </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.BUDGET(acct, from, to, [sub], [dept], [loc], [class])</div>
                    <div class="param-item"><span class="param-name">acct</span> - Account # or wildcard ("6*")</div>
                    <div class="param-item"><span class="param-name">from/to</span> - Period range</div>
                <div class="example">
                        <div class="example-code">=XAVI.BUDGET("5000", "2025", "2025")</div>
                        <div class="example-code">=XAVI.BUDGET("6*", "Jan 2025", "Dec 2025")</div>
                    </div>
                </div>
            </div>

            <!-- XAVI.TYPEBALANCE -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">TYPEBALANCE</span>
                        <span class="formula-brief">Sum by account type</span>
                </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.TYPEBALANCE(type, from, to, [sub], ...)</div>
                    <div class="param-item"><span class="param-name">type</span> - "Income", "Expense", "COGS", etc.</div>
                    <div class="example">
                        <div class="example-code">=XAVI.TYPEBALANCE("Income", "Jan 2025", "Dec 2025")</div>
                        <div class="example-code">=XAVI.TYPEBALANCE("COGS", "2025", "2025")</div>
                    </div>
                    </div>
                    </div>

            <!-- XAVI.NETINCOME -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">NETINCOME</span>
                        <span class="formula-brief">Calculate net income</span>
                    </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                    </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.NETINCOME(from, [to], [sub], [book], ...)</div>
                    <div class="param-item"><span class="param-name">from/to</span> - Period range (to defaults to from)</div>
                    <div class="example">
                        <div class="example-code">=XAVI.NETINCOME("Jan 2025", "Dec 2025")</div>
                        <div class="example-code">=XAVI.NETINCOME("2025",, "Celigo Inc.")</div>
                    </div>
                    <div style="font-size: 10px; color: var(--bottlenose); margin-top: 6px;"> 1020 sec</div>
                    </div>
                </div>

            <!-- XAVI.RETAINEDEARNINGS -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">RETAINEDEARNINGS</span>
                        <span class="formula-brief">Cumulative P&L</span>
                    </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.RETAINEDEARNINGS(period, [sub], [book], ...)</div>
                    <div class="param-item">Cumulative P&L from inception through prior FY end</div>
                <div class="example">
                        <div class="example-code">=XAVI.RETAINEDEARNINGS("Dec 2024")</div>
                </div>
                    <div style="font-size: 10px; color: var(--bottlenose); margin-top: 6px;"> Up to 2 min</div>
                </div>
            </div>

            <!-- XAVI.CTA -->
            <div class="formula-card" onclick="this.classList.toggle('expanded')">
                <div class="formula-header">
                    <div class="formula-header-left">
                        <span class="formula-name">CTA</span>
                        <span class="formula-brief">FX translation adjustment</span>
                    </div>
                    <svg class="formula-expand-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </div>
                <div class="formula-details">
                    <div class="formula-syntax">=XAVI.CTA(period, [sub], [book])</div>
                    <div class="param-item">Cumulative Translation Adjustment for multi-currency</div>
                    <div class="example">
                        <div class="example-code">=XAVI.CTA("Dec 2024")</div>
                    </div>
                    <div style="font-size: 10px; color: var(--bottlenose); margin-top: 6px;"> Up to 2 min</div>
                </div>
    </div>
    
                    <div class="help-tip" style="margin-top: 16px;">
                        <h4> Pro Tip: Date Formatting</h4>
                        <p>Use TEXT() to format date cells:<br>
                        <code style="background: var(--deep-dive); color: var(--anenome); padding: 2px 6px; border-radius: 4px; font-size: 11px;">=XAVI.BALANCE("4010", TEXT(C3,"mmm yyyy"), TEXT(D3,"mmm yyyy"))</code></p>
                </div>
                </div>
            </details>
            </div><!-- end panelFinancial -->
                    </div>

        <!-- Quick Actions Bar - Always visible at bottom -->
        <div class="quick-actions-bar" id="quickActionsBar">
            <!-- Contextual Status Badge (top) -->
            <div class="quick-actions-status" id="quickActionsStatus">
                <span class="status-badge-icon" id="statusBadgeIcon"></span>
                <span class="status-badge-text" id="statusBadgeText">Checking sheet...</span>
                    </div>
            <div class="quick-actions-buttons">
                <button class="quick-action-btn primary" onclick="refreshCurrentSheet()" id="quickRefreshBtn" disabled>
                    <span></span> Refresh All
                </button>
                <button class="quick-action-btn secondary" onclick="refreshSelected()" id="quickRefreshSelectedBtn" disabled>
                    <span></span> Refresh Selected
                </button>
                <button class="quick-action-btn secondary" onclick="drillDownTransactions()" id="quickDrillBtn" disabled>
                    <span></span> Drill Down
                </button>
                <button class="quick-action-help" onclick="showQuickActionsHelp()" title="Quick Actions Help">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
            </button>
                    </div>
            <!-- Formula Count (persistent at bottom) -->
            <div class="quick-actions-footer" id="quickActionsFooter">
                <span id="formulaCountText"></span>
                    </div>
                    </div>
        
        <!-- Quick Actions Help Modal -->
        <div class="quick-help-modal" id="quickHelpModal" onclick="hideQuickActionsHelp(event)">
            <div class="quick-help-content" onclick="event.stopPropagation()">
                <button class="quick-help-close" onclick="hideQuickActionsHelp()"></button>
                <h3> Quick Actions Guide</h3>
                <div class="quick-help-items">
                    <div class="quick-help-item">
                        <span class="quick-help-icon"></span>
                        <div>
                            <strong>Refresh All</strong>
                            <p>Clears cache and recalculates ALL XAVI formulas on the current sheet. Use after posting new transactions.</p>
                    </div>
                    </div>
                    <div class="quick-help-item">
                        <span class="quick-help-icon"></span>
                        <div>
                            <strong>Refresh Selected</strong>
                            <p>Recalculates only the cells you've highlighted. Much faster for spot-checking individual accounts.</p>
                </div>
                    </div>
                    <div class="quick-help-item">
                        <span class="quick-help-icon"></span>
                        <div>
                            <strong>Drill Down</strong>
                            <p>Select a cell with XAVI.BALANCE or XAVI.TYPEBALANCE and click to see all underlying transactions.</p>
                        </div>
                    </div>
                </div>
                <div class="quick-help-tip">
                     <strong>Pro Tip:</strong> Toggle "Show All Sections" above to access Filters, Bulk Add, and Formula Reference.
                </div>
                </div>
            </div>

        <!-- Interactive Onboarding Wizard -->
        <div class="onboarding-overlay" id="onboardingOverlay">
            <div class="onboarding-wizard">
                <!-- Exit Button - Always visible at top right -->
                <button class="onboarding-exit-btn" onclick="skipOnboarding()" title="Exit Tutorial">
                    
                </button>
                <!-- Restart Action -->
                <div class="onboarding-actions">
                    <button class="onboarding-restart" onclick="restartOnboarding()"> Start Over</button>
                </div>
                
                <!-- Step 2: Enter Account Number (now first step) -->
                <div class="onboarding-step active" id="onboardingStep2">
                    <div class="step-type-badge action"> Let's Build Your First Formula</div>
                    <div class="onboarding-icon"></div>
                    <h2>Pick an Account</h2>
                    <p class="onboarding-desc">
                        Enter a G/L account number, or we'll show you accounts with Jan 2025 activity.
                    </p>
                    <div class="overwrite-warning">
                        <span></span>
                        <span><strong>Heads up:</strong> This tutorial may write to your active sheet. Use a blank sheet if you want to preserve existing data.</span>
                    </div>
                    <div class="onboarding-input-group">
                        <input type="text" id="onboardingAccountInput" placeholder="e.g., 40110, 51000, 62100" class="onboarding-input" />
                        <button class="onboarding-btn secondary" onclick="showSampleAccounts()" id="showAccountsBtn">
                             Find Accounts With Activity
                        </button>
                    </div>
                    <div id="sampleAccountsList" class="sample-accounts-list" style="display: none;"></div>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn primary" onclick="insertFirstFormula()" id="insertFormulaBtn" style="font-size: 13px; padding: 10px 16px;">
                            Build My Formula & Continue 
                        </button>
                    </div>
                </div>
                
                <!-- Step 3: See the Magic -->
                <div class="onboarding-step" id="onboardingStep3">
                    <div class="step-type-badge tip"> SEE THE RESULT</div>
                    <div class="onboarding-icon"></div>
                    <h2>Look at That!</h2>
                    <p class="onboarding-desc">
                        Your formula pulled real data! We also added <strong>XAVI.NAME</strong> to show the account name automatically.
                    </p>
                    <div class="onboarding-highlight-box">
                        <div class="formula-display" id="insertedFormulaDisplay">=XAVI.BALANCE("40110", "Jan 2025", "Jan 2025")</div>
                        <div class="result-display"> <span id="insertedResultDisplay">$12,500.00</span></div>
                </div>
                    <div class="busy-notice">
                        <span class="busy-icon"></span>
                        <span>You may see <strong>#BUSY</strong> briefly  that's us doing the heavy lifting with NetSuite!</span>
                    </div>
                    <p class="onboarding-tip"> <strong>XAVI.NAME(account)</strong> returns the account name  great for labels!</p>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(2)"> Back</button>
                        <button class="onboarding-btn primary" onclick="teachDragFill()">
                            Add More Accounts 
                        </button>
                </div>
            </div>

                <!-- Step 4: Drag & Fill Rows -->
                <div class="onboarding-step" id="onboardingStep4">
                    <div class="step-type-badge action"> YOUR TURN (or skip)</div>
                    <div class="onboarding-icon"></div>
                    <h2>Fill Down for Accounts</h2>
                    <p class="onboarding-desc">
                        We added 3 more accounts. <strong>Drag the formula corner down</strong> to fill them  or we'll do it for you!
                    </p>
                    <div class="drag-demo-container">
                        <div class="drag-demo-visual">
                            <div class="demo-cell filled">$12,500</div>
                            <div class="demo-cell empty">?</div>
                            <div class="demo-cell empty">?</div>
                            <div class="demo-cell empty">?</div>
                            <div class="demo-arrow"> Drag</div>
                </div>
                </div>
                    <div class="busy-notice small">
                        <span class="busy-icon"></span>
                        <span><strong>#BUSY</strong> = we're fetching from NetSuite. It'll resolve in moments!</span>
                    </div>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(3)"> Back</button>
                        <button class="onboarding-btn secondary" onclick="autoFillFormulas()">Auto-Fill Rows</button>
                        <button class="onboarding-btn primary" onclick="validateStep4AndContinue()">Next: Months </button>
                    </div>
                    </div>
                
                <!-- Step 4b: Drag & Fill Months -->
                <div class="onboarding-step" id="onboardingStep4b">
                    <div class="step-type-badge action"> YOUR TURN (or skip)</div>
                    <div class="onboarding-icon"></div>
                    <h2>Fill Right for Months</h2>
                    <p class="onboarding-desc">
                        Now <strong>drag right</strong> across the columns to fill all 12 months! This is the power of Excel + XAVI.
                    </p>
                    <div class="drag-demo-container">
                        <div class="drag-demo-visual horizontal">
                            <div class="demo-cell filled">Jan</div>
                            <div class="demo-cell empty">Feb</div>
                            <div class="demo-cell empty">...</div>
                            <div class="demo-cell empty">Dec</div>
                            <div class="demo-arrow-right"> Drag</div>
                    </div>
                </div>
                    <div class="busy-notice">
                        <span class="busy-icon"></span>
                        <span>You'll see <strong>#BUSY</strong> while we fetch data from NetSuite  that's us doing all the heavy lifting! Each cell will resolve in moments.</span>
                </div>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(4)"> Back</button>
                        <button class="onboarding-btn secondary" onclick="autoFillMonths()">Auto-Fill Months</button>
                        <button class="onboarding-btn primary" onclick="validateStep4bAndContinue()">Wildcards </button>
                </div>
            </div>

                <!-- Step 5: Wildcards -->
                <div class="onboarding-step" id="onboardingStep5">
                    <div class="step-type-badge tip"> FORMULA TIP</div>
                    <div class="onboarding-icon"></div>
                    <h2>Level Up: Wildcards</h2>
                    <p class="onboarding-desc">
                        Use <strong>wildcards (*)</strong> to sum multiple accounts at once!
                    </p>
                    <div class="onboarding-highlight-box">
                        <div class="formula-display">=XAVI.BALANCE("40*", "Jan 2025", "Jan 2025")</div>
                        <div class="result-display"> Sum of ALL accounts starting with 40</div>
                </div>
                    <p class="onboarding-tip"> Great for totaling revenue (4*), expenses (6*), or any account group!</p>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep('4b')"> Back</button>
                        <button class="onboarding-btn primary" onclick="goToOnboardingStep(6)">More Power </button>
                </div>
                    </div>
                
                <!-- Step 6: TYPEBALANCE -->
                <div class="onboarding-step" id="onboardingStep6">
                    <div class="step-type-badge tip"> FORMULA TIP</div>
                    <div class="onboarding-icon"></div>
                    <h2>Level Up: Account Types</h2>
                    <p class="onboarding-desc">
                        Use <strong>TYPEBALANCE</strong> to sum all accounts of a type!
                    </p>
                    <div class="onboarding-highlight-box">
                        <div class="formula-display">=XAVI.TYPEBALANCE("Income", "Jan 2025", "Jan 2025")</div>
                        <div class="result-display"> Total of ALL Income accounts</div>
                    </div>
                    <div class="onboarding-examples">
                        <div class="example-item"><code>"Income"</code> All revenue</div>
                        <div class="example-item"><code>"COGS"</code> Cost of goods</div>
                        <div class="example-item"><code>"Expense"</code> Operating expenses</div>
                    </div>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(5)"> Back</button>
                        <button class="onboarding-btn primary" onclick="goToOnboardingStep(7)">Bulk Add </button>
                </div>
                </div>
                
                <!-- Step 7: Bulk Add -->
                <div class="onboarding-step" id="onboardingStep7">
                    <div class="step-type-badge action"> TRY IT (optional)</div>
                    <div class="onboarding-icon"></div>
                    <h2>Pro Tip: Bulk Add</h2>
                    <p class="onboarding-desc">
                        Need a list of your accounts? Use <strong>Bulk Add</strong>!
                    </p>
                    <div class="onboarding-steps-list">
                        <div class="step-item">1 Enter <code>*</code> for ALL accounts</div>
                        <div class="step-item">2 Or <code>4*</code> for just revenue</div>
                        <div class="step-item">3 Loads Account #, Name, Type & more!</div>
                    </div>
                    <div class="bulk-add-demo">
                        <input type="text" id="onboardingBulkAddInput" class="onboarding-input" placeholder="Enter * or 4* or 5*" value="*" style="text-align: center; margin-bottom: 10px;" />
                        <button class="onboarding-btn secondary" onclick="doBulkAddFromOnboarding()" style="width: 100%;">
                             Bulk Add Accounts Now
                        </button>
                    </div>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(6)"> Back</button>
                        <button class="onboarding-btn primary" onclick="goToOnboardingStep(8)">Go Dynamic </button>
                </div>
            </div>
    
                <!-- Step 8: Dynamic Parameters -->
                <div class="onboarding-step" id="onboardingStep8">
                    <div class="step-type-badge tip"> POWER TIP</div>
                    <div class="onboarding-icon"></div>
                    <h2>Go Dynamic!</h2>
                    <p class="onboarding-desc">
                        Use <strong>cell references</strong> for dynamic reports!
                    </p>
                    <div class="onboarding-highlight-box compact">
                        <div class="formula-display small">=XAVI.BALANCE($A2, $B$1, $B$1, $E$1)</div>
                    </div>
                    <div class="dynamic-params-list">
                        <div class="param-item"><span class="param-label">$E$1</span> Subsidiary</div>
                        <div class="param-item"><span class="param-label">$F$1</span> Department</div>
                        <div class="param-item"><span class="param-label">$G$1</span> Class/Location</div>
                </div>
                    <p class="onboarding-tip"> Change one cell  entire report updates!</p>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(7)"> Back</button>
                        <button class="onboarding-btn primary" onclick="goToOnboardingStep(9)">Drill Down </button>
                    </div>
        </div>

                <!-- Step 9: Drill Down -->
                <div class="onboarding-step" id="onboardingStep9">
                    <div class="step-type-badge action"> TRY IT (optional)</div>
                    <div class="onboarding-icon"></div>
                    <h2>Drill Into the Data</h2>
                    <p class="onboarding-desc">
                        Want to see the transactions behind any number? Use <strong>View Transactions</strong>!
                    </p>
                    <div class="onboarding-steps-list">
                        <div class="step-item">1 Click any cell with a BALANCE formula</div>
                        <div class="step-item">2 <strong>Right-click</strong>  Select <strong>"CloudExtend"</strong></div>
                        <div class="step-item">3 Choose <strong>"View Transactions"</strong></div>
            </div>
                    <div class="drill-demo-box">
                        <button class="drill-demo-btn" onclick="demoSelectForDrill()">
                             Select a BALANCE Cell
            </button>
                        <button class="onboarding-btn secondary" onclick="doDrillDownFromOnboarding()" style="width: 100%; margin-top: 8px;">
                             Drill Down Now
                        </button>
                        <p class="drill-demo-hint" id="drillDemoHint">Select a cell, then click "Drill Down Now" above  or use right-click  CloudExtend  View Transactions</p>
        </div>
                    <p class="onboarding-tip"> You can also use the <strong>Drill Down</strong> button in the Quick Actions bar at the bottom!</p>
                    <div class="onboarding-nav">
                        <button class="onboarding-btn text" onclick="goToOnboardingStep(8)"> Back</button>
                        <button class="onboarding-btn primary" onclick="goToOnboardingStep(10)">Finish </button>
                    </div>
                </div>
                
                <!-- Step 10: Complete -->
                <div class="onboarding-step" id="onboardingStep10">
                    <div class="step-type-badge celebrate"> COMPLETE!</div>
                    <div class="onboarding-celebration">
                        <div class="spreadsheet-party">
                            <div class="cell-char cell-a1"></div>
                            <div class="cell-char cell-b1"></div>
                            <div class="cell-char cell-c1"></div>
                            <div class="cell-char cell-a2"></div>
                            <div class="cell-char cell-b2"></div>
                            <div class="cell-char cell-c2"></div>
                        </div>
                        <div class="confetti-container">
                            <span class="confetti"></span>
                            <span class="confetti"></span>
                            <span class="confetti">=</span>
                            <span class="confetti">#</span>
                            <span class="confetti">$</span>
                            <span class="confetti">%</span>
                        </div>
                    </div>
                    <h2>You're an Excel Wizard! </h2>
                    <p class="onboarding-desc geeky">
                        =IF(you_completed_tutorial, "AMAZING!", "impossible")
                    </p>
                    <div class="cheat-sheet compact">
                        <div class="cheat-item"><code>BALANCE(acct, from, to)</code> <span>Balance</span></div>
                        <div class="cheat-item"><code>BUDGET(acct, from, to)</code> <span>Budget</span></div>
                        <div class="cheat-item"><code>TYPEBALANCE(type, ...)</code> <span>By type</span></div>
                        <div class="cheat-item"><code>NAME(acct)</code> <span>Account name</span></div>
                    </div>
                    <p class="more-formulas-hint"> Many more formulas available! Check the <strong>Formula Reference</strong> on the main menu.</p>
                    <button class="onboarding-btn primary celebration-btn" onclick="finishOnboarding()">
                        Finish 
                    </button>
                    <p class="final-tip"> <strong>Pro tip:</strong> Parametrize your queries! Put your year in a cell (e.g., P3=2025), then use <code>=DATE($P$3,1,1)</code> for dates. Drag right to fill all months, then just change the year cell and all XAVI values recalculate!</p>
                </div>
                
                <!-- Progress Indicator (bottom) -->
                <div class="onboarding-progress" id="onboardingProgress">
                    <div class="progress-bar-container" id="progressBar">
                        <div class="segment active" data-step="2"></div>
                        <div class="segment" data-step="3"></div>
                        <div class="segment" data-step="4"></div>
                        <div class="segment" data-step="4b"></div>
                        <div class="segment" data-step="5"></div>
                        <div class="segment" data-step="6"></div>
                        <div class="segment" data-step="7"></div>
                        <div class="segment" data-step="8"></div>
                        <div class="segment" data-step="9"></div>
                        <div class="segment" data-step="10"></div>
                    </div>
                    <span class="progress-text" id="progressText">1 of 10</span>
                </div>
            </div>
        </div>

        <!-- Footer removed - version info now in Settings panel only -->
        </div><!-- end main-view -->
    </div>
    
    <!-- Centered Status Overlay -->
    <div id="statusBar" class="status-overlay" style="display: none;">
        <div class="status-card">
            <div class="status-content">
                <span class="status-icon" id="statusIcon"></span>
                <span class="status-text" id="statusText">Processing...</span>
            </div>
            <div class="status-progress-bar">
                <div class="status-progress" id="statusProgress" style="width: 0%;"></div>
            </div>
        </div>
    </div>
    
    <style>
        .status-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .status-card {
            background: linear-gradient(135deg, #1a365d 0%, #0f2744 100%);
            color: white;
            padding: 20px 28px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 2px solid var(--anenome, #0AE2C1);
            min-width: 280px;
            max-width: 90%;
        }
        .status-content {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        .status-icon {
            font-size: 24px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-text {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }
        .status-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        .status-progress {
            height: 100%;
            background: var(--anenome, #0AE2C1);
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        .status-overlay.success .status-card {
            border-color: #10b981;
        }
        .status-overlay.success .status-progress {
            background: #10b981;
        }
        .status-overlay.error .status-card {
            border-color: #ef4444;
        }
        .status-overlay.error .status-progress {
            background: #ef4444;
        }
    </style>
    
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <!-- SHARED RUNTIME: functions.js must be loaded here for custom functions to work -->
    <script src="https://chris-cloudextend.github.io/netsuite-excel-addin/functions.js?v=3.0.5.237"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <!-- SheetJS for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ExcelJS for styled Excel export -->
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
    <script>
        // ========================================================================
        // CONTEXT MENU FUNCTION - MUST be registered FIRST before Office.onReady
        // ExecuteFunction actions require the function to exist immediately
        // ========================================================================
        
        // Forward declaration - the actual drillDownTransactions is defined later
        let drillDownTransactionsReady = null;
        
        // ========================================================================
        // CONTEXT MENU DRILL-DOWN - Triggered via localStorage flag from sharedruntime.html
        // ExecuteFunction runs in blank sharedruntime.html, sets flag, shows taskpane
        // Taskpane reads flag and performs the actual drill-down with UI
        // ========================================================================
        const DRILL_SERVER_URL = 'https://netsuite-proxy.chris-corcoran.workers.dev';
        
        let lastPendingDrilldownTimestamp = 0;
        
        // ================================================================
        // CONTEXT MENU DRILL-DOWN (via localStorage from sharedruntime.html)
        // NOTE: This feature has Mac platform limitations. The right-click 
        // context menu often fails on Mac Excel due to WebView handling.
        // Users should prefer the Quick Actions "Drill Down" button instead.
        // This code is kept for potential Windows support and future fixes.
        // ================================================================
        
        // Check for pending drilldown immediately
        async function checkPendingDrilldown() {
            try {
                const pendingJson = localStorage.getItem('xavi_pending_drilldown');
                if (!pendingJson) return;
                
                const request = JSON.parse(pendingJson);
                
                // Only process if recent (within 5 seconds) and new
                if (Date.now() - request.timestamp > 5000) {
                    localStorage.removeItem('xavi_pending_drilldown');
                    return;
                }
                
                if (request.timestamp <= lastPendingDrilldownTimestamp) {
                    return;
                }
                
                lastPendingDrilldownTimestamp = request.timestamp;
                localStorage.removeItem('xavi_pending_drilldown');
                
                console.log(' Processing pending drilldown:', request);
                await processPendingDrilldown(request);
                
            } catch (e) {
                console.error('checkPendingDrilldown error:', e);
            }
        }
        
        // Poll for pending drilldowns
        function startPendingDrilldownListener() {
            setInterval(() => checkPendingDrilldown(), 200);
        }
        
        // Process the pending drilldown request
        async function processPendingDrilldown(request) {
            const { formula, sheetName, address } = request;
            const upperFormula = String(formula || '').toUpperCase();
            
            try {
                // Handle XAVI.BALANCE - delegate to drillDownTransactions which reads selected cell
                if (upperFormula.includes('XAVI.BALANCE')) {
                    showDrilldownStatus('Processing BALANCE formula...');
                    await drillDownTransactions();
                    return;
                }
                
                // Handle XAVI.TYPEBALANCE
                if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                    showDrilldownStatus('Parsing TYPEBALANCE formula...');
                    await Excel.run(async (context) => {
                        await handleTypeBalanceDrillDown(context, formula, null);
                    });
                    hideDrilldownStatus();
                    return;
                }
                
                // Handle secondary drill-down from DrillDown_ sheet - delegate to drillDownTransactions
                if (sheetName && sheetName.startsWith('DrillDown_')) {
                    showDrilldownStatus('Processing secondary drill-down...');
                    await drillDownTransactions();
                    return;
                }
                
                console.log('No drill-down action for this cell');
                
            } catch (err) {
                console.error('processPendingDrilldown error:', err);
                hideDrilldownStatus();
            }
        }
        
        async function triggerContextMenuDrillDown() {
            console.log('=== CONTEXT MENU DRILL-DOWN (URL param fallback) ===');
            
            try {
                await performDrillDownOnSelectedCell();
            } catch (err) {
                console.error('Drill-down error:', err);
                hideDrilldownStatus();
            }
        }
        
        async function performDrillDownOnSelectedCell() {
            await Excel.run(async (context) => {
                const range = context.workbook.getSelectedRange();
                const sheet = context.workbook.worksheets.getActiveWorksheet();
                range.load(['formulas', 'values', 'address']);
                sheet.load('name');
                await context.sync();
                
                const formula = range.formulas[0][0];
                const address = range.address;
                const sheetName = sheet.name;
                const upperFormula = String(formula || '').toUpperCase();
                
                console.log(' Drill-down cell:', address, 'Sheet:', sheetName);
                console.log(' Formula:', formula);
                
                // Handle XAVI.BALANCE formulas
                if (upperFormula.includes('XAVI.BALANCE')) {
                    showDrilldownStatus('Parsing BALANCE formula...');
                    const match = formula.match(/XAVI\.BALANCE\s*\((.*)\)/i);
                    if (!match) { hideDrilldownStatus(); return; }
                    
                    const params = parseFormulaCellRefs(match[1]);
                    const resolved = await resolveFormulaParams(params);
                    
                    const account = resolved[0] || '';
                    const period = resolved[2] || resolved[1] || '';
                    const subsidiary = resolved[3] || '';
                    
                    showDrilldownStatus(`Fetching transactions for ${account}...`);
                    await drillDownTransactions(account, period, subsidiary);
                    hideDrilldownStatus();
                    return;
                }
                
                // Handle XAVI.TYPEBALANCE formulas
                if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                    // handleTypeBalanceDrillDown parses formula itself
                    await handleTypeBalanceDrillDown(context, formula, null);
                    return;
                }
                
                // Handle secondary drill-down from DrillDown_ sheet
                if (sheetName.startsWith('DrillDown_')) {
                    const rowMatch = address.match(/(\d+)(?:\D*)?$/);
                    const row = rowMatch ? parseInt(rowMatch[1]) : 0;
                    
                    if (row >= 6) {
                        const acctCell = sheet.getRange(`A${row}`);
                        const ctxCell = sheet.getRange('A3');
                        acctCell.load('values');
                        ctxCell.load('values');
                        await context.sync();
                        
                        const account = String(acctCell.values[0][0] || '');
                        const ctx = String(ctxCell.values[0][0] || '');
                        
                        if (account && ctx.startsWith('DRILLDOWN_CONTEXT:')) {
                            const parts = ctx.replace('DRILLDOWN_CONTEXT:', '').split(':');
                            const period = parts[0] || '';
                            const subsidiary = parts[1] || '';
                            
                            showDrilldownStatus(`Fetching transactions for ${account}...`);
                            await drillDownTransactions(account, period, subsidiary);
                            hideDrilldownStatus();
                            return;
                        }
                    }
                }
                
                console.log('No drill-down action for this cell');
            });
        }
        
        // Self-contained drill-down logic - doesn't depend on anything else in taskpane
        async function inlineDrillDown() {
            await Excel.run(async (context) => {
                const range = context.workbook.getSelectedRange();
                const sheet = context.workbook.worksheets.getActiveWorksheet();
                range.load(['formulas', 'values', 'address']);
                sheet.load('name');
                await context.sync();
                
                const formula = range.formulas[0][0];
                const address = range.address;
                const sheetName = sheet.name;
                const upperFormula = String(formula || '').toUpperCase();
                
                console.log('Cell:', address, 'Sheet:', sheetName, 'Formula:', formula);
                
                // Handle XAVI.BALANCE
                if (upperFormula.includes('XAVI.BALANCE')) {
                    const match = formula.match(/XAVI\.BALANCE\s*\((.*)\)/i);
                    if (match) {
                        const params = parseParams(match[1]);
                        const resolved = await resolveRefs(context, params);
                        console.log('BALANCE params:', resolved);
                        
                        const qp = new URLSearchParams({
                            account: resolved[0] || '',
                            period: resolved[2] || resolved[1] || ''
                        });
                        if (resolved[3]) qp.append('subsidiary', resolved[3]);
                        
                        const resp = await fetch(`${DRILL_SERVER_URL}/transactions?${qp}`);
                        if (resp.ok) {
                            const data = await resp.json();
                            await createTxnSheet(context, data.transactions || [], resolved[0], resolved[2] || resolved[1]);
                        }
                    }
                    return;
                }
                
                // Handle XAVI.TYPEBALANCE
                if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                    const match = formula.match(/XAVI\.TYPEBALANCE\s*\((.*)\)/i);
                    if (match) {
                        const params = parseParams(match[1]);
                        const resolved = await resolveRefs(context, params);
                        console.log('TYPEBALANCE params:', resolved);
                        
                        const qp = new URLSearchParams({
                            account_type: resolved[0] || '',
                            to_period: resolved[2] || ''
                        });
                        if (resolved[3]) qp.append('subsidiary', resolved[3]);
                        
                        const resp = await fetch(`${DRILL_SERVER_URL}/accounts/by-type?${qp}`);
                        if (resp.ok) {
                            const data = await resp.json();
                            await createAcctsSheet(context, data.accounts || [], resolved[0], resolved[2], resolved[3]);
                        }
                    }
                    return;
                }
                
                // Handle secondary drill-down from DrillDown_ sheet (accounts list  transactions)
                if (sheetName.startsWith('DrillDown_')) {
                    console.log(' Secondary drill-down from DrillDown_ sheet');
                    
                    // Extract row number from address (handles formats like "'DrillDown_Income'!C7" or "C7")
                    const rowMatch = address.match(/(\d+)(?:\D*)?$/);
                    const row = rowMatch ? parseInt(rowMatch[1]) : 0;
                    console.log(`   Address: ${address}, Extracted row: ${row}`);
                    
                    if (row >= 6) {
                        // Get account number from column A of same row
                        const acctCell = sheet.getRange(`A${row}`);
                        const ctxCell = sheet.getRange('A3');
                        acctCell.load('values');
                        ctxCell.load('values');
                        await context.sync();
                        
                        const acct = String(acctCell.values[0][0] || '');
                        const ctx = String(ctxCell.values[0][0] || '');
                        
                        console.log(`   Account: "${acct}", Context: "${ctx}"`);
                        
                        if (acct && ctx.startsWith('DRILLDOWN_CONTEXT:')) {
                            const parts = ctx.replace('DRILLDOWN_CONTEXT:', '').split(':');
                            const period = parts[0] || '';
                            const subsidiary = parts[1] || '';
                            
                            console.log(`   Fetching transactions for ${acct}, period=${period}, subsidiary=${subsidiary}`);
                            
                            const qp = new URLSearchParams({ account: acct, period: period });
                            if (subsidiary) qp.append('subsidiary', subsidiary);
                            
                            const resp = await fetch(`${DRILL_SERVER_URL}/transactions?${qp}`);
                            console.log(`   API response status: ${resp.status}`);
                            
                            if (resp.ok) {
                                const data = await resp.json();
                                console.log(`   Got ${(data.transactions || []).length} transactions`);
                                await createTxnSheet(context, data.transactions || [], acct, period);
                            } else {
                                console.error('   API error:', resp.status);
                            }
                        } else {
                            console.log('   No valid account or context found');
                        }
                    } else {
                        console.log(`   Row ${row} is a header row, skipping`);
                    }
                    return;
                }
                
                console.log('No drill-down action for this cell');
            });
        }
        
        function parseParams(str) {
            const params = [];
            let cur = '', inQ = false, depth = 0;
            for (const c of str) {
                if (c === '"') { inQ = !inQ; cur += c; }
                else if (c === '(' && !inQ) { depth++; cur += c; }
                else if (c === ')' && !inQ) { depth--; cur += c; }
                else if (c === ',' && !inQ && depth === 0) { params.push(cur.trim()); cur = ''; }
                else { cur += c; }
            }
            if (cur.trim()) params.push(cur.trim());
            return params;
        }
        
        async function resolveRefs(context, params) {
            const resolved = [];
            for (const p of params) {
                const clean = p.replace(/^["']|["']$/g, '');
                if (/^[\$]?[A-Z]+[\$]?\d+$/i.test(clean)) {
                    try {
                        const cell = context.workbook.worksheets.getActiveWorksheet().getRange(clean);
                        cell.load('values');
                        await context.sync();
                        let v = cell.values[0][0];
                        if (typeof v === 'number' && v > 1000 && v < 100000) {
                            const d = new Date(Math.round((v - 25569) * 86400 * 1000));
                            v = d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }
                        resolved.push(String(v || ''));
                    } catch (e) { resolved.push(''); }
                } else {
                    resolved.push(clean);
                }
            }
            return resolved;
        }
        
        async function createTxnSheet(context, txns, acct, period) {
            const name = `Transactions_${acct}`.substring(0, 31);
            const sheets = context.workbook.worksheets;
            sheets.load('items/name');
            await context.sync();
            
            const existing = sheets.items.find(s => s.name === name);
            if (existing) { existing.delete(); await context.sync(); }
            
            const sh = sheets.add(name);
            sh.activate();
            sh.getRange('A1').values = [[`Transactions: ${acct} - ${period}`]];
            sh.getRange('A1').format.font.bold = true;
            sh.getRange('A1').format.font.size = 14;
            
            sh.getRange('A3:G3').values = [['Date', 'Type', 'Doc #', 'Memo', 'Debit', 'Credit', 'Amount']];
            sh.getRange('A3:G3').format.font.bold = true;
            sh.getRange('A3:G3').format.fill.color = '#667eea';
            sh.getRange('A3:G3').format.font.color = 'white';
            
            if (txns.length > 0) {
                const rows = txns.map(t => [t.date || '', t.type || '', t.doc_number || '', t.memo || '', t.debit || 0, t.credit || 0, t.amount || 0]);
                sh.getRange(`A4:G${3 + txns.length}`).values = rows;
                sh.getRange(`E4:G${3 + txns.length}`).numberFormat = [['$#,##0.00']];
            }
            sh.getRange('A:G').format.autofitColumns();
            await context.sync();
        }
        
        async function createAcctsSheet(context, accts, type, period, sub) {
            const name = `DrillDown_${type}`.substring(0, 31);
            const sheets = context.workbook.worksheets;
            sheets.load('items/name');
            await context.sync();
            
            const existing = sheets.items.find(s => s.name === name);
            if (existing) { existing.delete(); await context.sync(); }
            
            const sh = sheets.add(name);
            sh.activate();
            sh.getRange('A1').values = [['TYPEBALANCE DRILL-DOWN']];
            sh.getRange('A1').format.font.bold = true;
            sh.getRange('A2').values = [[`Type: ${type} | Period: ${period || 'All'}`]];
            
            const ym = (period || '').match(/\d{4}/);
            sh.getRange('A3').values = [[`DRILLDOWN_CONTEXT:${ym ? ym[0] : period || ''}:${sub || ''}`]];
            sh.getRange('A3').format.font.color = 'white';
            
            sh.getRange('A5:C5').values = [['Account', 'Account Name', 'Balance']];
            sh.getRange('A5:C5').format.font.bold = true;
            sh.getRange('A5:C5').format.fill.color = '#667eea';
            sh.getRange('A5:C5').format.font.color = 'white';
            
            if (accts.length > 0) {
                const rows = accts.map(a => [a.account_number || a.acctnumber || '', a.account_name || a.accountname || '', a.balance || 0]);
                sh.getRange(`A6:C${5 + accts.length}`).values = rows;
                sh.getRange(`C6:C${5 + accts.length}`).numberFormat = [['$#,##0.00']];
                sh.getRange(`A6:A${5 + accts.length}`).format.font.color = '#0ea5e9';
            }
            sh.getRange('A:C').format.autofitColumns();
            await context.sync();
        }
        
        // NOTE: With ShowTaskpane approach (v3.0.5.187+), we no longer use ExecuteFunction
        // so no need to register drillDownFromContextMenu. The drill-down is triggered
        // automatically when taskpane opens with ?action=drilldown parameter.
        
        // SERVER_URL is defined in functions.js (loaded via shared runtime)
        // Do NOT redeclare it here to avoid duplicate variable error
        
        // ========================================================================
        // CURRENCY CACHE - Fetched once, reused until page reload
        // ========================================================================
        let currencyCache = null;  // { currencies: {...}, formats: {...}, default_subsidiary: "1" }
        let subsidiaryLookupCache = null;  // { name.toLowerCase()  id }
        
        async function getCurrencyData() {
            if (currencyCache) {
                console.log(' Using cached currency data');
                return currencyCache;
            }
            
            console.log(' Fetching currency data...');
            const response = await fetch(`${SERVER_URL}/lookups/currencies`);
            if (response.ok) {
                currencyCache = await response.json();
                console.log(' Currency data cached:', Object.keys(currencyCache.currencies).length, 'subsidiaries');
            }
            return currencyCache;
        }
        
        async function getSubsidiaryLookup() {
            if (subsidiaryLookupCache) {
                console.log(' Using cached subsidiary lookup');
                return subsidiaryLookupCache;
            }
            
            console.log(' Fetching subsidiary lookup...');
            subsidiaryLookupCache = {};
            const response = await fetch(`${SERVER_URL}/lookups/all`);
            if (response.ok) {
                const lookups = await response.json();
                for (const sub of (lookups.subsidiaries || [])) {
                    subsidiaryLookupCache[sub.name.toLowerCase()] = sub.id;
                    subsidiaryLookupCache[sub.id] = sub.id;
                }
                console.log(' Subsidiary lookup cached:', Object.keys(subsidiaryLookupCache).length, 'entries');
            }
            return subsidiaryLookupCache;
        }
        
        // ========================================================================
        // CURRENCY TO FLAG MAPPING - Maps currency symbols to country flags
        // ========================================================================
        function getCurrencyFlag(currencySymbol) {
            const flagMap = {
                '$': '',       // USD (United States)
                'A$': '',      // AUD (Australia)
                'AU$': '',     // AUD alternate
                '': '',       // EUR (European Union)
                '': '',       // GBP (United Kingdom)
                '': '',       // JPY (Japan) - also CNY
                '': '',       // INR (India)
                'R$': '',      // BRL (Brazil)
                'C$': '',      // CAD (Canada)
                'CA$': '',     // CAD alternate
                'CHF': '',     // Swiss Franc
                'kr': '',      // SEK/NOK/DKK (Scandinavia - default to Sweden)
                'NZ$': '',     // NZD (New Zealand)
                'HK$': '',     // HKD (Hong Kong)
                'S$': '',      // SGD (Singapore)
                'SG$': '',     // SGD alternate
                '': '',       // KRW (South Korea)
                'MX$': '',     // MXN (Mexico)
                'R': '',       // ZAR (South Africa)
                '': '',       // PHP (Philippines)
                '': '',       // THB (Thailand)
                'RM': '',      // MYR (Malaysia)
                'Rp': '',      // IDR (Indonesia)
                '': '',       // VND (Vietnam)
                'z': '',      // PLN (Poland)
                'K': '',      // CZK (Czech Republic)
                'Ft': '',      // HUF (Hungary)
                '': '',       // ILS (Israel)
                'AED': '',     // UAE Dirham
                'SAR': '',     // Saudi Riyal
            };
            return flagMap[currencySymbol] || '';  // Default to money bag
        }
        
        // ========================================================================
        // VIEW MODE TOGGLE - Progressive Disclosure
        // ========================================================================
        let showAllSections = false;
        
        function toggleViewMode() {
            showAllSections = !showAllSections;
            const panel = document.getElementById('panelFinancial');
            const toggle = document.getElementById('viewModeToggle');
            
            if (showAllSections) {
                panel.classList.add('show-all-sections');
                toggle.classList.add('active');
                localStorage.setItem('xavi_view_mode', 'all');
            } else {
                panel.classList.remove('show-all-sections');
                toggle.classList.remove('active');
                localStorage.setItem('xavi_view_mode', 'simple');
            }
        }
        
        function initViewMode() {
            const savedMode = localStorage.getItem('xavi_view_mode');
            if (savedMode === 'all') {
                showAllSections = true;
                document.getElementById('panelFinancial').classList.add('show-all-sections');
                document.getElementById('viewModeToggle').classList.add('active');
            }
        }
        
        // ========================================================================
        // CONTEXTUAL UI - Detect sheet state and update quick actions bar
        // ========================================================================
        let contextualState = {
            formulaCount: 0,
            hasXaviFormulas: false,
            selectedCellHasXavi: false,
            selectedFormulaType: null, // 'BALANCE', 'BUDGET', 'TYPEBALANCE', 'NETINCOME', etc.
            isCalculating: false,
            // Parameter cell detection
            selectedParamType: null,  // 'year', 'subsidiary', 'department', 'location', 'class', 'accountingBook'
            selectedCellAddress: null
        };
        
        // Parameter cell mapping - maps cell addresses to parameter types
        const PARAM_CELL_CONFIG = {
            'P3': { type: 'year', icon: '', label: 'Year', inputType: 'input', placeholder: 'e.g., 2025', hint: 'Enter a 4-digit year' },
            'Q3': { type: 'subsidiary', icon: '', label: 'Subsidiary', inputType: 'select', source: 'subsidiarySelect', hint: 'Add "(Consolidated)" for rollups' },
            'R3': { type: 'department', icon: '', label: 'Department', inputType: 'select', source: 'departmentSelect', hint: 'Leave empty for all departments' },
            'S3': { type: 'location', icon: '', label: 'Location', inputType: 'select', source: 'locationSelect', hint: 'Leave empty for all locations' },
            'T3': { type: 'class', icon: '', label: 'Class', inputType: 'select', source: 'classSelect', hint: 'Leave empty for all classes' },
            'U3': { type: 'accountingBook', icon: '', label: 'Accounting Book', inputType: 'select', source: 'accountingBookSelect', hint: 'Default is Primary Book' }
        };
        
        async function updateContextualUI() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const selection = context.workbook.getSelectedRange();
                    
                    // Load sheet name for DrillDown_ detection
                    sheet.load('name');
                    
                    // Load used range for formula count
                    let usedRange;
                    try {
                        usedRange = sheet.getUsedRange();
                        usedRange.load('formulas');
                    } catch (e) {
                        // Sheet might be empty
                        usedRange = null;
                    }
                    
                    // Load selected cell info
                    selection.load(['formulas', 'values', 'address', 'rowIndex']);
                    
                    await context.sync();
                    
                    // Count XAVI formulas on sheet
                    let formulaCount = 0;
                    let hasXaviFormulas = false;
                    
                    if (usedRange && usedRange.formulas) {
                        const formulas = usedRange.formulas;
                        for (let row of formulas) {
                            for (let cell of row) {
                                if (cell && typeof cell === 'string' && cell.toUpperCase().includes('XAVI.')) {
                                    formulaCount++;
                                    hasXaviFormulas = true;
                                }
                            }
                        }
                    }
                    
                    // Check selected cell
                    let selectedCellHasXavi = false;
                    let selectedFormulaType = null;
                    let isDrillDownSheetRow = false;
                    
                    const selectedFormula = selection.formulas[0][0];
                    if (selectedFormula && typeof selectedFormula === 'string') {
                        const upper = selectedFormula.toUpperCase();
                        if (upper.includes('XAVI.BALANCE')) {
                            selectedCellHasXavi = true;
                            selectedFormulaType = 'BALANCE';
                        } else if (upper.includes('XAVI.TYPEBALANCE')) {
                            selectedCellHasXavi = true;
                            selectedFormulaType = 'TYPEBALANCE';
                        } else if (upper.includes('XAVI.BUDGET')) {
                            selectedCellHasXavi = true;
                            selectedFormulaType = 'BUDGET';
                        } else if (upper.includes('XAVI.NETINCOME')) {
                            selectedCellHasXavi = true;
                            selectedFormulaType = 'NETINCOME';
                        } else if (upper.includes('XAVI.')) {
                            selectedCellHasXavi = true;
                            selectedFormulaType = 'OTHER';
                        }
                    }
                    
                    // Check if on a DrillDown_ sheet in a data row (for secondary drill)
                    if (sheet.name.startsWith('DrillDown_')) {
                        // Row index is 0-based, data starts at row 6 (index 5)
                        const rowNum = selection.rowIndex + 1; // Convert to 1-based
                        if (rowNum >= 6) {
                            // Check if this row has an account number (not TOTAL, not empty)
                            const cellValue = String(selection.values[0][0] || '');
                            const firstCellInRow = sheet.getRange(`A${rowNum}`);
                            firstCellInRow.load('values');
                            await context.sync();
                            
                            const acctValue = String(firstCellInRow.values[0][0] || '');
                            if (acctValue && acctValue !== 'TOTAL' && !acctValue.startsWith('')) {
                                isDrillDownSheetRow = true;
                                selectedFormulaType = 'DRILLDOWN_ACCOUNT';
                            }
                        }
                    }
                    
                    // Update state
                    contextualState.formulaCount = formulaCount;
                    contextualState.hasXaviFormulas = hasXaviFormulas;
                    contextualState.selectedCellHasXavi = selectedCellHasXavi || isDrillDownSheetRow;
                    contextualState.selectedFormulaType = selectedFormulaType;
                    contextualState.isDrillDownSheetRow = isDrillDownSheetRow;
                    
                    // ========================================
                    // PARAMETER CELL DETECTION
                    // Check if selected cell is a known parameter cell (P3, Q3, R3, S3, T3, U3)
                    // ========================================
                    let normalizedAddress = selection.address;
                    // Remove sheet name prefix if present (e.g., "Sheet1!Q3" -> "Q3")
                    if (normalizedAddress.includes('!')) {
                        normalizedAddress = normalizedAddress.split('!')[1];
                    }
                    // Remove $ signs (e.g., "$Q$3" -> "Q3")
                    normalizedAddress = normalizedAddress.replace(/\$/g, '').toUpperCase();
                    
                    contextualState.selectedCellAddress = normalizedAddress;
                    
                    // Check if this is a parameter cell
                    const paramConfig = PARAM_CELL_CONFIG[normalizedAddress];
                    if (paramConfig) {
                        contextualState.selectedParamType = paramConfig.type;
                        // Show the context popup with this parameter type
                        showParamContextPopup(normalizedAddress, paramConfig, selection.values[0][0]);
                    } else {
                        contextualState.selectedParamType = null;
                        hideParamContextPopup();
                    }
                    
                    // Update UI
                    updateQuickActionsUI();
                });
            } catch (e) {
                console.log('Contextual UI check skipped:', e.message);
                // Show default state
                updateQuickActionsUI();
                hideParamContextPopup();
            }
        }
        
        function updateQuickActionsUI() {
            const statusEl = document.getElementById('quickActionsStatus');
            const iconEl = document.getElementById('statusBadgeIcon');
            const textEl = document.getElementById('statusBadgeText');
            const refreshBtn = document.getElementById('quickRefreshBtn');
            const refreshSelectedBtn = document.getElementById('quickRefreshSelectedBtn');
            const drillBtn = document.getElementById('quickDrillBtn');
            const footerEl = document.getElementById('quickActionsFooter');
            const countTextEl = document.getElementById('formulaCountText');
            
            // Reset classes
            statusEl.className = 'quick-actions-status';
            footerEl.className = 'quick-actions-footer';
            refreshBtn.classList.remove('highlight');
            drillBtn.classList.remove('highlight');
            
            // Always update footer with formula count
            if (contextualState.formulaCount > 0) {
                countTextEl.textContent = `${contextualState.formulaCount} XAVI formula${contextualState.formulaCount !== 1 ? 's' : ''} on this sheet`;
                footerEl.classList.add('has-formulas');
            } else {
                countTextEl.textContent = 'No formulas on this sheet';
            }
            
            if (contextualState.isCalculating) {
                // Calculating state
                statusEl.classList.add('calculating');
                iconEl.textContent = '';
                textEl.textContent = 'Calculating formulas...';
                refreshBtn.disabled = true;
                refreshSelectedBtn.disabled = true;
                drillBtn.disabled = true;
            } else if (contextualState.isDrillDownSheetRow) {
                // On a DrillDown_ sheet in an account row - always allow drill
                statusEl.classList.add('has-selection');
                iconEl.textContent = '';
                textEl.textContent = 'Account row selected  Drill Down to transactions';
                drillBtn.disabled = false;
                drillBtn.classList.add('highlight');
                refreshBtn.disabled = true; // No formulas to refresh
                refreshSelectedBtn.disabled = true;
            } else if (contextualState.formulaCount === 0) {
                // Empty sheet - no XAVI formulas
                statusEl.classList.add('empty-sheet');
                iconEl.textContent = '';
                textEl.textContent = 'No XAVI formulas yet  Use Quick Start above or start building on your own';
                refreshBtn.disabled = true;
                refreshSelectedBtn.disabled = true;
                drillBtn.disabled = true;
            } else if (contextualState.selectedCellHasXavi) {
                // Cell with XAVI formula selected OR on drill-down sheet row
                statusEl.classList.add('has-selection');
                
                if (contextualState.selectedFormulaType === 'BALANCE' || 
                    contextualState.selectedFormulaType === 'TYPEBALANCE') {
                    iconEl.textContent = '';
                    textEl.textContent = `${contextualState.selectedFormulaType} selected  Drill Down ready`;
                    drillBtn.disabled = false;
                    drillBtn.classList.add('highlight');
                } else if (contextualState.selectedFormulaType === 'DRILLDOWN_ACCOUNT') {
                    iconEl.textContent = '';
                    textEl.textContent = 'Account row selected  Drill Down to transactions';
                    drillBtn.disabled = false;
                    drillBtn.classList.add('highlight');
                } else if (contextualState.selectedFormulaType === 'BUDGET') {
                    iconEl.textContent = '';
                    textEl.textContent = 'BUDGET selected  Drill Down not available';
                    drillBtn.disabled = true;
                } else {
                    iconEl.textContent = '';
                    textEl.textContent = `${contextualState.selectedFormulaType} selected`;
                    drillBtn.disabled = true;
                }
                
                refreshBtn.disabled = false;
                refreshSelectedBtn.disabled = false;
            } else {
                // Has formulas but none selected - show ready state
                statusEl.classList.add('has-formulas');
                iconEl.textContent = '';
                textEl.textContent = 'Ready  Select a BALANCE formula to drill down';
                refreshBtn.disabled = false;
                refreshSelectedBtn.disabled = false;
                drillBtn.disabled = true; // Can't drill without selection
            }
        }
        
        // Set up selection change listener
        async function setupSelectionChangeListener() {
            try {
                await Excel.run(async (context) => {
                    const workbook = context.workbook;
                    
                    // Listen for selection changes
                    workbook.onSelectionChanged.add(async (event) => {
                        // Debounce rapid selection changes
                        clearTimeout(window._selectionDebounce);
                        window._selectionDebounce = setTimeout(() => {
                            updateContextualUI();
                        }, 150);
                    });
                    
                    await context.sync();
                    console.log(' Selection change listener registered');
                });
            } catch (e) {
                console.log('Could not set up selection listener:', e.message);
            }
        }
        
        // Track calculation state
        function setCalculatingState(isCalculating) {
            contextualState.isCalculating = isCalculating;
            updateQuickActionsUI();
        }
        
        // ========================================================================
        // PARAMETER CONTEXT POPUP - Smart filter UI when parameter cells selected
        // ========================================================================
        let currentParamConfig = null;
        let currentParamCellAddress = null;
        
        function showParamContextPopup(cellAddress, config, currentValue) {
            currentParamConfig = config;
            currentParamCellAddress = cellAddress;
            
            const popup = document.getElementById('paramContextPopup');
            const iconEl = document.getElementById('paramContextIcon');
            const labelEl = document.getElementById('paramContextLabel');
            const cellEl = document.getElementById('paramContextCell');
            const selectEl = document.getElementById('paramContextSelect');
            const inputEl = document.getElementById('paramContextInput');
            const hintTextEl = document.getElementById('paramContextHintText');
            
            // Set header
            iconEl.textContent = config.icon;
            labelEl.textContent = config.label;
            cellEl.textContent = cellAddress;
            hintTextEl.textContent = config.hint;
            
            // Show appropriate input type
            if (config.inputType === 'select') {
                selectEl.style.display = 'block';
                inputEl.style.display = 'none';
                
                // Copy options from the source select
                const sourceSelect = document.getElementById(config.source);
                if (sourceSelect) {
                    selectEl.innerHTML = sourceSelect.innerHTML;
                    // Try to select current value
                    if (currentValue) {
                        const currentStr = String(currentValue).trim();
                        for (let option of selectEl.options) {
                            if (option.value === currentStr || option.text === currentStr) {
                                option.selected = true;
                                break;
                            }
                        }
                    }
                }
            } else {
                selectEl.style.display = 'none';
                inputEl.style.display = 'block';
                inputEl.placeholder = config.placeholder || 'Enter value...';
                inputEl.value = currentValue || '';
            }
            
            // Show with animation
            requestAnimationFrame(() => {
                popup.classList.add('visible');
            });
            
            console.log(` Parameter cell detected: ${cellAddress} (${config.type})`);
        }
        
        function hideParamContextPopup() {
            const popup = document.getElementById('paramContextPopup');
            popup.classList.remove('visible');
            currentParamConfig = null;
            currentParamCellAddress = null;
        }
        
        async function applyParamContextValue() {
            if (!currentParamConfig || !currentParamCellAddress) return;
            
            const selectEl = document.getElementById('paramContextSelect');
            const inputEl = document.getElementById('paramContextInput');
            
            // Get the value based on input type
            let newValue;
            if (currentParamConfig.inputType === 'select') {
                newValue = selectEl.value;
            } else {
                newValue = inputEl.value.trim();
            }
            
            // CRITICAL: For parameter cells that trigger sync (P3, Q3, R3, S3, T3, U3),
            // suppress the statusBar BEFORE writing to prevent "Fetching P&L" flash
            const syncTriggerCells = ['P3', 'Q3', 'R3', 'S3', 'T3', 'U3'];
            const normalizedAddr = currentParamCellAddress.replace(/\$/g, '').toUpperCase();
            if (syncTriggerCells.includes(normalizedAddr)) {
                console.log(` Pre-suppressing statusBar before writing to ${normalizedAddr}`);
                suppressStatusBar = true;
                localStorage.removeItem('netsuite_status');
                hideStatus();
            }
            
            // Apply the value to the cell
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const cell = sheet.getRange(currentParamCellAddress);
                    
                    // For year, convert to number
                    if (currentParamConfig.type === 'year' && newValue) {
                        const yearNum = parseInt(newValue, 10);
                        if (!isNaN(yearNum) && yearNum >= 1900 && yearNum <= 2100) {
                            cell.values = [[yearNum]];
                        } else {
                            cell.values = [[newValue]];
                        }
                    } else {
                        cell.values = [[newValue]];
                    }
                    
                    await context.sync();
                    console.log(` Applied "${newValue}" to ${currentParamCellAddress}`);
                });
                
                // CRITICAL: Immediately unlock isSyncInProgress when user manually applies a value
                // This allows the sync to trigger for this user-initiated change
                if (syncTriggerCells.includes(normalizedAddr)) {
                    console.log(` User applied value to ${normalizedAddr} - unlocking isSyncInProgress`);
                    isSyncInProgress = false;
                }
                
                // Show brief success feedback
                const btn = document.querySelector('.param-context-btn');
                const originalText = btn.textContent;
                btn.textContent = ' Applied';
                btn.style.background = '#22c55e';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 1500);
                
            } catch (error) {
                console.error('Failed to apply parameter value:', error);
            }
        }
        
        // ========================================================================
        // INTERACTIVE ONBOARDING WIZARD
        // ========================================================================
        let onboardingState = {
            currentStep: 2,
            selectedAccount: null,
            selectedAccountName: null,
            insertedValue: null,
            tutorialSheetName: null  // Save the sheet where tutorial started
        };
        
        async function startOnboarding() {
            // Skip confirmation dialog - go directly to the tutorial
            // The first step (Pick an Account) already shows what the tutorial does
            launchOnboardingWizard();
        }
        
        async function launchOnboardingWizard() {
            // Reset state completely
            onboardingState = {
                currentStep: 2,
                selectedAccount: null,
                selectedAccountName: null,
                insertedValue: null,
                tutorialSheetName: null
            };
            
            // Save the current sheet name so we can write celebration there later
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    sheet.load('name');
                    await context.sync();
                    onboardingState.tutorialSheetName = sheet.name;
                });
            } catch (e) {
                console.log('Could not save tutorial sheet name:', e);
            }
            
            // Reset overlay display state and show
            const overlay = document.getElementById('onboardingOverlay');
            overlay.style.display = '';  // Clear any inline display:none
            overlay.classList.add('active');
            
            // Reset to step 2 (first step - Welcome was removed)
            goToOnboardingStep(2);
        }
        
        function showOnboardingMessage(title, message, type = 'info') {
            // Use our drilldown status widget for messages
            const widget = document.getElementById('drilldownStatus');
            const msgEl = document.getElementById('drilldownMessage');
            const detailEl = document.getElementById('drilldownDetail');
            const iconEl = document.getElementById('drilldownIcon');
            const titleEl = document.getElementById('drilldownTitle');
            const dismissBtn = document.getElementById('drilldownDismiss');
            
            widget.className = 'drilldown-status ' + (type === 'warning' ? 'error' : 'success');
            iconEl.textContent = type === 'warning' ? '' : '';
            titleEl.textContent = title;
            msgEl.textContent = message;
            detailEl.textContent = '';
            dismissBtn.style.display = 'block';
            widget.style.display = 'block';
            
            // Auto-dismiss after 8 seconds
            setTimeout(() => { widget.style.display = 'none'; }, 8000);
        }
        
        function showOnboardingConfirm(title, message, onConfirm) {
            // Create a simple confirm dialog
            const overlay = document.createElement('div');
            overlay.className = 'onboarding-confirm-overlay';
            overlay.innerHTML = `
                <div class="onboarding-confirm-dialog">
                    <h3>${title}</h3>
                    <p>${message}</p>
                    <div class="confirm-buttons">
                        <button class="confirm-btn cancel" onclick="this.closest('.onboarding-confirm-overlay').remove()">No, Thanks</button>
                        <button class="confirm-btn ok" id="confirmYesBtn">Continue</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            document.getElementById('confirmYesBtn').onclick = () => {
                overlay.remove();
                onConfirm();
            };
        }
        
        async function isSheetEmpty() {
            try {
                let isEmpty = true;
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    let usedRange;
                    try {
                        usedRange = sheet.getUsedRange();
                        usedRange.load('cellCount');
                        await context.sync();
                        isEmpty = !usedRange || usedRange.cellCount === 0;
                    } catch (e) {
                        // getUsedRange throws if sheet is completely empty
                        isEmpty = true;
                    }
                });
                return isEmpty;
            } catch (e) {
                return true; // Assume empty on error
            }
        }
        
        function skipOnboarding() {
            document.getElementById('onboardingOverlay').classList.remove('active');
        }
        
        function goToOnboardingStep(step) {
            // Hide all steps (step 1 removed, starts at 2)
            const steps = ['2', '3', '4', '4b', '5', '6', '7', '8', '9', '10'];
            steps.forEach(s => {
                const el = document.getElementById(`onboardingStep${s}`);
                if (el) el.classList.remove('active');
            });
            // Show requested step
            const targetEl = document.getElementById(`onboardingStep${step}`);
            if (targetEl) targetEl.classList.add('active');
            onboardingState.currentStep = step;
            updateOnboardingProgress();
        }
        
        function updateOnboardingProgress() {
            const stepOrder = ['2', '3', '4', '4b', '5', '6', '7', '8', '9', '10'];
            const currentIdx = stepOrder.indexOf(String(onboardingState.currentStep));
            const segments = document.querySelectorAll('.progress-bar-container .segment');
            segments.forEach((segment, index) => {
                segment.classList.remove('active', 'completed');
                if (index === currentIdx) {
                    segment.classList.add('active');
                } else if (index < currentIdx) {
                    segment.classList.add('completed');
                }
            });
            // Update progress text
            const progressText = document.getElementById('progressText');
            if (progressText) {
                progressText.textContent = `${currentIdx + 1} of ${stepOrder.length}`;
            }
        }
        
        async function demoSelectForDrill() {
            // Try to select a cell with a BALANCE formula for the user
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    // Select C2 which should have a BALANCE formula from the tutorial
                    const cell = sheet.getRange('C2');
                    cell.select();
                    await context.sync();
                });
                document.getElementById('drillDemoHint').innerHTML = ' Cell selected! Now <strong>right-click</strong>  select <strong>CloudExtend</strong>  choose <strong>Drill Down</strong>';
                document.getElementById('drillDemoHint').style.color = '#047857';
            } catch (e) {
                console.error('Error selecting cell:', e);
            }
        }
        
        async function doBulkAddFromOnboarding() {
            // Get the pattern from the onboarding input
            const pattern = document.getElementById('onboardingBulkAddInput')?.value?.trim() || '*';
            
            // Close the onboarding overlay temporarily
            const overlay = document.getElementById('onboardingOverlay');
            if (overlay) overlay.style.display = 'none';
            
            try {
                // First, select cell A12 to start the bulk add
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const safeCell = sheet.getRange('A12');
                    safeCell.select();
                    await context.sync();
                });
                
                showLoading('Bulk Add', `Searching for accounts matching "${pattern}"...`, 20);
                
                // Call backend API directly (don't rely on searchAccounts which needs event.target)
                const url = `${SERVER_URL}/accounts/search?pattern=${encodeURIComponent(pattern)}`;
                console.log('Bulk Add API URL:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const accounts = data.accounts || [];
                
                if (accounts.length === 0) {
                    hideLoading();
                    showOnboardingMessage('No Accounts Found', `No accounts matched "${pattern}". Try a different pattern.`, 'info');
                    if (overlay) overlay.style.display = 'flex';
                    return;
                }
                
                updateLoading(`Inserting ${accounts.length} accounts...`, 70);
                
                // Insert accounts into the sheet
                await Excel.run(async (context) => {
                    await createAccountSearchSheet(context, accounts, pattern);
                });
                
                hideLoading();
                showOnboardingMessage('Bulk Add Complete!', `${accounts.length} accounts matching "${pattern}" have been added to your sheet.`, 'success');
                
            } catch (e) {
                console.error('Bulk add error:', e);
                hideLoading();
                showOnboardingMessage('Bulk Add Error', 'Could not fetch accounts. Check your connection and try again.', 'warning');
            }
            
            // Reopen onboarding
            if (overlay) overlay.style.display = 'flex';
        }
        
        async function doDrillDownFromOnboarding() {
            // Close the onboarding overlay temporarily
            const overlay = document.getElementById('onboardingOverlay');
            if (overlay) overlay.style.display = 'none';
            
            // Trigger the drillDownTransactions function (same as Quick Actions bar)
            try {
                await drillDownTransactions();
                
                // After successful drill down, wait a moment then show completion
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Reopen onboarding and go to the finish step
                if (overlay) {
                    overlay.style.display = 'flex';
                    goToOnboardingStep(10);
                }
            } catch (e) {
                console.error('Drill down error:', e);
                showOnboardingMessage('Drill Down', 'Select a cell with a XAVI.BALANCE formula first, then try again.', 'info');
                // Reopen onboarding on error
                if (overlay) overlay.style.display = 'flex';
            }
        }
        
        function restartOnboarding() {
            onboardingState = {
                currentStep: 2,
                selectedAccount: null,
                selectedAccountName: null,
                insertedValue: null,
                selectedAccounts: []
            };
            goToOnboardingStep(2);
        }
        
        function startOnboardingStep2() {
            goToOnboardingStep(2);
        }
        
        async function showSampleAccounts() {
            const listEl = document.getElementById('sampleAccountsList');
            const btn = document.getElementById('showAccountsBtn');
            listEl.style.display = 'block';
            listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 10px;"> Finding accounts with Jan 2025 activity...</div>';
            if (btn) btn.disabled = true;
            
            try {
                // Fetch accounts that have data for Jan 2025 (detail accounts only - those with parents)
                const response = await fetch(`${SERVER_URL}/accounts/with-activity?period=Jan 2025&limit=10&types=Income,Expense,COGS`);
                
                if (!response.ok) {
                    throw new Error('Could not load accounts');
                }
                
                const data = await response.json();
                const accounts = data.accounts || [];
                
                if (accounts.length === 0) {
                    listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 10px;">No accounts with Jan 2025 activity found. Try entering an account number manually.</div>';
                } else {
                    onboardingState.selectedAccounts = accounts;
                    renderSampleAccounts(accounts);
                }
            } catch (e) {
                console.error('Error loading sample accounts:', e);
                listEl.innerHTML = '<div style="color: #fca5a5; text-align: center; padding: 10px;">Could not load accounts. Try entering one manually (e.g., 40110).</div>';
            } finally {
                if (btn) btn.disabled = false;
            }
        }
        
        function renderSampleAccounts(accounts) {
            const listEl = document.getElementById('sampleAccountsList');
            
            if (accounts.length === 0) {
                listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 10px;">No accounts found. Try entering one manually.</div>';
                return;
            }
            
            listEl.innerHTML = accounts.map(acc => `
                <div class="sample-account-item" onclick="selectSampleAccount('${acc.accountnumber}', '${(acc.accountname || '').replace(/'/g, "\\'")}')">
                    <span class="account-number">${acc.accountnumber}</span>
                    <span class="account-name">${acc.accountname || ''}</span>
                </div>
            `).join('');
        }
        
        function selectSampleAccount(number, name) {
            document.getElementById('onboardingAccountInput').value = number;
            onboardingState.selectedAccount = number;
            onboardingState.selectedAccountName = name;
            document.getElementById('sampleAccountsList').style.display = 'none';
        }
        
        async function insertFirstFormula() {
            const inputEl = document.getElementById('onboardingAccountInput');
            const account = inputEl.value.trim() || onboardingState.selectedAccount;
            
            if (!account) {
                showOnboardingMessage('Account Required', 'Please enter an account number or click "Find Accounts" to see options.', 'warning');
                return;
            }
            
            onboardingState.selectedAccount = account;
            
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Create header row with Account Number, Account Name, and 12 months
                    const months = ['Jan 2025', 'Feb 2025', 'Mar 2025', 'Apr 2025', 'May 2025', 'Jun 2025', 
                                    'Jul 2025', 'Aug 2025', 'Sep 2025', 'Oct 2025', 'Nov 2025', 'Dec 2025'];
                    
                    // Headers: A=Number, B=Name, C-N=Months
                    const headerRange = sheet.getRange('A1:N1');
                    headerRange.values = [['Account #', 'Account Name', ...months]];
                    headerRange.format.font.bold = true;
                    headerRange.format.fill.color = '#1e3a5f';
                    headerRange.format.font.color = 'white';
                    
                    // Insert account number in A2
                    const accountCell = sheet.getRange('A2');
                    accountCell.values = [[account]];
                    
                    // Insert XAVI.NAME formula in B2 (teaches this formula!)
                    const nameCell = sheet.getRange('B2');
                    nameCell.formulas = [['=XAVI.NAME($A2)']];
                    
                    // Insert XAVI.BALANCE formula in C2 (first month)
                    const formulaCell = sheet.getRange('C2');
                    formulaCell.formulas = [['=XAVI.BALANCE($A2, C$1, C$1)']];
                    
                    // Set explicit column widths (autofit doesn't work reliably)
                    // Account # = 12, Account Name = 30, Month columns = 14 each
                    sheet.getRange('A:A').format.columnWidth = 75;  // ~12 chars
                    sheet.getRange('B:B').format.columnWidth = 180; // ~30 chars for account names
                    sheet.getRange('C:N').format.columnWidth = 90;  // ~14 chars for currency values
                    
                    await context.sync();
                    
                    // Wait for formula to calculate, then get value
                    await new Promise(resolve => setTimeout(resolve, 2500));
                    
                    formulaCell.load('values');
                    nameCell.load('values');
                    await context.sync();
                    
                    onboardingState.insertedValue = formulaCell.values[0][0];
                    onboardingState.accountName = nameCell.values[0][0];
                });
                
                // Update display and move to step 3
                document.getElementById('insertedFormulaDisplay').textContent = `=XAVI.BALANCE("${account}", "Jan 2025", "Jan 2025")`;
                
                const formattedValue = typeof onboardingState.insertedValue === 'number' 
                    ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(onboardingState.insertedValue)
                    : onboardingState.insertedValue || 'Loading...';
                document.getElementById('insertedResultDisplay').textContent = formattedValue;
                
                goToOnboardingStep(3);
                
                // Update contextual UI
                updateContextualUI();
                
            } catch (e) {
                console.error('Error inserting formula:', e);
                showOnboardingMessage('Error', 'Could not insert formula. Please try again.', 'warning');
            }
        }
        
        async function teachDragFill() {
            // Add 3 more accounts below using accounts with activity if available
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Use accounts from the list if available, otherwise fallback
                    let accounts = [];
                    if (onboardingState.selectedAccounts && onboardingState.selectedAccounts.length > 1) {
                        // Take different accounts from the fetched list (skip first which was already used)
                        accounts = onboardingState.selectedAccounts.slice(1, 4).map(a => a.accountnumber);
                    }
                    
                    // Fallback if we don't have enough
                    while (accounts.length < 3) {
                        const fallbacks = ['51000', '62000', '70000'];
                        accounts.push(fallbacks[accounts.length]);
                    }
                    
                    // Insert account numbers in A3:A5
                    const accountRange = sheet.getRange('A3:A5');
                    accountRange.values = accounts.map(a => [a]);
                    
                    // Also add XAVI.NAME formulas in B3:B5
                    const nameRange = sheet.getRange('B3:B5');
                    nameRange.formulas = [
                        ['=XAVI.NAME($A3)'],
                        ['=XAVI.NAME($A4)'],
                        ['=XAVI.NAME($A5)']
                    ];
                    
                    await context.sync();
                });
                
                goToOnboardingStep(4);
                
            } catch (e) {
                console.error('Error adding accounts:', e);
                goToOnboardingStep(4); // Continue anyway
            }
        }
        
        async function autoFillFormulas() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Fill BALANCE formulas in C3:C5 (first month column)
                    const formulaRange = sheet.getRange('C3:C5');
                    formulaRange.formulas = [
                        ['=XAVI.BALANCE($A3, C$1, C$1)'],
                        ['=XAVI.BALANCE($A4, C$1, C$1)'],
                        ['=XAVI.BALANCE($A5, C$1, C$1)']
                    ];
                    
                    // Format as currency
                    formulaRange.numberFormat = [['$#,##0.00'], ['$#,##0.00'], ['$#,##0.00']];
                    
                    await context.sync();
                });
                
                // Move to months step
                await new Promise(resolve => setTimeout(resolve, 1000));
                goToOnboardingStep('4b');
                updateContextualUI();
                
            } catch (e) {
                console.error('Error auto-filling rows:', e);
                goToOnboardingStep('4b');
            }
        }
        
        function setupMonthsFill() {
            goToOnboardingStep('4b');
        }
        
        async function autoFillMonths() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Fill all 12 months for all 4 accounts (rows 2-5, columns D-N)
                    // Row 2
                    const row2 = sheet.getRange('D2:N2');
                    row2.formulas = [[
                        '=XAVI.BALANCE($A2, D$1, D$1)', '=XAVI.BALANCE($A2, E$1, E$1)',
                        '=XAVI.BALANCE($A2, F$1, F$1)', '=XAVI.BALANCE($A2, G$1, G$1)',
                        '=XAVI.BALANCE($A2, H$1, H$1)', '=XAVI.BALANCE($A2, I$1, I$1)',
                        '=XAVI.BALANCE($A2, J$1, J$1)', '=XAVI.BALANCE($A2, K$1, K$1)',
                        '=XAVI.BALANCE($A2, L$1, L$1)', '=XAVI.BALANCE($A2, M$1, M$1)',
                        '=XAVI.BALANCE($A2, N$1, N$1)'
                    ]];
                    
                    // Rows 3-5
                    for (let row = 3; row <= 5; row++) {
                        const range = sheet.getRange(`D${row}:N${row}`);
                        range.formulas = [[
                            `=XAVI.BALANCE($A${row}, D$1, D$1)`, `=XAVI.BALANCE($A${row}, E$1, E$1)`,
                            `=XAVI.BALANCE($A${row}, F$1, F$1)`, `=XAVI.BALANCE($A${row}, G$1, G$1)`,
                            `=XAVI.BALANCE($A${row}, H$1, H$1)`, `=XAVI.BALANCE($A${row}, I$1, I$1)`,
                            `=XAVI.BALANCE($A${row}, J$1, J$1)`, `=XAVI.BALANCE($A${row}, K$1, K$1)`,
                            `=XAVI.BALANCE($A${row}, L$1, L$1)`, `=XAVI.BALANCE($A${row}, M$1, M$1)`,
                            `=XAVI.BALANCE($A${row}, N$1, N$1)`
                        ]];
                    }
                    
                    // Format all data as currency
                    const dataRange = sheet.getRange('C2:N5');
                    dataRange.numberFormat = '$#,##0.00';
                    
                    await context.sync();
                });
                
                // Wait for formulas to resolve
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Ensure column widths are set (autofit doesn't work reliably)
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    sheet.getRange('A:A').format.columnWidth = 75;  // Account #
                    sheet.getRange('B:B').format.columnWidth = 180; // Account Name
                    sheet.getRange('C:N').format.columnWidth = 90;  // Month columns
                    await context.sync();
                });
                
                goToOnboardingStep(5);
                updateContextualUI();
                
            } catch (e) {
                console.error('Error auto-filling months:', e);
                goToOnboardingStep(5);
            }
        }
        
        function completeDragStep() {
            goToOnboardingStep('4b');
            updateContextualUI();
        }
        
        // Validation: Check if user completed the drag-down action for accounts
        async function validateStep4AndContinue() {
            try {
                let isValid = false;
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const range = sheet.getRange('C3:C5');
                    range.load('formulas');
                    await context.sync();
                    
                    // Check if at least one cell has a BALANCE formula
                    const formulas = range.formulas;
                    isValid = formulas.some(row => row.some(cell => 
                        cell && String(cell).toUpperCase().includes('XAVI.BALANCE')
                    ));
                });
                
                if (isValid) {
                    setupMonthsFill();
                } else {
                    showOnboardingConfirm(
                        'Complete the Step?',
                        'It looks like you haven\'t dragged to fill the formulas yet. Use "Auto-Fill Rows" to complete this step, or click "Skip" to continue anyway.',
                        () => { setupMonthsFill(); }
                    );
                }
            } catch (e) {
                // On error, just proceed
                setupMonthsFill();
            }
        }
        
        // Validation: Check if user completed the drag-right action for months
        async function validateStep4bAndContinue() {
            try {
                let isValid = false;
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const range = sheet.getRange('D2:F2');  // Check first few month columns
                    range.load('formulas');
                    await context.sync();
                    
                    // Check if at least one cell has a BALANCE formula
                    const formulas = range.formulas;
                    isValid = formulas.some(row => row.some(cell => 
                        cell && String(cell).toUpperCase().includes('XAVI.BALANCE')
                    ));
                });
                
                if (isValid) {
                    goToOnboardingStep(5);
                } else {
                    showOnboardingConfirm(
                        'Complete the Step?',
                        'It looks like you haven\'t dragged to fill the months yet. Use "Auto-Fill Months" to complete this step, or click "Skip" to continue anyway.',
                        () => { goToOnboardingStep(5); }
                    );
                }
            } catch (e) {
                // On error, just proceed
                goToOnboardingStep(5);
            }
        }
        
        // Dot-matrix style celebration - writes "XAVI MASTER" in Excel cells
        async function writeXaviMasterCelebration() {
            try {
                await Excel.run(async (context) => {
                    // Use the saved tutorial sheet, not the active sheet (which might be drill-down results)
                    let sheet;
                    if (onboardingState.tutorialSheetName) {
                        sheet = context.workbook.worksheets.getItem(onboardingState.tutorialSheetName);
                    } else {
                        sheet = context.workbook.worksheets.getActiveWorksheet();
                    }
                    
                    // Fixed position at G12 - safe spot that won't conflict with tutorial data
                    const startRow = 12;
                    const startCol = 'G';
                    
                    // Dot matrix patterns for letters (5 rows x variable width)
                    const letters = {
                        'X': [
                            '   ',
                            '   ',
                            '    ',
                            '   ',
                            '   '
                        ],
                        'A': [
                            '  ',
                            '   ',
                            '',
                            '   ',
                            '   '
                        ],
                        'V': [
                            '   ',
                            '   ',
                            '   ',
                            '   ',
                            '    '
                        ],
                        'I': [
                            '',
                            '    ',
                            '    ',
                            '    ',
                            ''
                        ],
                        ' ': [
                            '  ',
                            '  ',
                            '  ',
                            '  ',
                            '  '
                        ],
                        'M': [
                            '   ',
                            ' ',
                            '  ',
                            '   ',
                            '   '
                        ],
                        'S': [
                            ' ',
                            '    ',
                            '  ',
                            '    ',
                            ' '
                        ],
                        'T': [
                            '',
                            '    ',
                            '    ',
                            '    ',
                            '    '
                        ],
                        'E': [
                            '',
                            '    ',
                            ' ',
                            '    ',
                            ''
                        ],
                        'R': [
                            ' ',
                            '   ',
                            ' ',
                            '   ',
                            '   '
                        ],
                        '!': [
                            '    ',
                            '    ',
                            '    ',
                            '     ',
                            '    '
                        ]
                    };
                    
                    // Build the text "XAVI MASTER!"
                    const text = 'XAVI MASTER!';
                    let output = ['', '', '', '', ''];
                    
                    for (const char of text) {
                        const pattern = letters[char] || letters[' '];
                        for (let row = 0; row < 5; row++) {
                            output[row] += pattern[row] + ' ';
                        }
                    }
                    
                    // Write each row to Excel as a merged cell with the dot matrix text
                    for (let row = 0; row < 5; row++) {
                        const cellRow = startRow + row;
                        const cell = sheet.getRange(`${startCol}${cellRow}`);
                        cell.values = [[output[row]]];
                        cell.format.font.name = 'Courier New';
                        cell.format.font.size = 10;
                        cell.format.font.bold = true;
                        cell.format.font.color = '#10b981';  // Green color
                    }
                    
                    // Add a congratulations message below
                    const msgCell = sheet.getRange(`${startCol}${startRow + 6}`);
                    msgCell.values = [[' Congratulations! You\'ve mastered XAVI! ']];
                    msgCell.format.font.bold = true;
                    msgCell.format.font.size = 12;
                    msgCell.format.font.color = '#09235C';  // Deep dive blue
                    
                    await context.sync();
                });
            } catch (e) {
                console.log('Could not write celebration:', e);
            }
        }
        
        async function finishOnboarding() {
            // Save completion status and timestamp
            localStorage.setItem('xavi_onboarding_completed', 'true');
            localStorage.setItem('xavi_onboarding_completed_at', new Date().toISOString());
            
            // Write the cool XAVI MASTER celebration to Excel
            await writeXaviMasterCelebration();
            
            // Switch back to the tutorial sheet so user sees the XAVI MASTER celebration
            if (onboardingState.tutorialSheetName) {
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getItem(onboardingState.tutorialSheetName);
                        sheet.activate();
                        // Select the celebration area so it's visible
                        const celebrationCell = sheet.getRange('G12');
                        celebrationCell.select();
                        await context.sync();
                    });
                } catch (e) {
                    console.log('Could not switch to tutorial sheet:', e);
                }
            }
            
            // Close the overlay properly
            const overlay = document.getElementById('onboardingOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                overlay.style.display = 'none';
            }
            
            // Update the tutorial button to show completion date
            updateTutorialCompletionDisplay();
            updateContextualUI();
        }
        
        function updateTutorialCompletionDisplay() {
            const completedAt = localStorage.getItem('xavi_onboarding_completed_at');
            if (completedAt) {
                const date = new Date(completedAt);
                const options = { 
                    month: 'short', 
                    day: 'numeric', 
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                };
                const formatted = date.toLocaleDateString('en-US', options);
                
                // Update the tutorial description
                const tutorialDesc = document.querySelector('.guide-choice[onclick="startOnboarding()"] .guide-choice-desc');
                if (tutorialDesc) {
                    tutorialDesc.innerHTML = `<span style="color: #059669;"> Completed ${formatted}</span>`;
                }
            }
        }
        
        // Sort subsidiaries hierarchically for display
        // Order: Consolidated first, then plain, then children indented
        function sortSubsidiariesHierarchically(subsidiaries) {
            if (!subsidiaries || subsidiaries.length === 0) return [];
            
            // Separate consolidated and non-consolidated entries
            const nonConsolidated = subsidiaries.filter(s => !s.isConsolidated);
            const consolidated = subsidiaries.filter(s => s.isConsolidated);
            
            // Build a map of id  non-consolidated subsidiary
            const subMap = new Map();
            nonConsolidated.forEach(s => subMap.set(s.id, s));
            
            // Build a map of id  consolidated subsidiary
            const consolidatedMap = new Map();
            consolidated.forEach(s => consolidatedMap.set(s.id, s));
            
            // Build children map: parent_id  [child_ids]
            const childrenOf = new Map();
            nonConsolidated.forEach(s => {
                if (s.parent) {
                    if (!childrenOf.has(s.parent)) {
                        childrenOf.set(s.parent, []);
                    }
                    childrenOf.get(s.parent).push(s.id);
                }
            });
            
            // Find root subsidiaries (no parent)
            const roots = nonConsolidated.filter(s => !s.parent);
            
            // Recursively build sorted list
            const result = [];
            const visited = new Set();
            
            function addSubtree(subId, depth) {
                if (visited.has(subId)) return;
                visited.add(subId);
                
                const sub = subMap.get(subId);
                if (!sub) return;
                
                const isParent = childrenOf.has(subId);
                const consolidatedVersion = consolidatedMap.get(subId);
                
                // For parents: add "(Consolidated)" FIRST, then plain version
                if (isParent && consolidatedVersion) {
                    result.push({ ...consolidatedVersion, depth });
                }
                
                // Add the plain version
                result.push({ ...sub, depth });
                
                // Add children (sorted alphabetically)
                if (isParent) {
                    const childIds = childrenOf.get(subId);
                    const children = childIds
                        .map(id => subMap.get(id))
                        .filter(Boolean)
                        .sort((a, b) => a.name.localeCompare(b.name));
                    
                    children.forEach(child => addSubtree(child.id, depth + 1));
                }
            }
            
            // Sort roots alphabetically and build tree
            roots.sort((a, b) => a.name.localeCompare(b.name));
            roots.forEach(root => addSubtree(root.id, 0));
            
            return result;
        }
        
        // ========================================================================
        // VERSION - Read from manifest URL parameter (?v=x.x.x.x)
        // ========================================================================
        const urlParams = new URLSearchParams(window.location.search);
        const ADDIN_VERSION = urlParams.get('v') || '0.0.0.0';
        
        // ============================================
        // REFRESH CANCELLATION
        // ============================================
        let refreshCancelled = false;
        
        function cancelRefresh() {
            refreshCancelled = true;
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.disabled = true;
                cancelBtn.textContent = 'Cancelling...';
            }
            updateLoading('Cancelling...', null, 
                'Stopping after current operation completes. Any queries already sent to NetSuite will finish.');
            console.log(' Refresh cancelled by user');
        }
        
        function showCancelButton() {
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'block';
                cancelBtn.disabled = false;
                cancelBtn.textContent = ' Cancel Refresh';
            }
        }
        
        function hideCancelButton() {
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'none';
            }
        }
        
        // ============================================
        // FLOATING STATUS WIDGET (for special formulas)
        // ============================================
        function showFloatingStatus(message, detail, progress = 0) {
            const widget = document.getElementById('floatingStatus');
            const msgEl = document.getElementById('floatingStatusMessage');
            const detailEl = document.getElementById('floatingStatusDetail');
            const progressBar = document.getElementById('floatingStatusProgressBar');
            
            if (widget) {
                widget.style.display = 'block';
                if (msgEl) msgEl.textContent = message;
                if (detailEl) detailEl.innerHTML = detail;
                if (progressBar) progressBar.style.width = `${progress}%`;
            }
        }
        
        function updateFloatingStatus(message, detail, progress) {
            const msgEl = document.getElementById('floatingStatusMessage');
            const detailEl = document.getElementById('floatingStatusDetail');
            const progressBar = document.getElementById('floatingStatusProgressBar');
            
            if (msgEl && message) msgEl.textContent = message;
            if (detailEl && detail) detailEl.innerHTML = detail;
            if (progressBar && progress !== undefined) progressBar.style.width = `${progress}%`;
        }
        
        function hideFloatingStatus() {
            const widget = document.getElementById('floatingStatus');
            if (widget) {
                widget.style.display = 'none';
            }
        }
        
        // ============================================
        // Set version in all UI elements
        function initializeVersion() {
            const versionBadge = document.getElementById('versionBadge');
            const settingsVersion = document.getElementById('settingsVersion');
            const footerVersion = document.getElementById('footerVersion');
            if (versionBadge) versionBadge.textContent = 'v' + ADDIN_VERSION;
            if (settingsVersion) settingsVersion.textContent = ADDIN_VERSION;
            if (footerVersion) footerVersion.textContent = ADDIN_VERSION;
        }

        // ========================================================================
        // CONNECTION STATUS - Check if backend/tunnel is reachable
        // ========================================================================
        let lastConnectionCheck = null;
        let connectionCheckInterval = null;
        
        async function checkConnectionStatus(silent = false) {
            const statusBadge = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');
            
            if (!statusBadge || !statusText) return false;
            
            // Show checking state
            statusBadge.className = 'status-badge checking';
            statusText.textContent = 'Checking...';
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(`${SERVER_URL}/health`, {
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    statusBadge.className = 'status-badge connected';
                    statusText.textContent = `Connected (${data.account || 'NetSuite'})`;
                    lastConnectionCheck = { status: 'connected', time: Date.now() };
                    if (!silent) {
                        showToast({ type: 'success', title: 'Connection OK', message: 'Backend and tunnel are working.', duration: 3000 });
                    }
                    return true;
                } else if (response.status === 502 || response.status === 524 || response.status === 522 || response.status === 530) {
                    // Tunnel/proxy error - show detailed diagnosis
                    statusBadge.className = 'status-badge disconnected';
                    
                    let errorTitle = 'Tunnel Disconnected';
                    let errorMsg = '';
                    
                    if (response.status === 530 || response.status === 522) {
                        // 530 = Origin DNS error, 522 = Connection timed out
                        statusText.textContent = 'Tunnel Expired';
                        errorTitle = ' Tunnel Expired';
                        errorMsg = `Error ${response.status}: The Cloudflare tunnel has expired and needs to be restarted.\n\n` +
                            `To fix:\n` +
                            `1. Run: cloudflared tunnel --url http://localhost:5002\n` +
                            `2. Copy the new trycloudflare.com URL\n` +
                            `3. Update the Worker at dash.cloudflare.com`;
                    } else if (response.status === 502) {
                        // 502 = Bad Gateway - server might be down
                        statusText.textContent = 'Server Down';
                        errorTitle = ' Server Not Responding';
                        errorMsg = `Error 502: The backend server may not be running.\n\n` +
                            `To fix:\n` +
                            `1. Check if server.py is running on port 5002\n` +
                            `2. Run: cd backend && python3 server.py`;
                    } else {
                        // 524 = Timeout
                        statusText.textContent = 'Tunnel Timeout';
                        errorTitle = ' Connection Timeout';
                        errorMsg = `Error ${response.status}: The tunnel connection timed out.\n\n` +
                            `The server may be overloaded or the tunnel may need restarting.`;
                    }
                    
                    lastConnectionCheck = { status: 'disconnected', time: Date.now(), error: `HTTP ${response.status}` };
                    if (!silent) {
                        showToast({ type: 'error', title: errorTitle, message: errorMsg, duration: 15000 });
                    }
                    return false;
                } else {
                    statusBadge.className = 'status-badge disconnected';
                    statusText.textContent = `Error (${response.status})`;
                    lastConnectionCheck = { status: 'error', time: Date.now(), error: `HTTP ${response.status}` };
                    return false;
                }
            } catch (error) {
                statusBadge.className = 'status-badge disconnected';
                if (error.name === 'AbortError') {
                    statusText.textContent = 'Timeout';
                    lastConnectionCheck = { status: 'timeout', time: Date.now() };
                    if (!silent) {
                        showToast({ type: 'error', title: 'Connection Timeout', 
                            message: 'Could not reach the backend. The tunnel may have expired.', duration: 8000 });
                    }
                } else {
                    statusText.textContent = 'Disconnected';
                    lastConnectionCheck = { status: 'disconnected', time: Date.now(), error: error.message };
                    if (!silent) {
                        showToast({ type: 'error', title: 'Connection Failed', 
                            message: `Could not connect: ${error.message}`, duration: 8000 });
                    }
                }
                return false;
            }
        }
        
        // Start periodic connection checks (every 60 seconds)
        function startConnectionMonitor() {
            // Initial check (silent)
            checkConnectionStatus(true);
            
            // Periodic checks every 60 seconds
            connectionCheckInterval = setInterval(() => {
                checkConnectionStatus(true);
            }, 60000);
        }
        
        // Stop connection monitor when page unloads
        window.addEventListener('beforeunload', () => {
            if (connectionCheckInterval) {
                clearInterval(connectionCheckInterval);
            }
        });

        // ========================================================================
        // STATUS BAR - Persistent Progress Messages
        // ========================================================================
        function showStatus(message, icon = '', progress = 0, type = '') {
            const bar = document.getElementById('statusBar');
            const textEl = document.getElementById('statusText');
            const iconEl = document.getElementById('statusIcon');
            const progressEl = document.getElementById('statusProgress');
            
            bar.className = 'status-overlay' + (type ? ' ' + type : '');
            bar.style.display = 'flex';
            textEl.textContent = message;
            iconEl.textContent = icon;
            progressEl.style.width = progress + '%';
        }
        
        function hideStatus(delay = 0) {
            setTimeout(() => {
                document.getElementById('statusBar').style.display = 'none';
            }, delay);
        }
        
        function showStatusSuccess(message) {
            showStatus(message, '', 100, 'success');
            hideStatus(3000);
        }
        
        function showStatusError(message) {
            showStatus(message, '', 100, 'error');
            hideStatus(5000);
        }
        
        // Poll for status updates from custom functions (via localStorage)
        // NOTE: Polling is started in Office.onReady to avoid showing stale statuses
        let lastStatusTimestamp = 0;
        let taskpaneReady = false;  // Flag to prevent polling before init cleanup
        
        function startStatusPolling() {
            // Set the initial timestamp to "now" so we ignore any stale statuses
            // Only show statuses that are created AFTER the taskpane loads
            lastStatusTimestamp = Date.now();
            taskpaneReady = true;
            
            // Clear any stale status from localStorage on taskpane load
            localStorage.removeItem('netsuite_status');
            
        setInterval(async () => {
                if (!taskpaneReady) return;  // Don't poll until ready
                
                // Don't show statusBar if suppressed (during report generation)
                if (suppressStatusBar) return;
                
            try {
                const statusJson = localStorage.getItem('netsuite_status');
                if (statusJson) {
                    const status = JSON.parse(statusJson);
                        // Only show if timestamp is newer than when taskpane loaded
                    if (status.timestamp > lastStatusTimestamp) {
                        // Check if current sheet has any XAVI formulas before showing status
                        // This prevents showing status from other workbooks
                        if (contextualState && contextualState.formulaCount === 0) {
                            // Skip showing status on empty sheets
                            return;
                        }
                        
                        lastStatusTimestamp = status.timestamp;
                        const icon = status.type === 'success' ? '' : 
                                     status.type === 'error' ? '' : '';
                        showStatus(status.message, icon, status.progress, status.type);
                        
                        // Auto-hide success/error after delay
                        if (status.type === 'success' || status.type === 'error') {
                            hideStatus(3000);
                        }
                    }
                }
            } catch (e) {
                // Ignore parsing errors
            }
        }, 500);  // Check every 500ms
        }
        
        // ========================================================================
        // NOTE: With ShowTaskpane approach (v3.0.5.187+), we no longer need localStorage polling.
        // The taskpane is opened directly with ?action=drilldown and handles it in Office.onReady.
        // This avoids the Mac "Developer Window" bug that occurred with ExecuteFunction.
        
        async function processDrilldownRequest(request) {
            const { formula, sheetName, address } = request;
            const upperFormula = String(formula || '').toUpperCase();
            
            try {
                // Handle XAVI.BALANCE
                if (upperFormula.includes('XAVI.BALANCE')) {
                    showDrilldownStatus('Parsing formula parameters...');
                    const match = formula.match(/XAVI\.BALANCE\s*\((.*)\)/i);
                    if (!match) { hideDrilldownStatus(); return; }
                    
                    const params = parseFormulaCellRefs(match[1]);
                    const resolved = await resolveFormulaParams(params);
                    
                    showDrilldownStatus('Fetching transactions from NetSuite...');
                    const account = resolved[0] || '';
                    const period = resolved[2] || resolved[1] || '';
                    const subsidiary = resolved[3] || '';
                    
                    const qp = new URLSearchParams({ account, period });
                    if (subsidiary) qp.append('subsidiary', subsidiary);
                    
                    const resp = await fetch(`${SERVER_URL}/transactions?${qp}`);
                    if (resp.ok) {
                        const data = await resp.json();
                        showDrilldownStatus(`Creating sheet with ${data.transactions?.length || 0} transactions...`);
                        await drillDownTransactions(account, period, subsidiary);
                    }
                    hideDrilldownStatus();
                    return;
                }
                
                // Handle XAVI.TYPEBALANCE
                if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                    showDrilldownStatus('Parsing TYPEBALANCE formula...');
                    const match = formula.match(/XAVI\.TYPEBALANCE\s*\((.*)\)/i);
                    if (!match) { hideDrilldownStatus(); return; }
                    
                    const params = parseTypeBalanceParams(match[1]);
                    const resolved = await resolveTypeBalanceParams(params);
                    
                    showDrilldownStatus('Fetching accounts by type from NetSuite...');
                    await handleTypeBalanceDrillDown(resolved);
                    hideDrilldownStatus();
                    return;
                }
                
                // Handle secondary drill-down from DrillDown_ sheet
                if (sheetName && sheetName.startsWith('DrillDown_')) {
                    showDrilldownStatus('Preparing secondary drill-down...');
                    
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const rowMatch = address.match(/(\d+)(?:\D*)?$/);
                        const row = rowMatch ? parseInt(rowMatch[1]) : 0;
                        
                        if (row >= 6) {
                            const acctCell = sheet.getRange(`A${row}`);
                            const ctxCell = sheet.getRange('A3');
                            acctCell.load('values');
                            ctxCell.load('values');
                            await context.sync();
                            
                            const account = String(acctCell.values[0][0] || '');
                            const ctx = String(ctxCell.values[0][0] || '');
                            
                            if (account && ctx.startsWith('DRILLDOWN_CONTEXT:')) {
                                const parts = ctx.replace('DRILLDOWN_CONTEXT:', '').split(':');
                                const period = parts[0] || '';
                                const subsidiary = parts[1] || '';
                                
                                showDrilldownStatus(`Fetching transactions for ${account}...`);
                                await drillDownTransactions(account, period, subsidiary);
                            }
                        }
                    });
                    
                    hideDrilldownStatus();
                    return;
                }
                
                console.log('No drilldown action for this cell');
                
            } catch (err) {
                console.error('processDrilldownRequest error:', err);
                hideDrilldownStatus();
            }
        }

        // Poll for toast notifications from custom functions (via localStorage)
        let lastToastTimestamp = 0;
        let lastToastUpdateTimestamp = 0;
        let lastToastRemoveTimestamp = 0;
        let lastBsPreloadSuggestionTimestamp = 0;
        const broadcastToastMap = new Map(); // Maps broadcast toast IDs to local toast IDs
        
        setInterval(() => {
            try {
                // Check for new toasts
                const toastJson = localStorage.getItem('netsuite_toast');
                if (toastJson) {
                    const toast = JSON.parse(toastJson);
                    if (toast.timestamp > lastToastTimestamp) {
                        lastToastTimestamp = toast.timestamp;
                        // Create local toast and map the ID
                        const localId = showToast({
                            title: toast.title,
                            message: toast.message,
                            type: toast.type,
                            duration: toast.duration
                        });
                        broadcastToastMap.set(toast.id, localId);
                        localStorage.removeItem('netsuite_toast');
                    }
                }
                
                // Check for toast updates
                const updateJson = localStorage.getItem('netsuite_toast_update');
                if (updateJson) {
                    const update = JSON.parse(updateJson);
                    if (update.timestamp > lastToastUpdateTimestamp) {
                        lastToastUpdateTimestamp = update.timestamp;
                        const localId = broadcastToastMap.get(update.id);
                        if (localId) {
                            updateToast(localId, {
                                title: update.title,
                                message: update.message,
                                type: update.type
                            });
                        }
                        localStorage.removeItem('netsuite_toast_update');
                    }
                }
                
                // Check for toast removals
                const removeJson = localStorage.getItem('netsuite_toast_remove');
                if (removeJson) {
                    const remove = JSON.parse(removeJson);
                    if (remove.timestamp > lastToastRemoveTimestamp) {
                        lastToastRemoveTimestamp = remove.timestamp;
                        const localId = broadcastToastMap.get(remove.id);
                        if (localId) {
                            removeToast(localId);
                            broadcastToastMap.delete(remove.id);
                        }
                        localStorage.removeItem('netsuite_toast_remove');
                    }
                }
                
                // ================================================================
                // BS PRELOAD SUGGESTION - Auto-suggest when BS queries are slow
                // Shows a persistent toast with action button to trigger preload
                // ================================================================
                const bsSuggestionJson = localStorage.getItem('netsuite_bs_preload_suggestion');
                if (bsSuggestionJson) {
                    const suggestion = JSON.parse(bsSuggestionJson);
                    if (suggestion.timestamp > lastBsPreloadSuggestionTimestamp) {
                        lastBsPreloadSuggestionTimestamp = suggestion.timestamp;
                        localStorage.removeItem('netsuite_bs_preload_suggestion');
                        
                        console.log(' BS Preload Suggestion received:', suggestion);
                        
                        // Pre-fill the period inputs if we have suggested periods
                        if (suggestion.periods && suggestion.periods.length > 0) {
                            const period1Input = document.getElementById('bsPreloadPeriod1');
                            const period2Input = document.getElementById('bsPreloadPeriod2');
                            if (period1Input) period1Input.value = suggestion.periods[0];
                            if (period2Input && suggestion.periods.length > 1) {
                                period2Input.value = suggestion.periods[1];
                            }
                        }
                        
                        // Show a persistent actionable toast
                        showToast({
                            title: ' Speed Up Balance Sheet Lookups!',
                            message: `<div style="line-height: 1.5;">
                                <p style="margin-bottom: 8px;">Your query took <strong>${(suggestion.queryTimeMs / 1000).toFixed(0)} seconds</strong>.</p>
                                <p style="margin-bottom: 12px; font-size: 12px;">Preload ALL BS accounts now for <strong>instant</strong> future lookups!</p>
                                <button onclick="preloadBalanceSheet(); removeToast(this.closest('.toast').dataset.toastId);" 
                                        style="background: #3B82F6; color: white; border: none; padding: 8px 16px; 
                                               border-radius: 6px; cursor: pointer; font-size: 13px; width: 100%;">
                                     Preload Now (${suggestion.periods?.length > 1 ? suggestion.periods.length + ' periods' : '~70s'})
                                </button>
                            </div>`,
                            type: 'warning',
                            duration: 30000,  // 30 seconds - long enough to act
                            icon: ''
                        });
                    }
                }
                
                // ================================================================
                // BS BUILD MODE WARNING - Shown when multiple BS formulas queued
                // More prominent than the slow-query suggestion
                // ================================================================
                const bsBuildModeJson = localStorage.getItem('netsuite_bs_buildmode_warning');
                if (bsBuildModeJson) {
                    const warning = JSON.parse(bsBuildModeJson);
                    localStorage.removeItem('netsuite_bs_buildmode_warning');
                    
                    console.log(' BS Build Mode Warning received:', warning);
                    
                    // Pre-fill the period inputs
                    if (warning.periods && warning.periods.length > 0) {
                        const period1Input = document.getElementById('bsPreloadPeriod1');
                        const period2Input = document.getElementById('bsPreloadPeriod2');
                        if (period1Input) period1Input.value = warning.periods[0];
                        if (period2Input && warning.periods.length > 1) {
                            period2Input.value = warning.periods[1];
                        }
                    }
                    
                    // Show prominent modal-style alert
                    showOnboardingMessage(
                        ' Multiple Balance Sheet Formulas Detected',
                        `<div style="text-align: left;">
                            <p style="margin-bottom: 12px; color: #B45309; font-weight: 500;">
                                You're adding <strong>${warning.bsCount} Balance Sheet formulas</strong>.
                            </p>
                            <p style="margin-bottom: 12px;">
                                <strong>Without preloading:</strong> Each formula takes 60-90 seconds individually.<br>
                                <span style="color: #DC2626;">Total wait: ${warning.bsCount * 60}+ seconds! </span>
                            </p>
                            <p style="margin-bottom: 16px;">
                                <strong>With Smart Preload:</strong> Load all accounts once in ~30 seconds.<br>
                                <span style="color: #059669;">Then every formula is instant! </span>
                            </p>
                            <div style="display: flex; gap: 12px; margin-top: 16px;">
                                <button onclick="smartPreloadFromSheet(); hideOnboarding();" 
                                        style="flex: 1; background: linear-gradient(135deg, #10B981, #059669); color: white; 
                                               border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; 
                                               font-size: 14px; font-weight: 500;">
                                     Smart Preload (Recommended)
                                </button>
                                <button onclick="hideOnboarding();" 
                                        style="flex: 0 0 auto; background: #E5E7EB; color: #374151; 
                                               border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; 
                                               font-size: 14px;">
                                    Continue Anyway
                                </button>
                            </div>
                            <p style="margin-top: 12px; font-size: 11px; color: #6B7280;">
                                 Tip: Smart Preload scans your sheet and only loads the BS accounts you're using.
                            </p>
                        </div>`,
                        'warning'
                    );
                }
                
            } catch (e) {
                // Ignore parsing errors
            }
        }, 300);  // Check every 300ms for responsive toasts

        // ========================================================================
        // LOADING OVERLAY - Modern Progress Indicator
        // ========================================================================
        // Fun facts about finance teams and Excel - shown during loading
        const financeFunFacts = [
            { icon: '', text: '<strong>89% of finance teams</strong> still rely on Excel as their primary analysis tool, even with ERP systems in place.' },
            { icon: '', text: '<strong>Finance professionals spend 20+ hours/month</strong> on manual data entry and report formatting in Excel.' },
            { icon: '', text: '<strong>750 million people</strong> worldwide use Excel  more than the population of Europe!' },
            { icon: '', text: '<strong>CFOs cite Excel errors</strong> as a top concern  the average spreadsheet has a 1-2% formula error rate.' },
            { icon: '', text: '<strong>Excel was born in 1985</strong>  40 years later, it\'s still the #1 tool for financial modeling.' },
            { icon: '', text: '<strong>Power users create 50+ formulas</strong> per sheet. Your NetSuite integration just made that 10x faster!' },
            { icon: '', text: '<strong>Finance teams refresh reports 15+ times/month</strong> on average. Automation saves 100+ hours yearly.' },
            { icon: '', text: '<strong>VLOOKUP is the most-used function</strong> in finance, followed by SUM and IF. But XAVI.BALANCE beats them all!' },
            { icon: '', text: '<strong>JPMorgan alone</strong> has over 200,000 Excel spreadsheets used for risk management and trading.' },
            { icon: '', text: '<strong>Excel Online launched in 2010</strong>  the first time you could edit spreadsheets in a browser!' },
            { icon: '', text: '<strong>A single Excel file</strong> can have 17 billion cells. That\'s more data points than stars in the Milky Way visible to the naked eye!' },
            { icon: '', text: '<strong>88% of spreadsheets contain errors</strong> according to research. Real-time NetSuite data reduces manual entry mistakes.' },
            { icon: '', text: '<strong>The average company</strong> has 1,000+ spreadsheets. CloudExtend helps keep them all in sync with NetSuite.' },
            { icon: '', text: '<strong>Before Excel, VisiCalc ruled</strong>  it was the "killer app" that made personal computers essential for business.' },
            { icon: '', text: '<strong>Excel 2007 expanded to 1 million rows</strong>  finance teams everywhere celebrated the end of "row limit" errors!' }
        ];
        
        let funFactInterval = null;
        
        function showLoading(title, message, progress = 0) {
            const overlay = document.getElementById('loadingOverlay');
            const titleEl = document.getElementById('loadingTitle');
            const messageEl = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('loadingProgressBar');
            const statsEl = document.getElementById('loadingStats');
            const funfactEl = document.getElementById('funfactText');
            
            titleEl.textContent = title || 'Processing...';
            messageEl.textContent = message || 'Please wait';
            progressBar.style.width = progress + '%';
            statsEl.textContent = '';
            
            // Show initial fun fact
            showRandomFunFact();
            
            // Rotate fun facts every 6 seconds
            if (funFactInterval) clearInterval(funFactInterval);
            funFactInterval = setInterval(showRandomFunFact, 6000);
            
            overlay.classList.add('active');
        }
        
        function showRandomFunFact() {
            const funfactEl = document.getElementById('funfactText');
            const iconEl = document.querySelector('.funfact-icon');
            if (!funfactEl) return;
            
            const fact = financeFunFacts[Math.floor(Math.random() * financeFunFacts.length)];
            funfactEl.innerHTML = fact.text;
            if (iconEl) iconEl.textContent = fact.icon;
        }

        function updateLoading(message, progress, stats) {
            const messageEl = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('loadingProgressBar');
            const statsEl = document.getElementById('loadingStats');
            
            if (message) messageEl.textContent = message;
            if (progress !== undefined) progressBar.style.width = progress + '%';
            if (stats) statsEl.textContent = stats;
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
            
            // Clear fun fact rotation
            if (funFactInterval) {
                clearInterval(funFactInterval);
                funFactInterval = null;
            }
        }

        // ========================================================================
        // TOAST NOTIFICATION SYSTEM
        // ========================================================================
        let toastCounter = 0;
        
        /**
         * Show a toast notification
         * @param {object} options - Toast options
         * @param {string} options.title - Toast title
         * @param {string} options.message - Toast message (can include HTML)
         * @param {string} options.type - Toast type: 'info', 'success', 'warning', 'error', 'calculating'
         * @param {number} options.duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
         * @param {string} options.icon - Custom icon (emoji)
         * @returns {string} Toast ID for manual removal
         */
        function showToast({ title, message, type = 'info', duration = 5000, icon }) {
            const container = document.getElementById('toastContainer');
            const toastId = `toast-${++toastCounter}`;
            
            // Default icons by type
            const defaultIcons = {
                info: '',
                success: '',
                warning: '',
                error: '',
                calculating: '' // Will use spinner
            };
            
            const displayIcon = icon || defaultIcons[type] || '';
            const iconHtml = type === 'calculating' 
                ? '<div class="toast-spinner"></div>' 
                : `<span class="toast-icon">${displayIcon}</span>`;
            
            const toast = document.createElement('div');
            toast.id = toastId;
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                ${iconHtml}
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="removeToast('${toastId}')">&times;</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-dismiss after duration (if set)
            if (duration > 0) {
                setTimeout(() => removeToast(toastId), duration);
            }
            
            return toastId;
        }
        
        function removeToast(toastId) {
            const toast = document.getElementById(toastId);
            if (toast) {
                toast.classList.add('removing');
                setTimeout(() => toast.remove(), 300);
            }
        }
        
        /**
         * Show a persistent error that requires user acknowledgment.
         * Unlike regular toasts, these don't auto-dismiss.
         * @param {string} title - Error title
         * @param {string} message - Error details
         * @param {string} [details] - Optional technical details (shown in smaller text)
         */
        function showPersistentError(title, message, details = null) {
            const container = document.getElementById('toastContainer');
            const toastId = `toast-${++toastCounter}`;
            
            let fullMessage = message;
            if (details) {
                fullMessage += `<div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; font-size: 11px; font-family: monospace; max-height: 100px; overflow-y: auto;">${details}</div>`;
            }
            fullMessage += '<div style="margin-top: 8px; font-size: 11px; color: #6b7280;">Click  to dismiss this message</div>';
            
            const toast = document.createElement('div');
            toast.id = toastId;
            toast.className = 'toast error persistent-error';
            toast.innerHTML = `
                <span class="toast-icon"></span>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${fullMessage}</div>
                </div>
                <button class="toast-close" onclick="removeToast('${toastId}')">&times;</button>
            `;
            
            container.appendChild(toast);
            
            // Persistent - no auto-dismiss (duration = 0)
            return toastId;
        }
        
        // Clear ALL toasts from the container
        function hideToast() {
            const container = document.getElementById('toastContainer');
            if (container) {
                const toasts = container.querySelectorAll('.toast');
                toasts.forEach(toast => {
                    toast.classList.add('removing');
                    setTimeout(() => toast.remove(), 300);
                });
            }
        }
        
        function updateToast(toastId, { title, message, type }) {
            const toast = document.getElementById(toastId);
            if (toast) {
                if (title) toast.querySelector('.toast-title').textContent = title;
                if (message) toast.querySelector('.toast-message').innerHTML = message;
                if (type) {
                    toast.className = `toast ${type}`;
                    // Update icon for non-calculating types
                    if (type !== 'calculating') {
                        const iconSpan = toast.querySelector('.toast-icon');
                        const spinner = toast.querySelector('.toast-spinner');
                        if (spinner) {
                            spinner.outerHTML = `<span class="toast-icon">${type === 'success' ? '' : type === 'error' ? '' : ''}</span>`;
                        }
                    }
                }
            }
        }
        
        // Make toast functions globally accessible for functions.js
        window.showToast = showToast;
        window.removeToast = removeToast;
        window.updateToast = updateToast;
        window.hideToast = hideToast;

        // ========================================================================
        // SETTINGS VIEW (inline, not modal)
        // ========================================================================
        function openSettings() {
            // Move settings content into the inline container
            const settingsContent = document.getElementById('settingsView');
            const settingsInline = document.getElementById('settingsViewInline');
            const mainView = document.getElementById('mainView');
            
            // Move settings panel content to inline view
            if (settingsContent && settingsInline) {
                settingsInline.innerHTML = settingsContent.innerHTML;
            }
            
            // Hide main, show settings
            mainView.classList.add('hidden');
            settingsInline.classList.add('active');
            
            // Rebind button handlers in the inline view (onclick attrs don't transfer)
            const backBtn = settingsInline.querySelector('.settings-back');
            if (backBtn) {
                backBtn.onclick = closeSettings;
            }
            
            const checkPermissionsBtn = settingsInline.querySelector('#checkPermissionsBtn');
            if (checkPermissionsBtn) {
                checkPermissionsBtn.onclick = checkNetSuitePermissions;
            }
            
            const refreshBtn = settingsInline.querySelector('.settings-btn-action[onclick*="checkServerStatus"]');
            const refreshBtnAlt = settingsInline.querySelectorAll('.settings-btn-action');
            refreshBtnAlt.forEach(btn => {
                if (btn.textContent.includes('Refresh')) {
                    btn.onclick = checkServerStatus;
                }
                if (btn.textContent.includes('Reload Lookups')) {
                    btn.onclick = reloadLookups;
                }
            });
            
            checkServerStatus();
            checkTunnelStatus();
            checkCacheStatus();
        }

        function closeSettings() {
            const settingsInline = document.getElementById('settingsViewInline');
            const mainView = document.getElementById('mainView');
            
            // Hide settings, show main
            settingsInline.classList.remove('active');
            mainView.classList.remove('hidden');
        }

        // ================================================================
        // GUIDE ME WIZARD - Build starter financial report
        // ================================================================
        
        function dismissGuideMe() {
            document.getElementById('guideMeCard').classList.add('guide-me-hidden');
            localStorage.setItem('guideMeDismissed', 'true');
        }

        function showGuideMe() {
            // Only show if not previously dismissed
            if (localStorage.getItem('guideMeDismissed') !== 'true') {
                document.getElementById('guideMeCard').classList.remove('guide-me-hidden');
            }
        }

        async function runGuideMe() {
            const startTime = Date.now(); // Track timing
            // Note: Button may not have an ID (called via onclick on div)
            const btn = document.getElementById('guideMeBtn');
            const progress = document.getElementById('guideMeProgress');
            const currentYear = new Date().getFullYear();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // CRITICAL: Clear all caches to prevent stale account type data
            // This ensures XAVI.TYPE formulas fetch fresh data from NetSuite
            try {
                if (typeof window.clearAllCaches === 'function') {
                    window.clearAllCaches();
                    console.log('Guide Me: Caches cleared');
                }
                // Also clear localStorage cache
                localStorage.removeItem('netsuite_balance_cache');
                localStorage.removeItem('netsuite_balance_cache_timestamp');
            } catch (e) {
                console.warn('Guide Me: Cache clear warning:', e.message);
            }
            
            // Excel tips, history, and financial formulas interspersed
            const excelTips = [
                // Financial formulas
                '=SUMIF(range, criteria, sum_range)  Sum by condition',
                ' VisiCalc (1979) was the first spreadsheetit made the Apple II a business tool',
                '=SUMIFS(sum_range, range1, criteria1, range2, criteria2)',
                ' Lotus 1-2-3 dominated the 1980s and made "/" the menu key',
                '=VLOOKUP(value, table, col, FALSE)  Exact match lookup',
                ' Excel launched in 1985 for MacWindows version came in 1987',
                '=INDEX(array, MATCH(value, range, 0))  Flexible lookup',
                ' The $ anchor (like $A$1) dates back to VisiCalc in 1979',
                '=IFERROR(formula, 0)  Handle #DIV/0! errors',
                ' Excel\'s 1,048,576 rows limit was set in Excel 2007 (was 65,536 before)',
                '=SUMPRODUCT((A:A="Revenue")*(B:B))  Sum with multiple criteria',
                ' The name "Excel" was a play on "electronic spreadsheet" excellence',
                '=EOMONTH(date, 0)  Last day of month',
                ' Named ranges make formulas self-documenting and easier to audit',
                '=EOMONTH(date, -1)+1  First day of month',
                ' Dan Bricklin invented VisiCalc after watching a professor erase a blackboard',
                '=TEXT(date, "mmmm yyyy")  Format dates',
                ' Use Ctrl+` to toggle formula view for auditing',
                '=ROUND(value, -3)  Round to nearest thousand',
                ' Excel was not Microsoft\'s first spreadsheetMultiplan (1982) was',
                '=ABS(value)  Absolute value for variances',
                ' Tables (Ctrl+T) auto-expand formulas to new rows',
                '=IF(actual>budget, "Over", "Under")  Budget variance',
                ' The first Excel easter egg was a flight simulator (Excel 97)',
                '=(current-prior)/ABS(prior)  % change formula',
                ' F4 cycles through A1  $A$1  A$1  $A1  A1',
                '=AVERAGEIF(range, ">0")  Average positive values',
                ' Over 750 million people use Excel worldwide today',
                '=COUNTIF(range, "<0")  Count negative variances',
                ' Alt+= is the fastest way to insert a SUM formula',
                '=MAX(range)-MIN(range)  Range/spread analysis',
                ' The @ symbol in Excel formulas was introduced for implicit intersection',
                '=RANK(value, range, 0)  Rank accounts by size',
                // Keyboard shortcuts with history
                'Ctrl+D  Fill down from cell above',
                ' Ctrl+C/V for copy/paste was invented by Larry Tesler at Apple',
                'Ctrl+R  Fill right from cell left',
                ' Double-click fill handle to auto-fill down to adjacent data',
                'Ctrl+Shift+L  Toggle filters',
                ' Pivot Tables were invented by Lotus in 1991 (called "Improv")',
                'Ctrl+`  Show/hide formulas',
                ' Ctrl+[ jumps to cells referenced by current formula',
                'F4  Toggle absolute refs ($A$1)',
                ' Excel formulas are processed left-to-right, but PEMDAS still applies',
                'Alt+=  Auto-sum selected range',
                ' Conditional formatting can highlight variances automatically',
                'Ctrl+;  Insert today\'s date',
                ' The "ribbon" interface was introduced in Office 2007',
                'Ctrl+Shift+$  Currency format',
                ' Data Validation creates dropdown lists for cleaner input',
                'Ctrl+Shift+%  Percentage format',
                ' Excel Online was launched in 2010 as "Excel Web App"'
            ];
            let tipIndex = 0;
            
            // Create and show loading overlay with progress bar
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'guideMeOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building Your Sample Report</h2>
                <div class="loading-subtitle">
                     First run takes up to 2 minutes to load and cache data
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="guideMeProgressBar"></div>
                    </div>
                    <div class="progress-text" id="guideMeProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="guideMeStep">Connecting to NetSuite...</div>
                <div class="loading-step-desc" id="guideMeStepDesc">Establishing secure connection</div>
                
                <div class="tips-section">
                    <div class="tips-label">Excel Tips & History</div>
                    <div class="loading-tip" id="guideMeTip">${excelTips[0]}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Rotate tips every 2.5 seconds
            const tipInterval = setInterval(() => {
                tipIndex = (tipIndex + 1) % excelTips.length;
                const tipEl = document.getElementById('guideMeTip');
                if (tipEl) {
                    tipEl.style.opacity = '0';
                    setTimeout(() => {
                        tipEl.innerHTML = '';  // Clear completely
                        tipEl.textContent = excelTips[tipIndex];
                        tipEl.style.opacity = '1';
                    }, 300);
                }
            }, 2500);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('guideMeProgressBar');
                const text = document.getElementById('guideMeProgressText');
                const stepEl = document.getElementById('guideMeStep');
                const descEl = document.getElementById('guideMeStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            if (btn) btn.disabled = true;
            
            try {
                // Step 1: Fetch ALL account data via full_year_refresh (preloads cache!)
                // This is the longest step - use artificial progress to keep user informed
                updateProgress(5, ' Step 1 of 4: Sampling Accounts', 
                    "We're sampling your accounts so we can return only accounts that have data for the year. This is a one-time step that takes some time...");
                
                // Start artificial progress increment during the long fetch
                let artificialProgress = 5;
                const progressInterval = setInterval(() => {
                    if (artificialProgress < 38) {
                        artificialProgress += 3;
                        updateProgress(artificialProgress, ' Step 1 of 4: Sampling Accounts', 
                            "Querying NetSuite for all account balances across 12 months...");
                    }
                }, 5000); // Increment every 5 seconds
                
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                // Stop artificial progress
                clearInterval(progressInterval);
                
                updateProgress(40, ' Step 1 of 4: Sampling Accounts', 'Receiving data from NetSuite...');
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {}; // { acctNum: "Income" | "Expense" | etc. }
                const accountNames = refreshData.account_names || {}; // { acctNum: "Account Name" }
                
                console.log(`Guide Me: Loaded ${Object.keys(allBalances).length} accounts from full_year_refresh`);
                console.log(`Guide Me: Account types received for ${Object.keys(accountTypes).length} accounts`);
                console.log(`Guide Me: Account names received for ${Object.keys(accountNames).length} accounts`);
                
                // CRITICAL: Populate the frontend cache so formulas can use the data!
                // This prevents #BUSY from appearing and makes formulas resolve instantly
                updateProgress(42, ' Preparing Data', 'Getting everything ready for fast analysis...');
                
                // IMPORTANT: Fill in $0 for ALL 12 months for each account
                // This prevents #BUSY for months with no transactions (they should show $0 instantly)
                const allMonthNames = monthNames.map(m => `${m} ${currentYear}`);
                let filledCount = 0;
                for (const acctNum in allBalances) {
                    for (const monthName of allMonthNames) {
                        if (allBalances[acctNum][monthName] === undefined) {
                            allBalances[acctNum][monthName] = 0;
                            filledCount++;
                        }
                    }
                }
                console.log(`Guide Me: Filled ${filledCount} missing month/account combinations with $0`);
                
                try {
                    // Save to localStorage (shared with functions.js)
                    const STORAGE_KEY = 'netsuite_balance_cache';
                    const STORAGE_TIMESTAMP_KEY = 'netsuite_balance_cache_timestamp';
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(allBalances));
                    localStorage.setItem(STORAGE_TIMESTAMP_KEY, Date.now().toString());
                    
                    // Save account types to localStorage for persistence
                    localStorage.setItem('netsuite_type_cache', JSON.stringify(accountTypes));
                    
                    // Save account names to localStorage (prevents 35+ parallel requests!)
                    localStorage.setItem('netsuite_name_cache', JSON.stringify(accountNames));
                    
                    // Populate in-memory caches via Shared Runtime (if available)
                    if (typeof window.setFullYearCache === 'function') {
                        window.setFullYearCache(allBalances);
                    }
                    
                    // Populate TYPE cache so XAVI.TYPE resolves correctly
                    if (typeof window.setAccountTypeCache === 'function') {
                        window.setAccountTypeCache(accountTypes);
                    }
                    
                    // Populate NAME cache so XAVI.NAME resolves without 35+ API calls
                    if (typeof window.setAccountNameCache === 'function') {
                        window.setAccountNameCache(accountNames);
                    }
                } catch (cacheError) {
                    console.warn('Guide Me: Cache population warning:', cacheError.message);
                }
                
                // Step 2: Filter to accounts with actual data (at least one non-zero month)
                // PRIORITY: Income accounts first, then Expense accounts
                updateProgress(45, ' Step 2 of 4: Analyzing Data', 'Filtering accounts by type and data...');
                
                const incomeAccounts = [];
                const expenseAccounts = [];
                const otherAccounts = [];
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null && val !== undefined);
                    
                    if (hasData) {
                        const monthValues = monthNames.map(m => monthData[`${m} ${currentYear}`] || 0);
                        const acctInfo = {
                            number: acctNum,
                            type: accountTypes[acctNum] || 'Unknown',
                            monthValues: monthValues,
                            total: monthValues.reduce((a, b) => a + b, 0)
                        };
                        
                        // Categorize by account type
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income' || acctType === 'othincome') {
                            incomeAccounts.push(acctInfo);
                        } else if (acctType === 'expense' || acctType === 'othexpense' || acctType === 'cogs' || acctType === 'cost of goods sold') {
                            expenseAccounts.push(acctInfo);
                        } else {
                            otherAccounts.push(acctInfo);  // BS accounts, etc.
                        }
                    }
                }
                
                console.log(`Guide Me: Found ${incomeAccounts.length} Income, ${expenseAccounts.length} Expense, ${otherAccounts.length} Other accounts`);
                updateProgress(50, ' Step 2 of 4: Analyzing Data', `Found ${incomeAccounts.length} income accounts`);
                
                // Build final list: Income first (up to 35), then Expense to fill remaining
                let allAccounts = [];
                
                // Add Income accounts first (up to 35)
                allAccounts = allAccounts.concat(incomeAccounts.slice(0, 35));
                
                // If we need more, add Expense accounts
                const remaining = 35 - allAccounts.length;
                if (remaining > 0) {
                    allAccounts = allAccounts.concat(expenseAccounts.slice(0, remaining));
                    console.log(`Guide Me: Added ${Math.min(remaining, expenseAccounts.length)} Expense accounts to fill to 35`);
                }
                
                updateProgress(55, ' Step 2 of 4: Analyzing Data', `Selected ${allAccounts.length} accounts (Income + Expense)`);
                
                console.log(`Guide Me: Final selection: ${allAccounts.length} accounts`);
                
                if (allAccounts.length === 0) {
                    throw new Error('No Income or Expense accounts with transaction data found for ' + currentYear);
                }
                
                // Limit to 35 accounts (25 with formulas, 10 more with just account numbers)
                allAccounts = allAccounts.slice(0, 35);
                const formulaRows = 25; // Only first 25 get formulas
                
                // Step 3: Build the Excel template
                updateProgress(60, ' Step 3 of 4: Building Template', 'Creating headers and formatting...');
                
                // Get the default/parent subsidiary (root subsidiary from backend)
                let defaultSubsidiary = '';
                let defaultSubsidiaryId = '1';
                try {
                    // Get parent subsidiary ID from currencies endpoint (backend knows the root)
                    const currencyResponse = await fetch(`${SERVER_URL}/lookups/currencies`);
                    if (currencyResponse.ok) {
                        const currencyData = await currencyResponse.json();
                        defaultSubsidiaryId = currencyData.default_subsidiary || '1';
                    }
                    
                    // Get the subsidiary name
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            const parentSub = lookups.subsidiaries.find(s => s.id === defaultSubsidiaryId);
                            if (parentSub) {
                                defaultSubsidiary = parentSub.name + ' (Consolidated)';
                            } else {
                                const consolidated = lookups.subsidiaries.find(s => 
                                    s.name.toLowerCase().includes('consolidated')
                                );
                                defaultSubsidiary = consolidated ? consolidated.name : lookups.subsidiaries[0].name;
                            }
                        }
                    }
                    
                    if (!defaultSubsidiary) {
                        defaultSubsidiary = 'Parent Company (Consolidated)';
                    }
                } catch (e) {
                    defaultSubsidiary = 'Parent Company (Consolidated)';
                }
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Try to rename sheet (may fail if name exists)
                    try {
                        sheet.name = "Income Statement";
                        await context.sync();
                    } catch (e) { /* Sheet name already exists */ }
                    
                    // Remove gridlines for cleaner look
                    try {
                    sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {
                        console.warn('Could not hide gridlines');
                    }
                    
                    // ========================================
                    // ROW 1-2: PARAMETER SECTION
                    // ========================================
                    
                    // Row 1: Title/spacing
                    const titleCell = sheet.getRange("A1");
                    titleCell.values = [[" Income Statement Parameters"]];
                    await context.sync();
                    
                    try {
                        titleCell.format.font.bold = true;
                        titleCell.format.font.size = 14;
                        titleCell.format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 2: PARAMETER LABELS (above values) ==========
                    sheet.getRange("E2").values = [["YEAR"]];
                    sheet.getRange("G2").values = [["Subsidiary Context"]];
                    await context.sync();
                    
                    // Style parameter labels
                    try {
                        sheet.getRange("E2").format.font.bold = true;
                        sheet.getRange("E2").format.font.color = "#09235C";
                        sheet.getRange("E2").format.font.size = 10;
                        sheet.getRange("G2").format.font.bold = true;
                        sheet.getRange("G2").format.font.color = "#09235C";
                        sheet.getRange("G2").format.font.size = 10;
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: PARAMETER VALUES (below labels) ==========
                    sheet.getRange("E3").values = [[currentYear]];
                    sheet.getRange("G3").values = [[defaultSubsidiary]];
                    await context.sync();
                    
                    // Style parameter INPUT cells (teal background)
                    try {
                        // Year input cell
                        const yearInput = sheet.getRange("E3");
                        yearInput.format.fill.color = "#0AE2C1";
                        yearInput.format.font.bold = true;
                        yearInput.format.font.color = "#09235C";
                        yearInput.format.borders.getItem('EdgeTop').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeBottom').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeLeft').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeRight').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeTop').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeBottom').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeLeft').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeRight').color = '#09235C';
                        
                        // Subsidiary input cell
                        const subInput = sheet.getRange("G3");
                        subInput.format.fill.color = "#0AE2C1";
                        subInput.format.font.bold = true;
                        subInput.format.font.color = "#09235C";
                        subInput.format.borders.getItem('EdgeTop').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeBottom').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeLeft').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeRight').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeTop').color = '#09235C';
                        subInput.format.borders.getItem('EdgeBottom').color = '#09235C';
                        subInput.format.borders.getItem('EdgeLeft').color = '#09235C';
                        subInput.format.borders.getItem('EdgeRight').color = '#09235C';
                        
                        await context.sync();
                    } catch (styleErr) { /* Style error - continue */ }
                    
                    // ========================================
                    // ROW 3: Blank separator
                    // ========================================
                    
                    // ========================================
                    // ROW 4: COLUMN HEADERS
                    // ========================================
                    const headerRow = 4;
                    
                    // Write text headers (A4:C4)
                    const cellA4 = sheet.getRange("A4");
                    cellA4.values = [["Type"]];
                    
                    const cellB4 = sheet.getRange("B4");
                    cellB4.values = [["Account #"]];
                    
                    const cellC4 = sheet.getRange("C4");
                    cellC4.values = [["Account Name"]];
                    
                    await context.sync();
                    
                    // Format header row
                    try {
                        const headerRange = sheet.getRange("A4:C4");
                        headerRange.format.font.bold = true;
                        headerRange.format.font.color = "#FFFFFF";
                        headerRange.format.fill.color = "#09235C";
                        await context.sync();
                    } catch (formatErr) {
                        console.warn('Guide Me: Header format warning:', formatErr.message);
                    }
                    
                    
                    // Write date headers (D4:O4) using DATE formula that references the YEAR parameter
                    // Formula: =DATE($E$3, COLUMN()-COLUMN($C$4)+1, 1)
                    // D4 = month 1, E4 = month 2, etc.
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(68 + m); // D=68
                        const cell = sheet.getRange(`${colLetter}4`);
                        // COLUMN(D4)=4, COLUMN($C$4)=3, so 4-3+1=2... we need 4-3=1 for Jan
                        // Actually: COLUMN()-COLUMN($C$4) gives D=4-3=1, E=5-3=2, etc. Perfect!
                        cell.formulas = [[`=DATE($E$3,COLUMN()-COLUMN($C$4),1)`]];
                    }
                    
                    await context.sync();
                    
                    // Format month headers
                    try {
                        const monthHeaderRange = sheet.getRange("D4:O4");
                        monthHeaderRange.numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                    monthHeaderRange.format.font.bold = true;
                    monthHeaderRange.format.font.color = "#FFFFFF";
                    monthHeaderRange.format.fill.color = "#09235C";
                        await context.sync();
                    } catch (monthFormatErr) {
                        console.warn('Guide Me: Month format warning:', monthFormatErr.message);
                    }
                    
                    // Write YTD Total header (P4)
                    const totalHeaderRange = sheet.getRange("P4");
                    totalHeaderRange.values = [['YTD Total']];
                    
                    await context.sync();
                    
                    // Format YTD header
                    try {
                        const ytdRange = sheet.getRange("P4");
                        ytdRange.format.font.bold = true;
                        ytdRange.format.font.color = "#FFFFFF";
                        ytdRange.format.fill.color = "#09235C";
                        await context.sync();
                    } catch (ytdFormatErr) {
                        console.warn('Guide Me: YTD format warning:', ytdFormatErr.message);
                    }
                    
                    // Set column widths to prevent parameter text from affecting month columns
                    try {
                        sheet.getRange("A:A").format.columnWidth = 60;  // Type
                        sheet.getRange("B:B").format.columnWidth = 80;  // Account #
                        sheet.getRange("C:C").format.columnWidth = 180; // Account Name
                        sheet.getRange("D:O").format.columnWidth = 85;  // Month columns (fixed width)
                        sheet.getRange("P:P").format.columnWidth = 90;  // YTD Total
                        await context.sync();
                    } catch (e) {}
                    
                    // ========================================
                    // ROW 5+: DATA ROWS
                    // ========================================
                    updateProgress(70, ' Step 4 of 4: Adding Formulas', `Writing ${allAccounts.length} accounts...`);
                    
                    const dataStartRow = 5; // Data starts at row 5
                    
                    // Write ALL 35 rows of account numbers, but only first 25 get formulas
                    for (let i = 0; i < allAccounts.length; i++) {
                        const acct = allAccounts[i];
                        const rowNum = dataStartRow + i; // Row 5, 6, 7, ...
                        
                        // Validate account number
                        if (!acct || !acct.number) {
                            console.warn(`Guide Me: Skipping row ${rowNum} - invalid account data`);
                            continue;
                        }
                        
                        try {
                        // Column B: Account NUMBER (always populated)
                        const numCell = sheet.getRange(`B${rowNum}`);
                            const acctNum = String(acct.number);
                            numCell.values = [[acctNum]];
                        
                        // Only add formulas for first 25 rows
                        if (i < formulaRows) {
                            // Column A: Account TYPE formula
                            const typeCell = sheet.getRange(`A${rowNum}`);
                            typeCell.formulas = [[`=XAVI.TYPE(B${rowNum})`]];
                            
                            // Column C: Account NAME formula
                            const nameCell = sheet.getRange(`C${rowNum}`);
                            nameCell.formulas = [[`=XAVI.NAME(B${rowNum})`]];
                            
                                // Columns D-O: BALANCE formulas with SUBSIDIARY parameter
                                // Formula: =XAVI.BALANCE($B5, TEXT(D$4,"mmm yyyy"), TEXT(D$4,"mmm yyyy"), $G$3)
                            for (let m = 0; m < 12; m++) {
                                const colLetter = String.fromCharCode(68 + m);
                                const cell = sheet.getRange(`${colLetter}${rowNum}`);
                                    cell.formulas = [[`=XAVI.BALANCE($B${rowNum},TEXT(${colLetter}$4,"mmm yyyy"),TEXT(${colLetter}$4,"mmm yyyy"),$G$3)`]];
                            }
                            
                            // Column P: YTD Total formula
                            const totalCell = sheet.getRange(`P${rowNum}`);
                            totalCell.formulas = [[`=SUM(D${rowNum}:O${rowNum})`]];
                        }
                        
                            // Alternating row colors
                        if (i % 2 === 0) {
                            const rowRange = sheet.getRange(`A${rowNum}:P${rowNum}`);
                            rowRange.format.fill.color = "#F5F7FA";
                            }
                        } catch (rowError) {
                            console.error(`Guide Me: Error writing row ${rowNum}:`, rowError.message);
                        }
                        
                        // Update progress every 5 rows
                        if (i % 5 === 0) {
                            updateProgress(70 + Math.floor((i / allAccounts.length) * 20), 
                                ' Step 4 of 4: Adding Formulas', 
                                `Processing row ${i + 1} of ${allAccounts.length}...`);
                        }
                    }
                    
                    await context.sync();
                    
                    updateProgress(92, ' Finishing Up', 'Applying formatting...');
                    
                    // Format number columns as CURRENCY with no decimals
                    try {
                        const lastDataRow = dataStartRow + Math.min(allAccounts.length, 35) - 1;
                        const numRange = sheet.getRange(`D${dataStartRow}:P${lastDataRow}`);
                        const formatRows = lastDataRow - dataStartRow + 1;
                        const formatCols = 13; // columns D through P
                        const numberFormatArray = Array(formatRows).fill(null).map(() => 
                            Array(formatCols).fill('#,##0')
                        );
                        numRange.numberFormat = numberFormatArray;
                    } catch (formatError) {
                        console.warn('Guide Me: Number format warning:', formatError.message);
                    }
                    
                    await context.sync();
                    
                    // Add LEFT BORDER to YTD Total column (P)
                    try {
                        const lastDataRow = dataStartRow + Math.min(allAccounts.length, 35) - 1;
                        const totalColumn = sheet.getRange(`P4:P${lastDataRow}`);
                        const leftBorder = totalColumn.format.borders.getItem('EdgeLeft');
                        leftBorder.style = 'Continuous';
                        leftBorder.weight = 'Medium';
                        leftBorder.color = '#09235C';
                    } catch (borderError) {
                        console.warn('Guide Me: Border formatting warning:', borderError.message);
                    }
                    
                    await context.sync();
                    
                    updateProgress(96, ' Finishing Up', 'Finalizing layout...');
                    
                    // Freeze rows 1-4 (parameters + header)
                    try {
                        sheet.freezePanes.freezeRows(4);
                    } catch (freezeError) {
                        console.warn('Guide Me: Freeze panes warning:', freezeError.message);
                    }
                    
                    await context.sync();
                    
                    updateProgress(100, ' Complete!', 'Your report is ready!');
                });
                
                // Stop tip rotation
                clearInterval(tipInterval);
                
                // Remove overlay
                overlay.remove();
                
                // Calculate how many rows need formulas extended
                const extraRows = Math.min(10, allAccounts.length - formulaRows);
                const lastFormulaRow = 4 + formulaRows; // Row 29 (4 header rows + 25 formula rows)
                const lastDataRow = 4 + allAccounts.length; // Row 39 (4 header rows + 35 data rows)
                
                // Success message - show as dismissible overlay with timing
                const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                showReportSuccessOverlay('Sample Report', {
                    totalAccounts: allAccounts.length,
                    elapsedTime: elapsedSeconds,
                    sections: [
                        { name: 'Rows with formulas', count: formulaRows },
                        { name: 'Rows ready to extend', count: extraRows }
                    ],
                    tips: [
                        { type: 'info', icon: '', title: 'Change Parameters:', text: 'Edit the <strong>Year</strong> and <strong>Subsidiary</strong> values in the header to refresh all formulas automatically!' },
                        { type: 'info', icon: '', title: '#BUSY:', text: 'You may see <code>#BUSY</code> in cells for a few seconds as data loads. This is normal!' },
                        { type: 'info', icon: '', title: 'Extend formulas:', text: `Select <strong>A${lastFormulaRow}:P${lastFormulaRow}</strong> and drag down to row ${lastDataRow}` },
                        { type: 'info', icon: '', title: 'Formulas used:', text: '<code>XAVI.TYPE</code>, <code>XAVI.NAME</code>, <code>XAVI.BALANCE</code>' }
                    ]
                });
                
                // Close Quick Start accordion after successful generation
                closeQuickStart();
                
                // After report is built, scan for subsidiary cells and apply currency formatting
                setTimeout(async () => {
                    try {
                        console.log(' Trial Balance: Scanning for subsidiary cells and formatting currencies...');
                        await scanForSubsidiaryCells();
                        await autoFormatCurrencies();
                    } catch (e) {
                        console.warn('Post-report currency format failed:', e.message);
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Guide Me error:', error);
                clearInterval(tipInterval);
                if (document.getElementById('guideMeOverlay')) {
                    document.getElementById('guideMeOverlay').remove();
                }
                if (progress) {
                    progress.style.display = 'block';
                    progress.textContent = ` Error: ${error.message}`;
                }
                if (btn) {
                    btn.disabled = false;
                    btn.style.background = '';
                }
            }
        }

        // ================================================================
        // GENERATE SUMMARY INCOME STATEMENT (High-Level P&L with TYPEBALANCE)
        // ================================================================
        
        async function generateSummaryIncomeStatement() {
            // CRITICAL: Prevent filter change handlers from triggering during report generation
            // When we write to P3, Q3, R3, S3, T3, U3, the event listeners would trigger
            // another sync - we must block that until report is fully generated
            isSyncInProgress = true;
            console.log(' CFO Flash: Blocking filter change handlers during generation');
            
            const startTime = Date.now(); // Track timing
            const progress = document.getElementById('guideMeProgress');
            const currentYear = new Date().getFullYear();
            
            // Tips with formula explanations every 3rd item
            const excelTips = [
                // XAVI Formula explanation
                ' XAVI.TYPEBALANCE("Income", from, to) sums ALL accounts of type "Income" for the period',
                ' TYPEBALANCE is faster than individual account formulas for summary reports',
                // Excel tip
                ' Summary P&L is perfect for executive dashboards and board meetings',
                // XAVI Formula explanation  
                ' XAVI.TYPEBALANCE("COGS", from, to) totals Cost of Goods Sold accounts',
                ' Parameters: account_type, from_period, to_period, subsidiary, dept, class, location',
                // Excel tip
                ' Change the Year cell to instantly update all formulas on the sheet',
                // XAVI Formula explanation
                ' XAVI.TYPEBALANCE("Expense", from, to) sums all Operating Expense accounts',
                ' Valid types: Income, COGS, Expense, OthIncome, OthExpense, plus Balance Sheet types',
                // Excel tip
                ' KPI cards automatically calculate margins and ratios from the data',
                // XAVI Formula explanation
                ' XAVI.TYPEBALANCE works with subsidiaries: add 5th parameter like "Celigo Inc."',
                ' For P&L: use same from/to period for monthly, different for YTD ranges',
                // Excel tip
                ' Filter by subsidiary, department, class, or location using optional parameters'
            ];
            let tipIndex = 0;
            
            // Create loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'summaryISOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building CFO Flash Report</h2>
                <div class="loading-subtitle">
                     This can take a couple of minutes while we review your NetSuite data and do all of the heavy lifting. Good things come to those who wait, right?
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="summaryISProgressBar"></div>
                    </div>
                    <div class="progress-text" id="summaryISProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="summaryISStep">Initializing...</div>
                <div class="loading-step-desc" id="summaryISStepDesc">Setting up your report</div>
                
                <div class="tips-section">
                    <div class="tips-label">Formula Tips</div>
                    <div class="loading-tip" id="summaryISTip">${excelTips[0]}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Rotate tips
            const tipInterval = setInterval(() => {
                tipIndex = (tipIndex + 1) % excelTips.length;
                const tipEl = document.getElementById('summaryISTip');
                if (tipEl) {
                    tipEl.style.opacity = '0';
                    setTimeout(() => {
                        tipEl.innerHTML = '';  // Clear completely
                        tipEl.textContent = excelTips[tipIndex];
                        tipEl.style.opacity = '1';
                    }, 300);
                }
            }, 2500);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('summaryISProgressBar');
                const text = document.getElementById('summaryISProgressText');
                const stepEl = document.getElementById('summaryISStep');
                const descEl = document.getElementById('summaryISStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            try {
                updateProgress(10, ' Step 1 of 4: Getting Settings', 'Loading subsidiary and currency info...');
                
                // Get default subsidiary and currency format
                let defaultSubsidiary = '';
                let defaultSubsidiaryId = '1';
                let currencyFormat = '$#,##0.00';
                
                try {
                    const currencyResponse = await fetch(`${SERVER_URL}/lookups/currencies`);
                    if (currencyResponse.ok) {
                        const currencyData = await currencyResponse.json();
                        defaultSubsidiaryId = currencyData.default_subsidiary || '1';
                        const symbol = currencyData.currencies[defaultSubsidiaryId] || '$';
                        currencyFormat = currencyData.formats[symbol] || '$#,##0.00';
                    }
                    
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            const parentSub = lookups.subsidiaries.find(s => s.id === defaultSubsidiaryId);
                            if (parentSub) {
                                defaultSubsidiary = parentSub.name + ' (Consolidated)';
                            } else {
                                const consolidated = lookups.subsidiaries.find(s => 
                                    s.name.toLowerCase().includes('consolidated')
                                );
                                defaultSubsidiary = consolidated ? consolidated.name : lookups.subsidiaries[0].name;
                            }
                        }
                    }
                    if (!defaultSubsidiary) defaultSubsidiary = 'Parent Company (Consolidated)';
                } catch (e) {
                    console.warn('Subsidiary lookup failed:', e.message);
                    defaultSubsidiary = 'Parent Company (Consolidated)';
                }
                
                // ========== PRE-FETCH TYPE BALANCES ==========
                // Call batch typebalance refresh BEFORE adding formulas
                // This pre-populates the cache so formulas resolve instantly
                updateProgress(20, ' Pre-fetching Type Balances', 'Loading all P&L types in one query...');
                
                try {
                    console.log(' CFO Flash: Pre-fetching TYPEBALANCE data for instant formula resolution...');
                    const typeBalanceResponse = await fetch(`${SERVER_URL}/batch/typebalance_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: currentYear,
                            subsidiary: defaultSubsidiary,
                            department: '',
                            location: '',
                            classId: '',
                            accountingBook: ''
                        })
                    });
                    
                    if (typeBalanceResponse.ok) {
                        const typeBalanceData = await typeBalanceResponse.json();
                        const balances = typeBalanceData.balances || {};
                        const typesLoaded = Object.keys(balances).length;
                        
                        console.log(` CFO Flash: Pre-fetched ${typesLoaded} account types  12 months`);
                        
                        // CRITICAL: Save directly to localStorage - don't rely on setTypeBalanceCache
                        // because functions.js may not be loaded yet!
                        console.log(' CFO Flash: Saving TYPEBALANCE cache directly to localStorage...');
                        console.log(`   - ${Object.keys(balances).length} account types`);
                        console.log(`   - Year: ${currentYear}`);
                        console.log(`   - Subsidiary: "${defaultSubsidiary}"`);
                        
                        try {
                            // Build cache entries with exact same key format as TYPEBALANCE function uses
                            const cacheEntries = {};
                            const specialFlag = '0'; // useSpecial = false
                            
                            for (const accountType in balances) {
                                const monthData = balances[accountType];
                                for (const period in monthData) {
                                    const value = monthData[period];
                                    // Key format: typebalance:${type}:${from}:${to}:${sub}:${dept}:${loc}:${class}:${book}:${special}
                                    // 4 empty fields: department, location, class, book
                                    // IMPORTANT: Must trim subsidiary - TYPEBALANCE function uses .trim()
                                    const cacheKey = `typebalance:${accountType}:${period}:${period}:${(defaultSubsidiary || '').trim()}::::${specialFlag}`;
                                    cacheEntries[cacheKey] = value;
                                }
                            }
                            
                            const storageData = {
                                balances: cacheEntries,
                                year: currentYear,
                                subsidiary: defaultSubsidiary,
                                timestamp: Date.now()
                            };
                            
                            localStorage.setItem('netsuite_typebalance_cache', JSON.stringify(storageData));
                            localStorage.setItem('netsuite_typebalance_cache_timestamp', Date.now().toString());
                            
                            console.log(` CFO Flash: Saved ${Object.keys(cacheEntries).length} cache entries to localStorage`);
                            
                            // Log sample keys for debugging
                            const sampleKeys = Object.keys(cacheEntries).slice(0, 3);
                            console.log('   Sample keys:');
                            sampleKeys.forEach(k => console.log(`      "${k}"`));
                            
                        } catch (e) {
                            console.error(' CFO Flash: localStorage save failed:', e.message);
                        }
                        
                        // Also try to call setTypeBalanceCache if available (for in-memory cache)
                        if (typeof window.setTypeBalanceCache === 'function') {
                            window.setTypeBalanceCache(balances, currentYear, defaultSubsidiary, '', '', '', '', false);
                        }
                    } else {
                        console.warn(' CFO Flash: TypeBalance pre-fetch failed, formulas will load individually');
                    }
                } catch (e) {
                    console.warn(' CFO Flash: TypeBalance pre-fetch error:', e.message);
                    // Continue anyway - formulas will just load one at a time
                }
                
                updateProgress(35, ' Step 2 of 4: Building Structure', 'Creating headers and parameters...');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Rename sheet
                    try {
                        sheet.name = "Summary P&L";
                        await context.sync();
                    } catch (e) {}
                    
                    // Hide gridlines
                    try {
                        sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 1: TITLE ==========
                    const titleCell = sheet.getRange("A1");
                    titleCell.values = [["Using XAVI.TYPEBALANCE"]];
                    titleCell.format.font.bold = true;
                    titleCell.format.font.size = 14;
                    titleCell.format.font.color = "#09235C";
                    await context.sync();
                    
                    // ========== ROW 2: PARAMETER LABELS ==========
                    sheet.getRange("P2").values = [["YEAR"]];
                    sheet.getRange("Q2").values = [["Subsidiary"]];
                    sheet.getRange("R2").values = [["Department"]];
                    sheet.getRange("S2").values = [["Location"]];
                    sheet.getRange("T2").values = [["Class"]];
                    sheet.getRange("U2").values = [["Acct Book"]];
                    sheet.getRange("V2").values = [[" CFO Sync"]];  // Different marker for CFO Flash
                    await context.sync();
                    
                    // Style parameter labels
                    const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                    for (const cell of labelCells) {
                        sheet.getRange(cell).format.font.bold = true;
                        sheet.getRange(cell).format.font.color = "#09235C";
                        sheet.getRange(cell).format.font.size = 10;
                    }
                    await context.sync();
                    
                    // ========== ROW 3: PARAMETER VALUES ==========
                    // CRITICAL: Set sync trackers BEFORE context.sync() to prevent race condition
                    lastSyncedYear = String(currentYear);
                    lastSyncedSubsidiary = defaultSubsidiary;
                    
                    sheet.getRange("P3").values = [[currentYear]];
                    sheet.getRange("Q3").values = [[defaultSubsidiary]];
                    sheet.getRange("R3").values = [[""]];
                    sheet.getRange("S3").values = [[""]];
                    sheet.getRange("T3").values = [[""]];
                    sheet.getRange("U3").values = [[""]];
                    sheet.getRange("V3").values = [["TRUE"]];  // Enable sync
                    await context.sync();
                    
                    // Style parameter value cells (teal background)
                    const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                    for (const cell of valueCells) {
                        sheet.getRange(cell).format.fill.color = "#0AE2C1";
                        sheet.getRange(cell).format.font.bold = true;
                        sheet.getRange(cell).format.font.color = "#09235C";
                    }
                    await context.sync();
                    
                    // NOTE: Parameter cell comments removed - caused errors on Mac
                    
                    // ========== ROW 4: KPI DASHBOARD ==========
                    try {
                        sheet.getRange("4:4").format.rowHeight = 50;
                        await context.sync();
                    } catch (e) {}
                    
                    // Merge KPI card cells
                    try {
                        sheet.getRange("A4:C4").merge();
                        sheet.getRange("D4:F4").merge();
                        sheet.getRange("G4:I4").merge();
                        sheet.getRange("J4:L4").merge();
                        await context.sync();
                    } catch (e) {}
                    
                    // KPI formulas using named ranges - matching screenshot layout
                    // Revenue: shows absolute value
                    sheet.getRange("A4").formulas = [['=" YTD REVENUE\n"&TEXT(IFERROR(@_Revenue,0),"#,##0")&"\nTotal Revenue YTD"']];
                    // Gross Margin: percentage
                    sheet.getRange("D4").formulas = [['=" GROSS MARGIN\n"&IF(IFERROR(@_Revenue,0)=0,"N/A",TEXT(IFERROR(@_Gross_Margin,0)/IFERROR(@_Revenue,0),"0.0%"))&"\nGross Profit / Revenue"']];
                    // Net Income: percentage of revenue
                    sheet.getRange("G4").formulas = [['=" NET INCOME\n"&IF(IFERROR(@_Revenue,0)=0,"N/A",TEXT(IFERROR(@_Net_Income,0)/IFERROR(@_Revenue,0),"0.0%"))&"\nNet Income / Revenue"']];
                    // OpEx Ratio: percentage
                    sheet.getRange("J4").formulas = [['=" OPEX RATIO\n"&IF(IFERROR(@_Revenue,0)=0,"N/A",TEXT(IFERROR(@_Operating_Expenses,0)/IFERROR(@_Revenue,0),"0.0%"))&"\nOpEx / Revenue"']];
                    await context.sync();
                    
                    // Style KPI cards
                    try {
                        const kpiStyle = async (range, bgColor, fontColor = "#FFFFFF") => {
                            const r = sheet.getRange(range);
                            r.format.font.bold = true;
                            r.format.font.size = 11;
                            r.format.font.color = fontColor;
                            r.format.fill.color = bgColor;
                            r.format.horizontalAlignment = "Center";
                            r.format.verticalAlignment = "Center";
                            r.format.wrapText = true;
                        };
                        await kpiStyle("A4:C4", "#22C55E");
                        await kpiStyle("D4:F4", "#FBBF24", "#000000");
                        await kpiStyle("G4:I4", "#EF4444");
                        await kpiStyle("J4:L4", "#8B5CF6");
                        await context.sync();
                    } catch (e) {}
                    
                    updateProgress(50, ' Step 3 of 4: Adding Formulas', 'Writing TYPEBALANCE formulas...');
                    
                    // ========== ROW 5: COLUMN HEADERS ==========
                    sheet.getRange("A5").values = [["Line Item"]];
                    sheet.getRange("B5").values = [[""]]; // Empty for spacing
                    
                    // Row 5 header labels (displayed) - formatted as "mmm-yy" for compact display
                    // These cells contain DATE values that TYPEBALANCE formulas will reference
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(67 + m); // C=67
                        sheet.getRange(`${colLetter}5`).formulas = [[`=DATE($P$3,${m + 1},1)`]];
                    }
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    // Format headers
                    const headerRange = sheet.getRange("A5:O5");
                    headerRange.format.font.bold = true;
                    headerRange.format.font.color = "#FFFFFF";
                    headerRange.format.fill.color = "#09235C";
                    
                    const monthRange = sheet.getRange("C5:N5");
                    monthRange.numberFormat = [['mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy', 'mmm-yy']];
                    await context.sync();
                    
                    // Helper to build TYPEBALANCE formula for each month
                    // References the header row 5 cells which contain DATE values
                    // The TYPEBALANCE function will convert the date serial number to "mmm yyyy" format
                    const buildTypeBalanceFormula = (acctType, colIndex) => {
                        const colLetter = String.fromCharCode(67 + (colIndex - 3)); // C=67
                        // Format: =XAVI.TYPEBALANCE(type, fromPeriod, toPeriod, subsidiary, dept, loc, class, acctBook)
                        // Reference the DATE value in row 5 - TYPEBALANCE will convert it
                        return `=XAVI.TYPEBALANCE("${acctType}",${colLetter}$5,${colLetter}$5,$Q$3,$R$3,$S$3,$T$3,$U$3)`;
                    };
                    
                    // Helper to create named range for YTD column
                    const createNamedRange = async (name, row) => {
                        try {
                            const range = sheet.getRange(`O${row}`);
                            const namedItem = context.workbook.names.add(name, range);
                            await context.sync();
                        } catch (e) {
                            console.warn(`Could not create named range ${name}:`, e.message);
                        }
                    };
                    
                    // ========== ROW 6: REVENUE (Income) ==========
                    sheet.getRange("A6").values = [["Total Revenue"]];
                    sheet.getRange("A6").format.font.bold = true;
                    sheet.getRange("A6").format.font.color = "#09235C";
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}6`).formulas = [[buildTypeBalanceFormula("Income", 3 + m)]];
                    }
                    sheet.getRange("O6").formulas = [["=SUM(C6:N6)"]];
                    await context.sync();
                    await createNamedRange("_Revenue", 6);
                    
                    // ========== ROW 7: COGS ==========
                    sheet.getRange("A7").values = [["Cost of Goods Sold"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}7`).formulas = [[buildTypeBalanceFormula("COGS", 3 + m)]];
                    }
                    sheet.getRange("O7").formulas = [["=SUM(C7:N7)"]];
                    await context.sync();
                    await createNamedRange("_COGS", 7);
                    
                    // ========== ROW 8: GROSS MARGIN ==========
                    sheet.getRange("A8").values = [["Gross Margin"]];
                    sheet.getRange("A8").format.font.bold = true;
                    sheet.getRange("A8").format.font.color = "#09235C";
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        // Gross Margin = Revenue - COGS (natural signs flow correctly)
                        sheet.getRange(`${col}8`).formulas = [[`=${col}6-${col}7`]];
                    }
                    // YTD uses named ranges for readability
                    sheet.getRange("O8").formulas = [["=@_Revenue-@_COGS"]];
                    await context.sync();
                    
                    // Style Gross Margin row (light blue background)
                    const gmRange = sheet.getRange("A8:O8");
                    gmRange.format.fill.color = "#D4E6F1";
                    gmRange.format.borders.getItem('EdgeTop').style = 'Continuous';
                    gmRange.format.borders.getItem('EdgeBottom').style = 'Continuous';
                    await context.sync();
                    await createNamedRange("_Gross_Margin", 8);
                    
                    // ========== ROW 9: BLANK ==========
                    
                    // ========== ROW 10: OPERATING EXPENSES ==========
                    sheet.getRange("A10").values = [["Operating Expenses"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}10`).formulas = [[buildTypeBalanceFormula("Expense", 3 + m)]];
                    }
                    sheet.getRange("O10").formulas = [["=SUM(C10:N10)"]];
                    await context.sync();
                    await createNamedRange("_Operating_Expenses", 10);
                    
                    // ========== ROW 11: NET OPERATING INCOME ==========
                    sheet.getRange("A11").values = [["Net Operating Income"]];
                    sheet.getRange("A11").format.font.bold = true;
                    sheet.getRange("A11").format.font.color = "#09235C";
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        // Operating Income = Gross Margin - Operating Expenses (natural signs)
                        sheet.getRange(`${col}11`).formulas = [[`=${col}8-${col}10`]];
                    }
                    // YTD uses named ranges for readability
                    sheet.getRange("O11").formulas = [["=@_Gross_Margin-@_Operating_Expenses"]];
                    await context.sync();
                    
                    // Style Operating Income row
                    const oiRange = sheet.getRange("A11:O11");
                    oiRange.format.fill.color = "#D5F5E3";
                    oiRange.format.borders.getItem('EdgeTop').style = 'Continuous';
                    await context.sync();
                    await createNamedRange("_Operating_Income", 11);
                    
                    // ========== ROW 12: BLANK ==========
                    
                    // ========== ROW 13: OTHER INCOME (with blank row 12) ==========
                    sheet.getRange("A13").values = [["Other Income"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}13`).formulas = [[buildTypeBalanceFormula("OthIncome", 3 + m)]];
                    }
                    sheet.getRange("O13").formulas = [["=SUM(C13:N13)"]];
                    await context.sync();
                    await createNamedRange("_Other_Income", 13);
                    
                    // ========== ROW 14: OTHER EXPENSES ==========
                    sheet.getRange("A14").values = [["Other Expenses"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}14`).formulas = [[buildTypeBalanceFormula("OthExpense", 3 + m)]];
                    }
                    sheet.getRange("O14").formulas = [["=SUM(C14:N14)"]];
                    await context.sync();
                    await createNamedRange("_Other_Expense", 14);
                    
                    // ========== ROW 15: BLANK ==========
                    
                    // ========== ROW 16: NET INCOME (with blank row 15) ==========
                    sheet.getRange("A16").values = [["Net Income"]];
                    sheet.getRange("A16").format.font.bold = true;
                    sheet.getRange("A16").format.font.size = 12;
                    sheet.getRange("A16").format.font.color = "#09235C";
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        // Net Income = Operating Income + Other Income - Other Expense (natural signs)
                        sheet.getRange(`${col}16`).formulas = [[`=${col}11+${col}13-${col}14`]];
                    }
                    // YTD uses named ranges for readability
                    sheet.getRange("O16").formulas = [["=@_Operating_Income+@_Other_Income-@_Other_Expense"]];
                    await context.sync();
                    
                    // Style Net Income row (dark navy with white text - matches Full P&L)
                    const niRange = sheet.getRange("A16:O16");
                    niRange.format.font.bold = true;
                    niRange.format.fill.color = "#09235C";
                    niRange.format.font.color = "#FFFFFF";
                    niRange.format.borders.getItem('EdgeTop').style = 'Double';
                    niRange.format.borders.getItem('EdgeBottom').style = 'Double';
                    await context.sync();
                    await createNamedRange("_Net_Income", 16);
                    
                    updateProgress(80, ' Formatting', 'Applying currency formats...');
                    
                    // Format all data as currency
                    const dataRange = sheet.getRange("C6:O16");
                    dataRange.numberFormat = currencyFormat;
                    await context.sync();
                    
                    // Set column widths
                    sheet.getRange("A:A").format.columnWidth = 200;
                    sheet.getRange("B:B").format.columnWidth = 20;
                    sheet.getRange("C:O").format.columnWidth = 85;
                    await context.sync();
                    
                    updateProgress(100, ' Complete!', 'Your CFO Flash Report is ready!');
                });
                
                // Cleanup - update overlay to show waiting for formulas
                clearInterval(tipInterval);
                
                // Update overlay to show we're waiting for formulas
                const overlayTitle = overlay.querySelector('h2');
                const overlaySubtitle = overlay.querySelector('.loading-subtitle');
                const overlayStep = overlay.querySelector('.loading-step');
                const overlayStepDesc = overlay.querySelector('.loading-step-desc');
                const overlayProgress = overlay.querySelector('.progress-bar-fill');
                const overlayProgressText = overlay.querySelector('.progress-text');
                
                if (overlayTitle) overlayTitle.textContent = ' Step 4 of 4: Tidying Up';
                if (overlaySubtitle) overlaySubtitle.innerHTML = 'Tidying up the results. This is the last step...';
                if (overlayStep) overlayStep.innerHTML = '<span class="spreadsheet-animation"></span> Tucking everything into place...';
                if (overlayStepDesc) overlayStepDesc.textContent = '';
                
                // Hide any other loading overlays and status bars
                hideLoading();
                hideStatus();
                
                // Wait for formulas to complete - no sub-messages, just "Tidying Up"
                await waitForFormulasToComplete(60000, null);
                
                // Auto-fit columns AFTER all formulas have resolved
                await autoFitColumns();
                
                // NOW remove overlay and show success
                overlay.remove();
                
                // Show success overlay with timing
                const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                showReportSuccessOverlay('CFO Flash Report', {
                    totalAccounts: 5,
                    elapsedTime: elapsedSeconds,
                    countLabel: 'Formula Type',  // Header label for the count column
                    sections: [
                        { name: 'Revenue', count: 'TYPEBALANCE' },
                        { name: 'COGS', count: 'TYPEBALANCE' },
                        { name: 'Expenses', count: 'TYPEBALANCE' },
                        { name: 'Other', count: 'TYPEBALANCE' }
                    ],
                    tips: [
                        { type: 'info', icon: '', title: 'Year:', text: 'Edit <strong>P3</strong> to change year. Auto-syncs.' },
                        { type: 'info', icon: '', title: 'Subsidiary:', text: 'Edit <strong>Q3</strong> to filter. Auto-syncs.' },
                        { type: 'info', icon: '', title: 'Named Ranges:', text: '_Revenue, _COGS, _Gross_Margin, _Operating_Income, _Net_Income' }
                    ]
                });
                
                closeQuickStart();
                
                // After report is built, scan for subsidiary cells and apply currency formatting
                setTimeout(async () => {
                    try {
                        console.log(' CFO Flash Report: Scanning for subsidiary cells and formatting currencies...');
                        await scanForSubsidiaryCells();
                        await autoFormatCurrencies();
                    } catch (e) {
                        console.warn('Post-report currency format failed:', e.message);
                    }
                    
                    // Release the sync lock after currency formatting is done
                    // Reduced delay (was 1000ms) - user can change subsidiary sooner
                    setTimeout(() => {
                        isSyncInProgress = false;
                        console.log(' CFO Flash: Filter change handlers unblocked - report generation complete');
                    }, 500);
                }, 500); // Reduced from 2000ms - formulas start immediately
                
            } catch (error) {
                console.error('CFO Flash Report error:', error);
                clearInterval(tipInterval);
                if (document.getElementById('summaryISOverlay')) {
                    document.getElementById('summaryISOverlay').remove();
                }
                progress.style.display = 'block';
                progress.textContent = ` Error: ${error.message}`;
                
                // Release the sync lock on error too
                isSyncInProgress = false;
                console.log(' CFO Flash: Filter change handlers unblocked (error case)');
            }
        }

        // ================================================================
        // GENERATE FULL INCOME STATEMENT
        // ================================================================
        
        async function generateFullIncomeStatement() {
            const startTime = Date.now(); // Track timing
            const progress = document.getElementById('guideMeProgress');
            const currentYear = new Date().getFullYear();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Set flag to prevent auto-sync from triggering during generation
            isSyncInProgress = true;
            lastSyncedYear = currentYear;
            
            // Tips with XAVI.BALANCE formula explanations every 3rd item
            const excelTips = [
                // XAVI Formula explanation
                ' XAVI.BALANCE(account, from, to) returns the balance for a specific G/L account',
                ' Parameters: account number, from_period, to_period, subsidiary, dept, class, location',
                // Excel tip
                ' Drag formulas down to copy for multiple accountscell refs auto-adjust',
                // XAVI Formula explanation
                ' For monthly balances, use same from/to: XAVI.BALANCE("40110", "Jan 2025", "Jan 2025")',
                ' For YTD: use different from/to: XAVI.BALANCE("40110", "Jan 2025", "Dec 2025")',
                // Excel tip
                'Ctrl+Shift+L  Toggle filters quickly on your data',
                // XAVI Formula explanation
                ' Use wildcards: XAVI.BALANCE("401*", from, to) sums all accounts starting with 401',
                ' Wildcards work for ranges too: "40*" matches 4000-4999',
                // Excel tip
                ' Double-click the fill handle to auto-fill formulas down to adjacent data',
                // XAVI Formula explanation
                ' Add subsidiary filter: XAVI.BALANCE("40110", from, to, "Celigo Inc.")',
                ' Use "(Consolidated)" suffix for subsidiary rollups',
                // Excel tip
                'F4  Toggle absolute refs ($A$1) to lock row/column references',
                // XAVI Formula explanation
                ' XAVI.NAME(account) returns the account namegreat for labels next to numbers',
                ' XAVI.TYPE(account) returns the account type (Income, Expense, etc.)',
                // Excel tip
                ' Named ranges make formulas self-documenting and easier to maintain',
                // XAVI Formula explanation
                ' Balance Sheet accounts ignore from_periodjust pass the to_period',
                ' For BS: XAVI.BALANCE("10100", "", "Dec 2025") gets year-end balance'
            ];
            let tipIndex = 0;
            
            // Create loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'incomeStatementOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building Your Income Statement</h2>
                <div class="loading-subtitle">
                     We're reviewing your NetSuite data and doing the hard work for you. It takes a couple of minutes but is worth the wait. Coffee refills optional.
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="isProgressBar"></div>
                    </div>
                    <div class="progress-text" id="isProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="isStep">Connecting to NetSuite...</div>
                <div class="loading-step-desc" id="isStepDesc">Establishing secure connection</div>
                
                <div class="tips-section">
                    <div class="tips-label">XAVI Formula Tips</div>
                    <div class="loading-tip" id="isTip">${excelTips[0]}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Rotate tips
            const tipInterval = setInterval(() => {
                tipIndex = (tipIndex + 1) % excelTips.length;
                const tipEl = document.getElementById('isTip');
                if (tipEl) {
                    tipEl.style.opacity = '0';
                    setTimeout(() => {
                        tipEl.innerHTML = '';  // Clear completely
                        tipEl.textContent = excelTips[tipIndex];
                        tipEl.style.opacity = '1';
                    }, 300);
                }
            }, 3000);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('isProgressBar');
                const text = document.getElementById('isProgressText');
                const stepEl = document.getElementById('isStep');
                const descEl = document.getElementById('isStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            try {
                // Step 1: Fetch ALL account data
                updateProgress(5, ' Step 1 of 6: Loading Accounts', 'Fetching all P&L accounts from NetSuite...');
                
                let artificialProgress = 5;
                const progressInterval = setInterval(() => {
                    if (artificialProgress < 30) {
                        artificialProgress += 2;
                        updateProgress(artificialProgress, ' Step 1 of 6: Loading Accounts', 
                            'Querying NetSuite for all account balances...');
                    }
                }, 4000);
                
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                clearInterval(progressInterval);
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                console.log(`Income Statement: Loaded ${Object.keys(allBalances).length} accounts`);
                
                // CRITICAL: Save to localStorage so XAVI.BALANCE formulas can use cached data
                // This prevents individual API calls for each formula cell
                console.log(' Income Statement: Saving BALANCE cache to localStorage...');
                try {
                    const cacheData = {};
                    for (const acctNum in allBalances) {
                        cacheData[acctNum] = allBalances[acctNum];
                    }
                    localStorage.setItem('netsuite_balance_cache', JSON.stringify(cacheData));
                    localStorage.setItem('netsuite_balance_cache_timestamp', Date.now().toString());
                    console.log(` Income Statement: Saved ${Object.keys(cacheData).length} accounts to localStorage`);
                } catch (e) {
                    console.warn(' Income Statement: localStorage save failed:', e.message);
                }
                
                // Step 2: Categorize accounts by type
                updateProgress(35, ' Step 2 of 6: Categorizing', 'Grouping accounts by type...');
                
                const categories = {
                    income: [],      // Revenue
                    othIncome: [],   // Other Income
                    cogs: [],        // Cost of Goods Sold
                    expense: [],     // Operating Expenses
                    othExpense: []   // Other Expenses
                };
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const monthValues = monthNames.map(m => monthData[`${m} ${currentYear}`] || 0);
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown',
                            monthValues: monthValues,
                            total: monthValues.reduce((a, b) => a + b, 0)
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') {
                            categories.income.push(acctInfo);
                        } else if (acctType === 'othincome') {
                            categories.othIncome.push(acctInfo);
                        } else if (acctType === 'cogs' || acctType === 'cost of goods sold') {
                            categories.cogs.push(acctInfo);
                        } else if (acctType === 'expense') {
                            categories.expense.push(acctInfo);
                        } else if (acctType === 'othexpense') {
                            categories.othExpense.push(acctInfo);
                        }
                    }
                }
                
                // Sort each category by account number
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                console.log(`Income Statement: Revenue=${categories.income.length}, OthIncome=${categories.othIncome.length}, COGS=${categories.cogs.length}, Expense=${categories.expense.length}, OthExpense=${categories.othExpense.length}`);
                
                // Get default subsidiary (parent/root) and its currency format
                // Use the currencies endpoint which correctly identifies the parent via backend
                let defaultSubsidiary = '';
                let defaultSubsidiaryId = '1';
                let currencyFormat = '$#,##0.00';  // Default to USD
                try {
                    // First get the correct parent subsidiary from currencies endpoint
                    const currencyResponse = await fetch(`${SERVER_URL}/lookups/currencies`);
                    if (currencyResponse.ok) {
                        const currencyData = await currencyResponse.json();
                        defaultSubsidiaryId = currencyData.default_subsidiary || '1';
                        const symbol = currencyData.currencies[defaultSubsidiaryId] || '$';
                        currencyFormat = currencyData.formats[symbol] || '$#,##0.00';
                        console.log(` Default subsidiary ID: ${defaultSubsidiaryId}, Currency: ${symbol}`);
                    }
                    
                    // Now get the subsidiary name
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            // Find the parent subsidiary by ID (not by name keywords)
                            const parentSub = lookups.subsidiaries.find(s => s.id === defaultSubsidiaryId);
                            if (parentSub) {
                                // Add "(Consolidated)" suffix for clarity
                                defaultSubsidiary = parentSub.name + ' (Consolidated)';
                            } else {
                                // Fallback: look for one with "(Consolidated)" already in name
                                const consolidated = lookups.subsidiaries.find(s => 
                                    s.name.toLowerCase().includes('consolidated')
                                );
                                defaultSubsidiary = consolidated ? consolidated.name : lookups.subsidiaries[0].name;
                            }
                        }
                    }
                    
                    if (!defaultSubsidiary) {
                        defaultSubsidiary = 'Parent Company (Consolidated)';
                    }
                    console.log(` Default subsidiary: ${defaultSubsidiary} (ID: ${defaultSubsidiaryId})`);
                } catch (e) {
                    console.warn('Subsidiary lookup failed, using defaults:', e.message);
                    defaultSubsidiary = 'Parent Company (Consolidated)';
                }
                
                // Step 3: Build Excel structure
                updateProgress(45, ' Step 3 of 6: Building Structure', 'Creating sections and headers...');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    try {
                        sheet.name = "Income Statement";
                        await context.sync();
                    } catch (e) {}
                    
                    // Remove gridlines for cleaner look
                    try {
                        sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {
                        console.warn('Could not hide gridlines');
                    }
                    
                    let currentRow = 1;
                    
                    // ========== ROW 1-2: PARAMETERS ==========
                    // Title with dynamic year reference
                    const titleCell = sheet.getRange("A1");
                    titleCell.formulas = [['="Income Statement For: "&P3']];
                    await context.sync();
                    
                    try {
                        titleCell.format.font.bold = true;
                        titleCell.format.font.size = 18;
                        titleCell.format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 2: PARAMETER LABELS (above values) ==========
                    sheet.getRange("P2").values = [["YEAR"]];
                    sheet.getRange("Q2").values = [["Subsidiary"]];
                    sheet.getRange("R2").values = [["Department"]];
                    sheet.getRange("S2").values = [["Location"]];
                    sheet.getRange("T2").values = [["Class"]];
                    sheet.getRange("U2").values = [["Acct Book"]];
                    sheet.getRange("V2").values = [["Structure Sync"]];
                    await context.sync();
                    
                    // Style parameter labels
                    try {
                        const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                        for (const cell of labelCells) {
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                            sheet.getRange(cell).format.font.size = 10;
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: PARAMETER VALUES (below labels) ==========
                    // Set sync trackers BEFORE context.sync() to prevent race condition with change listeners
                    lastSyncedYear = String(currentYear);
                    lastSyncedSubsidiary = defaultSubsidiary;
                    
                    sheet.getRange("P3").values = [[currentYear]];
                    sheet.getRange("Q3").values = [[defaultSubsidiary]];
                    sheet.getRange("R3").values = [[""]];  // Department - empty by default
                    sheet.getRange("S3").values = [[""]];  // Location - empty by default
                    sheet.getRange("T3").values = [[""]];  // Class - empty by default
                    sheet.getRange("U3").values = [[""]];  // Accounting Book - empty by default (uses Primary Book)
                    sheet.getRange("V3").values = [["TRUE"]];
                    await context.sync();
                    
                    // Style parameter value cells
                    try {
                        const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                        for (const cell of valueCells) {
                            sheet.getRange(cell).format.fill.color = "#0AE2C1";
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // NOTE: Filter cell comments removed - caused errors on Mac
                    
                    // ========== ROW 4: KPI METRICS DASHBOARD ==========
                    // Set row height for KPI cards
                    try {
                        sheet.getRange("4:4").format.rowHeight = 50;
                        await context.sync();
                    } catch (e) {}
                    
                    // Merge cells for each KPI card (3 columns each)
                    try {
                        sheet.getRange("A4:C4").merge();
                        sheet.getRange("D4:F4").merge();
                        sheet.getRange("G4:I4").merge();
                        sheet.getRange("J4:L4").merge();
                        await context.sync();
                    } catch (e) {}
                    
                    // KPI formulas with wildcards for robust matching
                    // Revenue card - searches for any cell containing "Total Revenue"
                    sheet.getRange("A4").formulas = [['=" YTD REVENUE\n"&TEXT(SUMIF(B:B,"*Total Revenue*",O:O),"#,##0")&"\nTotal Revenue YTD"']];
                    // Gross Margin card
                    sheet.getRange("D4").formulas = [['=" GROSS MARGIN\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Gross Profit*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nGross Profit / Revenue"']];
                    // Net Income card  
                    sheet.getRange("G4").formulas = [['=" NET INCOME\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Net Income*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nNet Income / Revenue"']];
                    // OpEx Ratio card
                    sheet.getRange("J4").formulas = [['=" OPEX RATIO\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Operating Expenses*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nOpEx / Revenue"']];
                    await context.sync();
                    
                    // Style KPI cards
                    try {
                        // Revenue card - Green
                        sheet.getRange("A4:C4").format.font.bold = true;
                        sheet.getRange("A4:C4").format.font.size = 11;
                        sheet.getRange("A4:C4").format.font.color = "#FFFFFF";
                        sheet.getRange("A4:C4").format.fill.color = "#22C55E";
                        sheet.getRange("A4:C4").format.horizontalAlignment = "Center";
                        sheet.getRange("A4:C4").format.verticalAlignment = "Center";
                        sheet.getRange("A4:C4").format.wrapText = true;
                        
                        // Gross Margin card - Gold/Yellow
                        sheet.getRange("D4:F4").format.font.bold = true;
                        sheet.getRange("D4:F4").format.font.size = 11;
                        sheet.getRange("D4:F4").format.font.color = "#000000";
                        sheet.getRange("D4:F4").format.fill.color = "#FBBF24";
                        sheet.getRange("D4:F4").format.horizontalAlignment = "Center";
                        sheet.getRange("D4:F4").format.verticalAlignment = "Center";
                        sheet.getRange("D4:F4").format.wrapText = true;
                        
                        // Net Income card - Red
                        sheet.getRange("G4:I4").format.font.bold = true;
                        sheet.getRange("G4:I4").format.font.size = 11;
                        sheet.getRange("G4:I4").format.font.color = "#FFFFFF";
                        sheet.getRange("G4:I4").format.fill.color = "#EF4444";
                        sheet.getRange("G4:I4").format.horizontalAlignment = "Center";
                        sheet.getRange("G4:I4").format.verticalAlignment = "Center";
                        sheet.getRange("G4:I4").format.wrapText = true;
                        
                        // OpEx Ratio card - Purple
                        sheet.getRange("J4:L4").format.font.bold = true;
                        sheet.getRange("J4:L4").format.font.size = 11;
                        sheet.getRange("J4:L4").format.font.color = "#FFFFFF";
                        sheet.getRange("J4:L4").format.fill.color = "#8B5CF6";
                        sheet.getRange("J4:L4").format.horizontalAlignment = "Center";
                        sheet.getRange("J4:L4").format.verticalAlignment = "Center";
                        sheet.getRange("J4:L4").format.wrapText = true;
                        
                        await context.sync();
                    } catch (e) {
                        console.warn('KPI styling warning:', e.message);
                    }
                    
                    // ========== ROW 5: COLUMN HEADERS ==========
                    const headerRow = 5;
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    
                    // Month headers with formula
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(67 + m); // C=67
                        const cell = sheet.getRange(`${colLetter}5`);
                        cell.formulas = [[`=DATE($P$3,${m + 1},1)`]];
                    }
                    
                    // YTD column
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    // Format headers
                    try {
                        const headerRange = sheet.getRange("A5:O5");
                        headerRange.format.font.bold = true;
                        headerRange.format.font.color = "#FFFFFF";
                        headerRange.format.fill.color = "#09235C";
                        
                        const monthRange = sheet.getRange("C5:N5");
                        monthRange.numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    currentRow = 6;
                    
                    // Helper to write section header
                    const writeSectionHeader = async (text, row) => {
                        const cell = sheet.getRange(`A${row}`);
                        cell.values = [[text]];
                        await context.sync();
                        try {
                            const range = sheet.getRange(`A${row}:O${row}`);
                            range.format.font.bold = true;
                            range.format.font.color = "#09235C";
                            range.format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    // Helper to write account row
                    const writeAccountRow = async (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).formulas = [[`=XAVI.NAME($A${row})`]];  // Reference account number for drag-ability
                        
                        // Balance formulas for each month (header row is now 5)
                        // Use direct cell reference - XAVI.BALANCE handles date conversion internally
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            const cell = sheet.getRange(`${colLetter}${row}`);
                            cell.formulas = [[`=XAVI.BALANCE($A${row},${colLetter}$5,${colLetter}$5,$Q$3,$R$3,$S$3,$T$3,$U$3)`]];
                        }
                        
                        // YTD formula
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    // Helper to write subtotal row
                    const writeSubtotalRow = async (text, startRow, endRow, row, isBold = true) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        
                        // Sum formulas for each column
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${row}`).formulas = [[`=SUM(${colLetter}${startRow}:${colLetter}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        
                        await context.sync();
                        
                        if (isBold) {
                            try {
                                const range = sheet.getRange(`A${row}:O${row}`);
                                range.format.font.bold = true;
                                // Add top border
                                range.format.borders.getItem('EdgeTop').style = 'Continuous';
                                await context.sync();
                            } catch (e) {}
                        }
                    };
                    
                    // Helper to create worksheet-scoped named range
                    // Named ranges make formulas robust against row changes from Structure Sync
                    const createNamedRange = async (name, row) => {
                        try {
                            // Delete existing name first (in case of re-sync)
                            try {
                                const existingName = sheet.names.getItem(name);
                                existingName.delete();
                                await context.sync();
                            } catch (e) {
                                // Name doesn't exist, that's fine
                            }
                            
                            // Create named range for data columns C:O (13 columns for 12 months + YTD)
                            const range = sheet.getRange(`C${row}:O${row}`);
                            sheet.names.add(name, range);
                            await context.sync();
                            console.log(` Created named range: ${name}  Row ${row}`);
                        } catch (e) {
                            console.warn(` Could not create named range ${name}:`, e.message);
                        }
                    };
                    
                    // Track row positions for calculations
                    let revenueStartRow, revenueEndRow, revenueTotalRow;
                    let cogsStartRow, cogsEndRow, cogsTotalRow;
                    let grossProfitRow;
                    let expenseStartRow, expenseEndRow, expenseTotalRow;
                    let operatingIncomeRow;
                    let othIncomeStartRow, othIncomeEndRow, othIncomeTotalRow;
                    let othExpenseStartRow, othExpenseEndRow, othExpenseTotalRow;
                    let netIncomeRow;
                    
                    updateProgress(50, ' Step 4 of 6: Writing Data', 'Adding Revenue accounts...');
                    
                    // ========== REVENUE SECTION ==========
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow);
                        currentRow++;
                        revenueStartRow = currentRow;
                        
                        for (const acct of categories.income) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        revenueEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', revenueStartRow, revenueEndRow, currentRow);
                        revenueTotalRow = currentRow;
                        await createNamedRange('_Total_Revenue', currentRow);
                        currentRow += 2; // Blank row after
                    }
                    
                    updateProgress(60, ' Step 4 of 6: Writing Data', 'Adding Cost of Sales...');
                    
                    // ========== COST OF SALES SECTION ==========
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow);
                        currentRow++;
                        cogsStartRow = currentRow;
                        
                        for (const acct of categories.cogs) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        cogsEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', cogsStartRow, cogsEndRow, currentRow);
                        cogsTotalRow = currentRow;
                        await createNamedRange('_Total_COGS', currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== GROSS PROFIT ROW ==========
                    // Always create Gross Profit row using named ranges with IFERROR for missing sections
                    if (revenueTotalRow || cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        // Use IFERROR(@INDIRECT()) to handle missing sections gracefully
                        // LET formula: cleaner, more efficient than INDIRECT
                        const gpFormula = '=LET(rev,IFERROR(@_Total_Revenue,0),cogs,IFERROR(@_Total_COGS,0),IF(cogs<0,ABS(rev)+ABS(cogs),ABS(rev)-ABS(cogs)))';
                        for (let m = 0; m < 13; m++) { // C through O (all 13 columns)
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${currentRow}`).formulas = [[gpFormula]];
                        }
                        await context.sync();
                        
                        try {
                            const gpRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                            gpRange.format.font.bold = true;
                            gpRange.format.fill.color = "#D4E6F1";
                            gpRange.format.borders.getItem('EdgeTop').style = 'Double';
                            gpRange.format.borders.getItem('EdgeBottom').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                        
                        grossProfitRow = currentRow;
                        await createNamedRange('_Gross_Profit', currentRow);
                        currentRow += 2;
                    }
                    
                    updateProgress(70, ' Step 4 of 6: Writing Data', 'Adding Operating Expenses...');
                    
                    // ========== OPERATING EXPENSES SECTION ==========
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow);
                        currentRow++;
                        expenseStartRow = currentRow;
                        
                        for (const acct of categories.expense) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        expenseEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', expenseStartRow, expenseEndRow, currentRow);
                        expenseTotalRow = currentRow;
                        await createNamedRange('_Total_Operating_Expenses', currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== OPERATING INCOME ROW ==========
                    // Always create if we have Gross Profit or Expenses
                    if (grossProfitRow || expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        // LET formula: cleaner, more efficient than INDIRECT
                        const oiFormula = '=LET(gp,IFERROR(@_Gross_Profit,0),opex,IFERROR(@_Total_Operating_Expenses,0),IF(opex<0,ABS(gp)+ABS(opex),ABS(gp)-ABS(opex)))';
                        for (let m = 0; m < 13; m++) { // C through O
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${currentRow}`).formulas = [[oiFormula]];
                        }
                        await context.sync();
                        
                        try {
                            const oiRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                            oiRange.format.font.bold = true;
                            oiRange.format.fill.color = "#D5F5E3";
                            oiRange.format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                        
                        operatingIncomeRow = currentRow;
                        await createNamedRange('_Operating_Income', currentRow);
                        currentRow += 2;
                    }
                    
                    updateProgress(80, ' Step 4 of 6: Writing Data', 'Adding Other Income/Expense...');
                    
                    // ========== OTHER INCOME SECTION ==========
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow);
                        currentRow++;
                        othIncomeStartRow = currentRow;
                        
                        for (const acct of categories.othIncome) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        othIncomeEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', othIncomeStartRow, othIncomeEndRow, currentRow);
                        othIncomeTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Income', currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== OTHER EXPENSE SECTION ==========
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow);
                        currentRow++;
                        othExpenseStartRow = currentRow;
                        
                        for (const acct of categories.othExpense) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        othExpenseEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', othExpenseStartRow, othExpenseEndRow, currentRow);
                        othExpenseTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Expense', currentRow);
                        currentRow += 2;
                    }
                    
                    updateProgress(90, ' Step 4 of 6: Writing Data', 'Calculating Net Income...');
                    
                    // ========== NET INCOME ROW ==========
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    
                    // NET INCOME - LET formula: cleaner, more efficient than INDIRECT
                    // Falls back: Operating Income  Gross Profit  Total Revenue  0
                    // Note: We ADD otherExp because it's already signed correctly (negative for expenses, positive for credits)
                    // Net Income = Operating Income + Other Income - Other Expense
                    // Simple formula works because raw data has correct signs:
                    // - Positive expenses hurt income (subtract)
                    // - Negative expenses (credits/gains) help income (subtracting negative = adding)
                    const niFormula = '=LET(opInc,IFERROR(@_Operating_Income,IFERROR(@_Gross_Profit,IFERROR(@_Total_Revenue,0))),otherInc,IFERROR(@_Total_Other_Income,0),otherExp,IFERROR(@_Total_Other_Expense,0),opInc+otherInc-otherExp)';
                    
                    for (let m = 0; m < 13; m++) { // C through O
                        const colLetter = String.fromCharCode(67 + m);
                        sheet.getRange(`${colLetter}${currentRow}`).formulas = [[niFormula]];
                    }
                    await context.sync();
                    
                    try {
                        const niRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                        niRange.format.font.bold = true;
                        niRange.format.font.size = 12;
                        niRange.format.fill.color = "#09235C";
                        niRange.format.font.color = "#FFFFFF";
                        niRange.format.borders.getItem('EdgeTop').style = 'Double';
                        await context.sync();
                    } catch (e) {}
                    
                    netIncomeRow = currentRow;
                    await createNamedRange('_Net_Income', currentRow);
                    
                    updateProgress(95, ' Step 5 of 6: Formatting', 'Applying currency formats...');
                    
                    // Format all number cells with the correct currency symbol (data starts at row 6)
                    try {
                        const dataRange = sheet.getRange(`C6:O${netIncomeRow}`);
                        const rows = netIncomeRow - 5;
                        const cols = 13; // C through O
                        // Use the currency format determined from subsidiary
                        const formatArray = Array(rows).fill(null).map(() => Array(cols).fill(currencyFormat));
                        dataRange.numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {
                        console.warn('Format warning:', e.message);
                    }
                    
                    // Freeze header rows (rows 1-5: title, params, sync flag, blank, headers)
                    try {
                        sheet.freezePanes.freezeRows(5);
                        await context.sync();
                    } catch (e) {}
                    
                    // Auto-fit columns
                    try {
                        sheet.getRange("A:O").format.autofitColumns();
                        await context.sync();
                    } catch (e) {}
                    
                    updateProgress(100, ' Complete!', 'Your Income Statement is ready!');
                });
                
                // Cleanup the progress overlay but show a "waiting for formulas" message
                clearInterval(tipInterval);
                
                // Update overlay to show we're waiting for formulas
                const overlayTitle = overlay.querySelector('h2');
                const overlaySubtitle = overlay.querySelector('.loading-subtitle');
                const overlayStep = overlay.querySelector('.loading-step');
                const overlayStepDesc = overlay.querySelector('.loading-step-desc');
                const overlayProgress = overlay.querySelector('.progress-bar-fill');
                const overlayProgressText = overlay.querySelector('.progress-text');
                
                if (overlayTitle) overlayTitle.textContent = ' Step 6 of 6: Tidying Up';
                if (overlaySubtitle) overlaySubtitle.innerHTML = 'Tidying up the results. This is the last step...';
                if (overlayStep) overlayStep.innerHTML = '<span class="spreadsheet-animation"></span> Tucking everything into place...';
                if (overlayStepDesc) overlayStepDesc.textContent = '';
                
                // Hide any other loading overlays and status bars
                hideLoading();
                hideStatus();
                
                // Wait for formulas to complete - no sub-messages, just "Tidying Up"
                await waitForFormulasToComplete(120000, null);
                
                // Auto-fit columns AFTER all formulas have resolved
                await autoFitColumns();
                
                // NOW remove the overlay and show success
                overlay.remove();
                
                // Success message - show as dismissible overlay
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                showReportSuccessOverlay('Income Statement', {
                    totalAccounts,
                    elapsedTime: elapsedSeconds,
                    sections: [
                        { name: 'Revenue', count: categories.income.length },
                        { name: 'Cost of Sales', count: categories.cogs.length },
                        { name: 'Operating Expenses', count: categories.expense.length },
                        { name: 'Other Income/Expense', count: categories.othIncome.length + categories.othExpense.length }
                    ],
                    tips: [
                        { type: 'warning', icon: '', title: 'Verify:', text: 'Auto-generated from NetSuite. Review before official use.' },
                        { type: 'info', icon: '', title: 'Year:', text: 'Edit <strong>P3</strong> to change year. Structure auto-syncs.' },
                        { type: 'info', icon: '', title: 'Subsidiary:', text: 'Edit <strong>Q3</strong> to filter. Also supports Dept, Class, Location.' }
                    ]
                });
                
                // Clear sync flag after a delay to let any queued change events fire first
                setTimeout(() => {
                    isSyncInProgress = false;
                    console.log(' Sync protection cleared - ready for user changes');
                }, 3000);
                
                // Close Quick Start accordion after successful generation
                closeQuickStart();
                
                // After report is built, scan for subsidiary cells and apply currency formatting
                setTimeout(async () => {
                    try {
                        console.log(' Full Income Statement: Scanning for subsidiary cells and formatting currencies...');
                        await scanForSubsidiaryCells();
                        await autoFormatCurrencies();
                    } catch (e) {
                        console.warn('Post-report currency format failed:', e.message);
                    }
                    
                    // Release the sync lock after currency formatting is done
                    setTimeout(() => {
                        isSyncInProgress = false;
                        console.log(' Full Income Statement: Filter change handlers unblocked - report generation complete');
                    }, 1000);
                }, 2000); // Wait for formulas to start evaluating
                
            } catch (error) {
                console.error('Income Statement error:', error);
                clearInterval(tipInterval);
                if (document.getElementById('incomeStatementOverlay')) {
                    document.getElementById('incomeStatementOverlay').remove();
                }
                progress.style.display = 'block';
                progress.textContent = ` Error: ${error.message}`;
                
                // Clear sync flag after a delay on error too
                setTimeout(() => {
                    isSyncInProgress = false;
                    console.log(' Full Income Statement: Filter change handlers unblocked (error case)');
                }, 3000);
            }
        }

        // ================================================================
        // GENERATE BUDGET REPORT - Load existing budget from NetSuite
        // ================================================================
        
        async function generateBudgetReport() {
            const progress = document.getElementById('guideMeProgress');
            const budgetYear = 2011;  // For testing - only year with budget data
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Set flag to prevent auto-sync from triggering during generation
            isSyncInProgress = true;
            
            // Create loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'budgetReportOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building Your Budget Report</h2>
                <div class="loading-subtitle">
                     Loading budget data from NetSuite...
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="budgetProgressBar"></div>
                    </div>
                    <div class="progress-text" id="budgetProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="budgetStep">Connecting to NetSuite...</div>
                <div class="loading-step-desc" id="budgetStepDesc">Establishing secure connection</div>
            `;
            document.body.appendChild(overlay);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('budgetProgressBar');
                const text = document.getElementById('budgetProgressText');
                const stepEl = document.getElementById('budgetStep');
                const descEl = document.getElementById('budgetStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            try {
                // Step 1: Get default subsidiary and budget categories
                updateProgress(5, ' Step 1 of 4: Loading Settings', 'Fetching subsidiary and budget categories...');
                
                let defaultSubsidiary = '';
                let defaultSubsidiaryId = '1';
                let currencyFormat = '$#,##0.00';
                let budgetCategory = '';
                let budgetCategoryId = '';
                
                try {
                    // Get currencies and default subsidiary
                    const currencyResponse = await fetch(`${SERVER_URL}/lookups/currencies`);
                    if (currencyResponse.ok) {
                        const currencyData = await currencyResponse.json();
                        defaultSubsidiaryId = currencyData.default_subsidiary || '1';
                        const symbol = currencyData.currencies[defaultSubsidiaryId] || '$';
                        currencyFormat = currencyData.formats[symbol] || '$#,##0.00';
                    }
                    
                    // Get subsidiary name
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            const parentSub = lookups.subsidiaries.find(s => s.id === defaultSubsidiaryId);
                            if (parentSub) {
                                defaultSubsidiary = parentSub.name + ' (Consolidated)';
                            } else {
                                defaultSubsidiary = lookups.subsidiaries[0].name;
                            }
                        }
                        
                        // Get most recent budget category
                        if (lookups.budgetCategories && lookups.budgetCategories.length > 0) {
                            // Use the last one (most recently created by ID)
                            const sortedCats = [...lookups.budgetCategories].sort((a, b) => 
                                parseInt(b.id) - parseInt(a.id)
                            );
                            budgetCategory = sortedCats[0].name;
                            budgetCategoryId = sortedCats[0].id;
                        }
                    }
                } catch (e) {
                    console.warn('Settings lookup failed:', e.message);
                    defaultSubsidiary = 'Parent Company (Consolidated)';
                }
                
                // Step 2: Fetch all budget data
                updateProgress(20, ' Step 2 of 4: Loading Budget Data', `Fetching budgets for ${budgetYear}...`);
                
                let artificialProgress = 20;
                const progressInterval = setInterval(() => {
                    if (artificialProgress < 50) {
                        artificialProgress += 3;
                        updateProgress(artificialProgress, ' Step 2 of 4: Loading Budget Data', 
                            'Querying NetSuite budget records...');
                    }
                }, 2000);
                
                const budgetUrl = new URL(`${SERVER_URL}/budget/all`);
                budgetUrl.searchParams.append('year', budgetYear);
                if (budgetCategoryId) budgetUrl.searchParams.append('category', budgetCategoryId);
                
                const budgetResponse = await fetch(budgetUrl);
                clearInterval(progressInterval);
                
                if (!budgetResponse.ok) {
                    throw new Error(`Failed to load budget data: ${budgetResponse.status}`);
                }
                
                const budgetData = await budgetResponse.json();
                const allBudgets = budgetData.accounts || {};
                const accountNames = budgetData.account_names || {};
                const accountTypes = budgetData.account_types || {};
                
                console.log(`Budget Report: Loaded ${Object.keys(allBudgets).length} accounts with budget data`);
                
                if (Object.keys(allBudgets).length === 0) {
                    throw new Error(`No budget data found for year ${budgetYear}. Check that budgets exist in NetSuite.`);
                }
                
                // Step 3: Categorize accounts by type
                updateProgress(55, ' Step 3 of 4: Categorizing', 'Grouping accounts by type...');
                
                const categories = {
                    income: [],
                    othIncome: [],
                    cogs: [],
                    expense: [],
                    othExpense: [],
                    other: []  // For any non-P&L accounts with budgets
                };
                
                for (const acctNum in allBudgets) {
                    const monthData = allBudgets[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const monthValues = monthNames.map(m => monthData[`${m} ${budgetYear}`] || 0);
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown',
                            monthValues: monthValues,
                            total: monthValues.reduce((a, b) => a + b, 0)
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') {
                            categories.income.push(acctInfo);
                        } else if (acctType === 'othincome') {
                            categories.othIncome.push(acctInfo);
                        } else if (acctType === 'cogs' || acctType === 'cost of goods sold') {
                            categories.cogs.push(acctInfo);
                        } else if (acctType === 'expense') {
                            categories.expense.push(acctInfo);
                        } else if (acctType === 'othexpense') {
                            categories.othExpense.push(acctInfo);
                        } else {
                            categories.other.push(acctInfo);
                        }
                    }
                }
                
                // Sort each category by account number
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                const totalAccounts = Object.values(categories).reduce((sum, arr) => sum + arr.length, 0);
                console.log(`Budget Report: Income=${categories.income.length}, OthIncome=${categories.othIncome.length}, COGS=${categories.cogs.length}, Expense=${categories.expense.length}, OthExpense=${categories.othExpense.length}, Other=${categories.other.length}`);
                
                // Step 4: Build Excel structure
                updateProgress(65, ' Step 4 of 4: Building Report', 'Creating budget worksheet...');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    try {
                        sheet.name = "Budget Report";
                        await context.sync();
                    } catch (e) {}
                    
                    // Remove gridlines
                    try {
                        sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {}
                    
                    let currentRow = 1;
                    
                    // ========== ROW 1: TITLE ==========
                    const titleCell = sheet.getRange("A1");
                    titleCell.formulas = [['="Budget Report For: "&P3&" - "&R3']];
                    await context.sync();
                    
                    try {
                        titleCell.format.font.bold = true;
                        titleCell.format.font.size = 18;
                        titleCell.format.font.color = "#8B5CF6";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 2: PARAMETER LABELS ==========
                    sheet.getRange("P2").values = [["YEAR"]];
                    sheet.getRange("Q2").values = [["Subsidiary"]];
                    sheet.getRange("R2").values = [["Budget Category"]];
                    sheet.getRange("S2").values = [["Department"]];
                    sheet.getRange("T2").values = [["Location"]];
                    sheet.getRange("U2").values = [["Class"]];
                    sheet.getRange("V2").values = [["Acct Book"]];
                    await context.sync();
                    
                    // Style parameter labels
                    try {
                        const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                        for (const cell of labelCells) {
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#8B5CF6";
                            sheet.getRange(cell).format.font.size = 10;
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: PARAMETER VALUES ==========
                    // Set sync trackers BEFORE context.sync() to prevent race condition
                    lastSyncedYear = String(budgetYear);
                    lastSyncedSubsidiary = defaultSubsidiary;
                    
                    sheet.getRange("P3").values = [[budgetYear]];
                    sheet.getRange("Q3").values = [[defaultSubsidiary]];
                    sheet.getRange("R3").values = [[budgetCategory || 'All Categories']];
                    sheet.getRange("S3").values = [[""]];  // Department - empty by default
                    sheet.getRange("T3").values = [[""]];  // Location - empty by default
                    sheet.getRange("U3").values = [[""]];  // Class - empty by default
                    sheet.getRange("V3").values = [[""]];  // Accounting Book - empty by default
                    await context.sync();
                    
                    // Style parameter value cells
                    try {
                        const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                        for (const cell of valueCells) {
                            sheet.getRange(cell).format.fill.color = "#DDD6FE";  // Light purple
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#5B21B6";
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // NOTE: Budget cell comments removed - caused errors on Mac
                    
                    // ========== ROW 4: BLANK ==========
                    currentRow = 4;
                    
                    // ========== ROW 5: COLUMN HEADERS ==========
                    const headerRow = 5;
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    
                    // Month headers with formula based on year
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(67 + m); // C=67
                        const cell = sheet.getRange(`${colLetter}5`);
                        cell.formulas = [[`=DATE($P$3,${m + 1},1)`]];
                    }
                    
                    // YTD column
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    // Format headers
                    try {
                        const headerRange = sheet.getRange("A5:O5");
                        headerRange.format.font.bold = true;
                        headerRange.format.font.color = "#FFFFFF";
                        headerRange.format.fill.color = "#8B5CF6";  // Purple theme
                        
                        const monthRange = sheet.getRange("C5:N5");
                        monthRange.numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 
                                                   'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    currentRow = 6;
                    
                    // Helper to write section header
                    const writeSectionHeader = async (text, row) => {
                        const cell = sheet.getRange(`A${row}`);
                        cell.values = [[text]];
                        await context.sync();
                        try {
                            const range = sheet.getRange(`A${row}:O${row}`);
                            range.format.font.bold = true;
                            range.format.font.color = "#5B21B6";
                            range.format.fill.color = "#EDE9FE";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    // Helper to write account row with BUDGET formulas
                    // Parameters: $Q$3=Subsidiary, $S$3=Department, $U$3=Location, $T$3=Class, $R$3=BudgetCategory
                    const writeAccountRow = (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).formulas = [[`=XAVI.NAME($A${row})`]];
                        
                        // BUDGET formulas for each month
                        // =XAVI.BUDGET(account, fromPeriod, toPeriod, subsidiary, department, location, classId, accountingBook, budgetCategory)
                        // Cell refs: Q3=Subsidiary, S3=Dept, T3=Location, U3=Class, V3=AcctBook, R3=BudgetCategory
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            const cell = sheet.getRange(`${colLetter}${row}`);
                            // Full formula with all parameters as cell references
                            cell.formulas = [[`=XAVI.BUDGET($A${row},${colLetter}$5,${colLetter}$5,$Q$3,$S$3,$T$3,$U$3,$V$3,$R$3)`]];
                        }
                        
                        // YTD formula
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    // Helper to write subtotal row
                    const writeSubtotalRow = async (text, startRow, endRow, row) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${row}`).formulas = [[`=SUM(${colLetter}${startRow}:${colLetter}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        
                        await context.sync();
                        
                        try {
                            const range = sheet.getRange(`A${row}:O${row}`);
                            range.format.font.bold = true;
                            range.format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    let accountsWritten = 0;
                    
                    // ========== REVENUE SECTION ==========
                    updateProgress(70, ' Step 4 of 4: Writing Data', 'Adding Revenue budgets...');
                    
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.income) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total Revenue Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== COST OF SALES SECTION ==========
                    updateProgress(75, ' Step 4 of 4: Writing Data', 'Adding COGS budgets...');
                    
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.cogs) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total COGS Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== EXPENSE SECTION ==========
                    updateProgress(80, ' Step 4 of 4: Writing Data', 'Adding Expense budgets...');
                    
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.expense) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== OTHER INCOME SECTION ==========
                    updateProgress(85, ' Step 4 of 4: Writing Data', 'Adding Other Income budgets...');
                    
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.othIncome) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Income Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== OTHER EXPENSE SECTION ==========
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSES BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.othExpense) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Expenses Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    // ========== OTHER ACCOUNTS SECTION (non-P&L) ==========
                    if (categories.other.length > 0) {
                        await writeSectionHeader('OTHER ACCOUNTS BUDGET', currentRow);
                        currentRow++;
                        const startRow = currentRow;
                        
                        for (const acct of categories.other) {
                            writeAccountRow(acct, currentRow);
                            currentRow++;
                            accountsWritten++;
                        }
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Budget', startRow, currentRow - 1, currentRow);
                        currentRow += 2;
                    }
                    
                    updateProgress(90, ' Finishing', 'Applying formatting...');
                    
                    // Set column widths
                    try {
                        sheet.getRange("A:A").format.columnWidth = 80;
                        sheet.getRange("B:B").format.columnWidth = 200;
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}:${colLetter}`).format.columnWidth = 100;
                        }
                        sheet.getRange("O:O").format.columnWidth = 100;
                        await context.sync();
                    } catch (e) {}
                    
                    // Apply currency format to data cells
                    try {
                        const dataRange = sheet.getRange(`C6:O${currentRow}`);
                        dataRange.numberFormat = [[currencyFormat]];
                        await context.sync();
                    } catch (e) {}
                    
                    await context.sync();
                    
                    console.log(`Budget Report: Created with ${accountsWritten} accounts`);
                });
                
                updateProgress(100, ' Complete!', `Budget report created with ${totalAccounts} accounts`);
                
                // Scan for subsidiary cells and auto-format currencies
                setTimeout(async () => {
                    try {
                        console.log(' Budget Report: Scanning for subsidiary cells and formatting currencies...');
                        await scanForSubsidiaryCells();
                    await autoFormatCurrencies();
                    } catch (e) {
                        console.warn('Post-report currency format failed:', e.message);
                    }
                }, 500);
                
                // Close overlay after short delay
                setTimeout(() => {
                    overlay.remove();
                    showToast({
                        title: 'Budget Report Created!',
                        message: `Loaded ${totalAccounts} accounts with budget data for ${budgetYear}`,
                        type: 'success',
                        icon: ''
                    });
                    
                    // Close Quick Start accordion after successful generation
                    closeQuickStart();
                }, 1500);
                
            } catch (error) {
                console.error('Budget Report error:', error);
                overlay.remove();
                showToast({
                    title: 'Budget Report Failed',
                    message: error.message,
                    type: 'error',
                    icon: ''
                });
            } finally {
                // Clear sync flag after a delay to let any queued change events fire first
                setTimeout(() => {
                    isSyncInProgress = false;
                    console.log(' Sync protection cleared - ready for user changes');
                }, 3000);
            }
        }
        
        // ================================================================
        // SMART PRELOAD - Scan sheet and preload only used BS accounts
        // Much faster than preloading all 200+ accounts
        // ================================================================
        
        async function smartPreloadFromSheet() {
            console.log(' SMART PRELOAD: Scanning sheet for BS formulas...');
            
            showLoading(' Scanning Sheet', 'Finding Balance Sheet formulas...', 10);
            
            try {
                // Step 1: Scan sheet for XAVI.BALANCE and XAVI.BALANCECHANGE formulas
                const formulaData = await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load('formulas');
                    await context.sync();
                    
                    const accounts = new Set();
                    const periods = new Set();
                    const formulas = usedRange.formulas;
                    
                    // Regex to match XAVI.BALANCE and XAVI.BALANCECHANGE formulas
                    const balanceRegex = /XAVI\.BALANCE(?:CHANGE)?\s*\(\s*"?([^",)]+)"?\s*,\s*"?([^",)]*)"?\s*,\s*"?([^",)]+)"?/gi;
                    
                    for (let row = 0; row < formulas.length; row++) {
                        for (let col = 0; col < formulas[row].length; col++) {
                            const cell = formulas[row][col];
                            if (typeof cell === 'string' && cell.toUpperCase().includes('XAVI.BALANCE')) {
                                let match;
                                balanceRegex.lastIndex = 0;
                                while ((match = balanceRegex.exec(cell)) !== null) {
                                    const account = match[1].replace(/"/g, '').trim();
                                    const fromPeriod = match[2].replace(/"/g, '').trim();
                                    const toPeriod = match[3].replace(/"/g, '').trim();
                                    
                                    // Skip cell references (like $A$2) - we want actual values
                                    if (account && !account.includes('$')) {
                                        accounts.add(account);
                                    }
                                    if (toPeriod && !toPeriod.includes('$')) {
                                        periods.add(toPeriod);
                                    }
                                    if (fromPeriod && !fromPeriod.includes('$') && fromPeriod !== toPeriod) {
                                        periods.add(fromPeriod);
                                    }
                                }
                            }
                        }
                    }
                    
                    return {
                        accounts: Array.from(accounts),
                        periods: Array.from(periods)
                    };
                });
                
                console.log(` Found ${formulaData.accounts.length} accounts, ${formulaData.periods.length} periods`);
                console.log('   Accounts:', formulaData.accounts.slice(0, 10).join(', '), formulaData.accounts.length > 10 ? '...' : '');
                console.log('   Periods:', formulaData.periods.join(', '));
                
                if (formulaData.accounts.length === 0) {
                    hideLoading();
                    showToast({
                        title: 'No Formulas Found',
                        message: 'No XAVI.BALANCE formulas detected on this sheet. Add some formulas first!',
                        type: 'warning',
                        duration: 5000
                    });
                    return;
                }
                
                if (formulaData.periods.length === 0) {
                    hideLoading();
                    showToast({
                        title: 'No Periods Found',
                        message: 'Could not detect periods from formulas. Try using the manual preload.',
                        type: 'warning',
                        duration: 5000
                    });
                    return;
                }
                
                updateLoading(' Identifying BS Accounts', 30, `Checking ${formulaData.accounts.length} accounts...`);
                
                // Step 2: Identify which accounts are Balance Sheet accounts
                const accountTypesResponse = await fetch(`${SERVER_URL}/accounts/types`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accounts: formulaData.accounts })
                });
                
                if (!accountTypesResponse.ok) {
                    throw new Error('Failed to get account types');
                }
                
                const accountTypes = await accountTypesResponse.json();
                const bsAccounts = formulaData.accounts.filter(acct => {
                    const type = accountTypes[acct];
                    return type && ['Bank', 'AcctRec', 'OthCurrAsset', 'FixedAsset', 'OthAsset', 
                                   'AcctPay', 'CreditCard', 'OthCurrLiab', 'LongTermLiab', 
                                   'Equity', 'RetainEarn'].includes(type);
                });
                
                console.log(` Found ${bsAccounts.length} Balance Sheet accounts out of ${formulaData.accounts.length} total`);
                
                if (bsAccounts.length === 0) {
                    hideLoading();
                    showToast({
                        title: 'No BS Accounts',
                        message: 'All accounts on this sheet are P&L accounts (fast by default). No preload needed!',
                        type: 'success',
                        duration: 5000
                    });
                    return;
                }
                
                // Step 3: Preload only the BS accounts found
                updateLoading(
                    ` Preloading ${bsAccounts.length} BS Accounts`,
                    40,
                    `Loading ${bsAccounts.length} accounts  ${formulaData.periods.length} periods...`
                );
                
                // Call targeted preload endpoint
                const preloadResponse = await fetch(`${SERVER_URL}/batch/bs_preload_targeted`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accounts: bsAccounts,
                        periods: formulaData.periods
                    })
                });
                
                if (!preloadResponse.ok) {
                    // Handle timeout
                    if ([524, 522, 523, 504].includes(preloadResponse.status)) {
                        throw new Error(`Timeout preloading. Try fewer accounts or use manual preload.`);
                    }
                    throw new Error(`Preload failed: HTTP ${preloadResponse.status}`);
                }
                
                let result;
                try {
                    result = await preloadResponse.json();
                } catch (e) {
                    throw new Error('Timeout - server response incomplete');
                }
                
                // Cache results
                if (result.balances) {
                    const cacheEntries = {};
                    for (const [account, periodBalances] of Object.entries(result.balances)) {
                        if (typeof periodBalances === 'object') {
                            for (const [pName, balance] of Object.entries(periodBalances)) {
                                cacheEntries[`balance:${account}::${pName}`] = { value: balance, timestamp: Date.now() };
                            }
                        }
                    }
                    try {
                        const existing = JSON.parse(localStorage.getItem('xavi_balance_cache') || '{}');
                        const merged = { ...existing, ...cacheEntries };
                        localStorage.setItem('xavi_balance_cache', JSON.stringify(merged));
                        console.log(` Cached ${Object.keys(cacheEntries).length} balances`);
                    } catch (e) { }
                }
                
                hideLoading();
                
                showToast({
                    title: ' Smart Preload Complete!',
                    message: `${bsAccounts.length} BS accounts  ${formulaData.periods.length} periods cached. Formulas will now be instant!`,
                    type: 'success',
                    duration: 8000
                });
                
            } catch (error) {
                console.error('Smart preload error:', error);
                hideLoading();
                showToast({
                    title: 'Smart Preload Failed',
                    message: error.message,
                    type: 'error',
                    duration: 8000
                });
            }
        }
        
        // ================================================================
        // PRELOAD BALANCE SHEET ACCOUNTS (ALL)
        // Performance tool: Batch query ALL BS accounts to cache (~70s)
        // After preload, individual XAVI.BALANCE formulas for BS accounts are instant
        // ================================================================
        
        async function preloadBalanceSheet() {
            console.log(' PRELOAD BALANCE SHEET: Starting...');
            
            // Get periods from input fields
            const periods = [];
            const period1Input = document.getElementById('bsPreloadPeriod1');
            const period2Input = document.getElementById('bsPreloadPeriod2');
            
            const period1 = period1Input?.value?.trim() || 'Dec 2024';
            const period2 = period2Input?.value?.trim();
            
            periods.push(period1);
            if (period2) periods.push(period2);
            
            const periodLabel = periods.length > 1 ? periods.join(' & ') : periods[0];
            // Sequential loading: ~70s per period to avoid Cloudflare timeout
            const expectedTime = periods.length > 1 ? '~140 seconds (sequential to avoid timeout)' : '~70 seconds';
            
            console.log(` BS Preload: ${periods.length} period(s): ${periodLabel}`);
            
            // Show loading overlay with educational BS-specific messaging
            // Messages explain WHY this takes time and what benefits the user gets
            
            showLoading(
                ' Analyzing Account History',
                `Preparing to load all Balance Sheet accounts for ${periodLabel}...`,
                5
            );
            
            // Message 1: Explain the "why" - this is the most important
            setTimeout(() => {
                updateLoading(
                    'Crunching Numbers from the Beginning of Time',
                    15,
                    ' Unlike P&L accounts, Balance Sheet accounts are cumulative  we calculate every transaction since your company started!'
                );
            }, 3000);
            
            // Message 2: Explain caching benefit
            setTimeout(() => {
                updateLoading(
                    'Building Your Balance Sheet Cache',
                    25,
                    ' Good news: We\'re caching all 200+ accounts at once. After this, individual lookups will be instant!'
                );
            }, 8000);
            
            // Message 3: Fun fact about BS accounts
            setTimeout(() => {
                updateLoading(
                    'Processing Assets, Liabilities & Equity',
                    35,
                    ' Fun fact: The Balance Sheet equation (A = L + E) dates back to 1494, invented by Luca Pacioli!'
                );
            }, 15000);
            
            // Message 4: Technical insight
            setTimeout(() => {
                updateLoading(
                    'Running Consolidated Currency Translation',
                    45,
                    ' For multi-currency, we\'re applying exchange rates at each subsidiary level  just like NetSuite\'s CONSOLIDATE function.'
                );
            }, 22000);
            
            // Message 5: Progress update
            setTimeout(() => {
                updateLoading(
                    'Still Working  This is Normal!',
                    55,
                    ` Typical time: ${expectedTime}. A single account would take ~70s anyway  batching saves you hours!`
                );
            }, 32000);
            
            // Message 6: Almost there
            setTimeout(() => {
                updateLoading(
                    'Finalizing Account Balances',
                    70,
                    periods.length > 1 
                        ? ' Loading multiple periods is smart  one query now beats two 70-second waits later!' 
                        : ' Processing Bank, AR, AP, Fixed Assets, and all other BS account types...'
                );
            }, 45000);
            
            // Message 7: Tip for future
            setTimeout(() => {
                updateLoading(
                    'Almost Done  Caching Results',
                    85,
                    ' TIP: Need fresh numbers later? Click "Refresh All"  we\'ll recalc everything in one clean pass.'
                );
            }, 55000);
            
            // Message 8: Final stretch
            setTimeout(() => {
                updateLoading(
                    'Finishing Up...',
                    95,
                    ' Your Balance Sheet formulas will now resolve in milliseconds instead of minutes!'
                );
            }, 70000);
            
            try {
                const startTime = Date.now();
                
                // Load periods SEQUENTIALLY to avoid Cloudflare timeout
                // Each period takes ~70s, Cloudflare times out at ~100s
                let totalAccountCount = 0;
                const allBalances = {};
                const cacheEntries = {};
                
                for (let i = 0; i < periods.length; i++) {
                    const period = periods[i];
                    const periodNum = i + 1;
                    
                    console.log(` Loading period ${periodNum}/${periods.length}: ${period}`);
                    updateLoading(
                        `Loading Period ${periodNum}/${periods.length}: ${period}`,
                        Math.round(10 + (i / periods.length) * 70),
                        ` Each period takes ~70 seconds to calculate from inception...`
                    );
                    
                    const response = await fetch(`${SERVER_URL}/batch/bs_preload`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            periods: [period]  // Send ONE period at a time to avoid timeout
                        })
                    });
                    
                    if (!response.ok) {
                        // Handle Cloudflare timeout errors (524, 522, 523) and other errors
                        const isTimeout = [524, 522, 523, 504, 408].includes(response.status);
                        if (isTimeout) {
                            throw new Error(`TIMEOUT loading ${period}. The query took too long. This is a known limitation during development - will be resolved in production.`);
                        }
                        // Try to get error message from response
                        let errorMsg = `HTTP ${response.status}`;
                        try {
                            const text = await response.text();
                            if (text && text.startsWith('{')) {
                                const errorData = JSON.parse(text);
                                errorMsg = errorData.message || errorData.error || errorMsg;
                            }
                        } catch (e) { /* ignore parse errors */ }
                        throw new Error(`Server error loading ${period}: ${errorMsg}`);
                    }
                    
                    // Parse response JSON with error handling
                    let result;
                    try {
                        const text = await response.text();
                        result = JSON.parse(text);
                    } catch (parseError) {
                        console.error('Failed to parse response:', parseError);
                        throw new Error(`TIMEOUT loading ${period}. Server response was incomplete. This is a known dev limitation.`);
                    }
                    console.log(` Period ${periodNum} loaded: ${result.account_count} accounts`);
                    
                    totalAccountCount = result.account_count;
                    
                    // Merge balances from this period
                    if (result.balances) {
                        for (const [account, periodBalances] of Object.entries(result.balances)) {
                            if (!allBalances[account]) allBalances[account] = {};
                            if (typeof periodBalances === 'object') {
                                for (const [pName, balance] of Object.entries(periodBalances)) {
                                    allBalances[account][pName] = balance;
                                    cacheEntries[`balance:${account}::${pName}`] = { value: balance, timestamp: Date.now() };
                                }
                            } else {
                                allBalances[account][period] = periodBalances;
                                cacheEntries[`balance:${account}::${period}`] = { value: periodBalances, timestamp: Date.now() };
                            }
                        }
                    }
                }
                
                const elapsedSec = ((Date.now() - startTime) / 1000).toFixed(1);
                
                console.log(` BS PRELOAD COMPLETE: ${totalAccountCount} accounts  ${periods.length} periods in ${elapsedSec}s`);
                
                // Store in localStorage for functions.js to use
                try {
                    const existing = JSON.parse(localStorage.getItem('xavi_balance_cache') || '{}');
                    const merged = { ...existing, ...cacheEntries };
                    localStorage.setItem('xavi_balance_cache', JSON.stringify(merged));
                    console.log(` Cached ${Object.keys(cacheEntries).length} BS balances to localStorage`);
                } catch (e) {
                    console.warn('Could not cache to localStorage:', e.message);
                }
                
                hideLoading();
                
                const periodCount = periods.length;
                const result = { account_count: totalAccountCount, balances: allBalances };
                const timeSaved = Math.round(result.account_count * 70 / 60); // ~70s per account if done individually
                
                showToast({
                    title: ' Balance Sheet Ready!',
                    message: `${result.account_count} accounts cached! Individual lookups now instant.`,
                    type: 'success',
                    duration: 10000,
                    icon: ''
                });
                
                // Show an info message with helpful stats and tips
                showOnboardingMessage(
                    ' Balance Sheet Cache Ready!',
                    `<div style="line-height: 1.6;">
                        <p><strong>${result.account_count}</strong> Balance Sheet accounts  <strong>${periodCount}</strong> period(s) loaded in <strong>${elapsedSec} seconds</strong>.</p>
                        
                        <div style="margin-top: 12px; padding: 10px; background: rgba(16,185,129,0.1); border-radius: 8px; border-left: 3px solid #10B981;">
                            <strong style="color: #10B981;"> Time Saved:</strong> ~${timeSaved} minutes!<br>
                            <span style="font-size: 12px; opacity: 0.8;">Each BS account would take ~70 seconds individually.</span>
                        </div>
                        
                        <p style="margin-top: 12px;"><strong>What's cached:</strong></p>
                        <ul style="margin: 4px 0 0 16px; font-size: 13px;">
                            <li>Bank & Cash accounts</li>
                            <li>Accounts Receivable & Payable</li>
                            <li>Fixed Assets & Depreciation</li>
                            <li>All Liability accounts</li>
                            <li>Equity & Retained Earnings</li>
                        </ul>
                        
                        <div style="margin-top: 12px; padding: 8px; background: rgba(59,130,246,0.1); border-radius: 6px;">
                            <strong style="color: #3B82F6;"> Tips:</strong><br>
                            <span style="font-size: 12px;"> Cache lasts 5 minutes  re-run if formulas slow down<br>
                             Use "Refresh All" for latest numbers anytime<br>
                             P&L accounts don't need preload (they're fast!)</span>
                        </div>
                    </div>`,
                    'success'
                );
                
            } catch (error) {
                console.error(' BS Preload failed:', error);
                hideLoading();
                
                showToast({
                    title: 'Preload Failed',
                    message: error.message,
                    type: 'error',
                    duration: 10000,
                    icon: ''
                });
            }
        }

        // ================================================================
        // SYNC INCOME STATEMENT STRUCTURE FOR NEW YEAR
        // Only works on auto-generated sheets with Structure Sync = TRUE
        // ================================================================
        
        async function syncIncomeStatementStructure() {
            const statusEl = document.getElementById('refreshStatus');
            
            try {
                // Step 1: Check if current sheet has the sync flag
                let syncEnabled = false;
                let targetYear = new Date().getFullYear();
                let currentSubsidiary = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Read V2 to check for sync marker label (Structure Sync is now in column V)
                    const markerCell = sheet.getRange("V2");
                    markerCell.load("values");
                    
                    // Read V3 for sync flag value
                    const syncCell = sheet.getRange("V3");
                    syncCell.load("values");
                    
                    // Read P3 for year
                    const yearCell = sheet.getRange("P3");
                    yearCell.load("values");
                    
                    // Read Q3 for subsidiary
                    const subCell = sheet.getRange("Q3");
                    subCell.load("values");
                    
                    await context.sync();
                    
                    const markerValue = String(markerCell.values[0][0] || '').toLowerCase();
                    const syncValue = String(syncCell.values[0][0] || '').toUpperCase();
                    const yearValue = yearCell.values[0][0];
                    const subValue = subCell.values[0][0];
                    
                    console.log('Sync check - Marker:', markerValue, 'Sync:', syncValue, 'Year:', yearValue);
                    
                    // Check if this is an auto-generated sheet
                    if (markerValue.includes('structure sync') || markerValue.includes('')) {
                        if (syncValue === 'TRUE' || syncValue === 'YES' || syncValue === '1') {
                            syncEnabled = true;
                            targetYear = parseInt(yearValue) || new Date().getFullYear();
                            currentSubsidiary = subValue || '';
                        } else {
                            // Sync is disabled
                            statusEl.innerHTML = `
                                <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                                    <strong style="color: #92400e;"> Structure Sync Disabled</strong><br>
                                    <span style="font-size: 12px; color: #78350f;">
                                        Cell B3 is set to "${syncValue}". Change it to TRUE to enable structure sync.
                                    </span>
                                </div>
                            `;
                            return;
                        }
                    } else {
                        // Not an auto-generated sheet
                        statusEl.innerHTML = `
                            <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                                <strong style="color: #dc2626;"> Not an Auto-Generated Sheet</strong><br>
                                <span style="font-size: 12px; color: #991b1b;">
                                    This feature only works on Income Statements created by "Full Income Statement" generator.
                                    The current sheet doesn't have the sync marker in cell A3.
                                </span>
                            </div>
                        `;
                        return;
                    }
                });
                
                if (!syncEnabled) {
                    return; // Message already shown above
                }
                
                // Step 2: Confirm with user
                const confirmed = confirm(
                    `Sync Structure for Year ${targetYear}?\n\n` +
                    `This will regenerate the Income Statement with all accounts that have data in ${targetYear}.\n\n` +
                    `Your YEAR and Subsidiary parameters will be preserved.\n\n` +
                    `Click OK to continue or Cancel to abort.`
                );
                
                if (!confirmed) {
                    statusEl.innerHTML = `
                        <div style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <span style="color: #6b7280;">Sync cancelled.</span>
                        </div>
                    `;
                    return;
                }
                
                // Step 3: Show loading and regenerate
                statusEl.innerHTML = `
                    <div style="background: #dbeafe; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #1e40af;"> Syncing Structure...</strong><br>
                        <span style="font-size: 12px; color: #1e3a8a;">
                            Fetching accounts with data for ${targetYear}...
                        </span>
                    </div>
                `;
                
                // Get currency format for the selected subsidiary
                let currencyFormat = '$#,##0.00';  // Default to USD
                try {
                    const currencyData = await getCurrencyData();
                    if (currencyData && currentSubsidiary) {
                        const subsidiaryNameToId = await getSubsidiaryLookup();
                        const subId = /^\d+$/.test(currentSubsidiary) ? 
                            currentSubsidiary : 
                            (subsidiaryNameToId[currentSubsidiary.toLowerCase()] || currencyData.default_subsidiary);
                        const symbol = currencyData.currencies[subId] || currencyData.currencies[currencyData.default_subsidiary] || '$';
                        currencyFormat = currencyData.formats[symbol] || '$#,##0.00';
                        console.log(` Sync currency: "${currentSubsidiary}"  ID ${subId}  ${symbol}  ${currencyFormat}`);
                    }
                } catch (e) {
                    console.warn('Currency lookup failed:', e.message);
                }
                
                // Fetch accounts for the target year AND selected subsidiary
                // This ensures we get accounts that have data for THIS subsidiary
                console.log(`Syncing structure for year ${targetYear}, subsidiary: "${currentSubsidiary}"`);
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: targetYear,
                        subsidiary: currentSubsidiary || '',  // Use selected subsidiary!
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                // DEBUG: Log what we received
                console.log(` Structure sync received ${Object.keys(allBalances).length} accounts from API`);
                console.log(`   Account types received: ${Object.keys(accountTypes).length}`);
                
                // Categorize accounts
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                const categories = {
                    income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                };
                
                let skippedZeroData = 0;
                let categorizedCount = 0;
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown'
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') { categories.income.push(acctInfo); categorizedCount++; }
                        else if (acctType === 'othincome') { categories.othIncome.push(acctInfo); categorizedCount++; }
                        else if (acctType === 'cogs' || acctType === 'cost of goods sold') { categories.cogs.push(acctInfo); categorizedCount++; }
                        else if (acctType === 'expense') { categories.expense.push(acctInfo); categorizedCount++; }
                        else if (acctType === 'othexpense') { categories.othExpense.push(acctInfo); categorizedCount++; }
                        else {
                            console.warn(`    Unknown account type for ${acctNum}: "${acctType}"`);
                        }
                    } else {
                        skippedZeroData++;
                    }
                }
                
                console.log(`   Categorized: ${categorizedCount}, Skipped (zero data): ${skippedZeroData}`);
                console.log(`   COGS accounts: ${categories.cogs.map(a => a.number).join(', ')}`)
                
                // Sort categories
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                statusEl.innerHTML = `
                    <div style="background: #dbeafe; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #1e40af;"> Rebuilding Sheet...</strong><br>
                        <span style="font-size: 12px; color: #1e3a8a;">
                            Found ${totalAccounts} accounts with data for ${targetYear}. Creating structure...
                        </span>
                    </div>
                `;
                
                // Step 4: Clear sheet and rebuild
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Clear existing content (keep name)
                    const usedRange = sheet.getUsedRange();
                    usedRange.clear();
                    await context.sync();
                    
                    let currentRow = 1;
                    
                    // ========== ROW 1: TITLE ==========
                    // Title with dynamic year reference
                    sheet.getRange("A1").formulas = [['="Income Statement For: "&P3']];
                    await context.sync();
                    try {
                        sheet.getRange("A1").format.font.bold = true;
                        sheet.getRange("A1").format.font.size = 18;
                        sheet.getRange("A1").format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 2: PARAMETER LABELS (above values) ==========
                    sheet.getRange("P2").values = [["YEAR"]];
                    sheet.getRange("Q2").values = [["Subsidiary"]];
                    sheet.getRange("R2").values = [["Department"]];
                    sheet.getRange("S2").values = [["Location"]];
                    sheet.getRange("T2").values = [["Class"]];
                    sheet.getRange("U2").values = [["Acct Book"]];
                    sheet.getRange("V2").values = [["Structure Sync"]];
                    await context.sync();
                    
                    try {
                        const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                        for (const cell of labelCells) {
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                            sheet.getRange(cell).format.font.size = 10;
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: PARAMETER VALUES (below labels) ==========
                    // Set sync trackers BEFORE context.sync() to prevent race condition
                    lastSyncedYear = String(targetYear);
                    lastSyncedSubsidiary = currentSubsidiary || 'Celigo Inc. (Consolidated)';
                    
                    sheet.getRange("P3").values = [[targetYear]];
                    sheet.getRange("Q3").values = [[currentSubsidiary || 'Celigo Inc. (Consolidated)']];
                    sheet.getRange("R3").values = [[""]];  // Department - empty by default
                    sheet.getRange("S3").values = [[""]];  // Location - empty by default
                    sheet.getRange("T3").values = [[""]];  // Class - empty by default
                    sheet.getRange("U3").values = [[""]];  // Accounting Book - empty by default
                    sheet.getRange("V3").values = [["TRUE"]];
                    await context.sync();
                    
                    try {
                        // Style input cells with teal background
                        const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                        for (const cell of valueCells) {
                            sheet.getRange(cell).format.fill.color = "#0AE2C1";
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // NOTE: Filter cell comments removed - caused errors on Mac
                    
                    // ========== ROW 4: KPI METRICS DASHBOARD ==========
                    try {
                        sheet.getRange("4:4").format.rowHeight = 50;
                        await context.sync();
                    } catch (e) {}
                    
                    try {
                        sheet.getRange("A4:C4").merge();
                        sheet.getRange("D4:F4").merge();
                        sheet.getRange("G4:I4").merge();
                        sheet.getRange("J4:L4").merge();
                        await context.sync();
                    } catch (e) {}
                    
                    sheet.getRange("A4").formulas = [['=" YTD REVENUE\n"&TEXT(SUMIF(B:B,"*Total Revenue*",O:O),"#,##0")&"\nTotal Revenue YTD"']];
                    sheet.getRange("D4").formulas = [['=" GROSS MARGIN\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Gross Profit*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nGross Profit / Revenue"']];
                    sheet.getRange("G4").formulas = [['=" NET INCOME\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Net Income*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nNet Income / Revenue"']];
                    sheet.getRange("J4").formulas = [['=" OPEX RATIO\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Operating Expenses*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nOpEx / Revenue"']];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A4:C4").format.font.bold = true;
                        sheet.getRange("A4:C4").format.font.size = 11;
                        sheet.getRange("A4:C4").format.font.color = "#FFFFFF";
                        sheet.getRange("A4:C4").format.fill.color = "#22C55E";
                        sheet.getRange("A4:C4").format.horizontalAlignment = "Center";
                        sheet.getRange("A4:C4").format.verticalAlignment = "Center";
                        sheet.getRange("A4:C4").format.wrapText = true;
                        sheet.getRange("D4:F4").format.font.bold = true;
                        sheet.getRange("D4:F4").format.font.size = 11;
                        sheet.getRange("D4:F4").format.font.color = "#000000";
                        sheet.getRange("D4:F4").format.fill.color = "#FBBF24";
                        sheet.getRange("D4:F4").format.horizontalAlignment = "Center";
                        sheet.getRange("D4:F4").format.verticalAlignment = "Center";
                        sheet.getRange("D4:F4").format.wrapText = true;
                        sheet.getRange("G4:I4").format.font.bold = true;
                        sheet.getRange("G4:I4").format.font.size = 11;
                        sheet.getRange("G4:I4").format.font.color = "#FFFFFF";
                        sheet.getRange("G4:I4").format.fill.color = "#EF4444";
                        sheet.getRange("G4:I4").format.horizontalAlignment = "Center";
                        sheet.getRange("G4:I4").format.verticalAlignment = "Center";
                        sheet.getRange("G4:I4").format.wrapText = true;
                        sheet.getRange("J4:L4").format.font.bold = true;
                        sheet.getRange("J4:L4").format.font.size = 11;
                        sheet.getRange("J4:L4").format.font.color = "#FFFFFF";
                        sheet.getRange("J4:L4").format.fill.color = "#8B5CF6";
                        sheet.getRange("J4:L4").format.horizontalAlignment = "Center";
                        sheet.getRange("J4:L4").format.verticalAlignment = "Center";
                        sheet.getRange("J4:L4").format.wrapText = true;
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 5: HEADERS ==========
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}5`).formulas = [[`=DATE($P$3,${m + 1},1)`]];
                    }
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A5:O5").format.font.bold = true;
                        sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                        sheet.getRange("A5:O5").format.fill.color = "#09235C";
                        sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    // Set column widths to prevent parameter text from affecting month columns
                    try {
                        sheet.getRange("A:A").format.columnWidth = 80;  // Account #
                        sheet.getRange("B:B").format.columnWidth = 180; // Account Name
                        sheet.getRange("C:N").format.columnWidth = 85;  // Month columns (fixed width)
                        sheet.getRange("O:O").format.columnWidth = 90;  // YTD Total
                        await context.sync();
                    } catch (e) {}
                    
                    currentRow = 6;
                    
                    // Helper functions (same as generate)
                    const writeSectionHeader = async (text, row) => {
                        sheet.getRange(`A${row}`).values = [[text]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    const writeAccountRow = (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).formulas = [[`=XAVI.NAME($A${row})`]];  // Reference account number for drag-ability
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},${col}$5,${col}$5,$Q$3,$R$3,$S$3,$T$3,$U$3)`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    const writeSubtotalRow = async (text, startRow, endRow, row) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    // Helper to create named ranges
                    const createNamedRange = async (name, row) => {
                        try {
                            try { sheet.names.getItem(name).delete(); await context.sync(); } catch (e) {}
                            sheet.names.add(name, sheet.getRange(`C${row}:O${row}`));
                            await context.sync();
                        } catch (e) { console.warn(`Could not create ${name}:`, e.message); }
                    };
                    
                    let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                    let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                    
                    // REVENUE
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                        revenueTotalRow = currentRow;
                        await createNamedRange('_Total_Revenue', currentRow);
                        currentRow++;
                        currentRow++; // blank
                    }
                    
                    // COGS
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                        cogsTotalRow = currentRow;
                        await createNamedRange('_Total_COGS', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // GROSS PROFIT - Always create if we have revenue or COGS
                    if (revenueTotalRow || cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        // LET formula: cleaner, more efficient than INDIRECT
                        const gpFormula = '=LET(rev,IFERROR(@_Total_Revenue,0),cogs,IFERROR(@_Total_COGS,0),IF(cogs<0,ABS(rev)+ABS(cogs),ABS(rev)-ABS(cogs)))';
                        for (let m = 0; m < 13; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[gpFormula]];
                        }
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                            await context.sync();
                        } catch (e) {}
                        grossProfitRow = currentRow;
                        await createNamedRange('_Gross_Profit', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // OPERATING EXPENSES
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                        expenseTotalRow = currentRow;
                        await createNamedRange('_Total_Operating_Expenses', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // OPERATING INCOME - Always create if we have gross profit or expenses
                    if (grossProfitRow || expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        // LET formula: cleaner, more efficient than INDIRECT
                        const oiFormula = '=LET(gp,IFERROR(@_Gross_Profit,0),opex,IFERROR(@_Total_Operating_Expenses,0),IF(opex<0,ABS(gp)+ABS(opex),ABS(gp)-ABS(opex)))';
                        for (let m = 0; m < 13; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[oiFormula]];
                        }
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                            await context.sync();
                        } catch (e) {}
                        operatingIncomeRow = currentRow;
                        await createNamedRange('_Operating_Income', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // OTHER INCOME
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                        othIncomeTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Income', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // OTHER EXPENSE
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                        othExpenseTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Expense', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // NET INCOME - LET formula: ADD otherExp (already signed correctly)
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    // Net Income = Operating Income + Other Income - Other Expense
                    // Simple formula works because raw data has correct signs:
                    // - Positive expenses hurt income (subtract)
                    // - Negative expenses (credits/gains) help income (subtracting negative = adding)
                    const niFormula = '=LET(opInc,IFERROR(@_Operating_Income,IFERROR(@_Gross_Profit,IFERROR(@_Total_Revenue,0))),otherInc,IFERROR(@_Total_Other_Income,0),otherExp,IFERROR(@_Total_Other_Expense,0),opInc+otherInc-otherExp)';
                    for (let m = 0; m < 13; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}${currentRow}`).formulas = [[niFormula]];
                    }
                    await context.sync();
                    
                    try {
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                        await context.sync();
                    } catch (e) {}
                    netIncomeRow = currentRow;
                    await createNamedRange('_Net_Income', currentRow);
                    
                    // Format numbers with correct currency
                    try {
                        const rows = netIncomeRow - 5;
                        const formatArray = Array(rows).fill(null).map(() => Array(13).fill(currencyFormat));
                        sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {}
                    
                    // Freeze
                    try {
                        sheet.freezePanes.freezeRows(5);
                        await context.sync();
                    } catch (e) {}
                });
                
                // Success
                statusEl.innerHTML = `
                    <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #065f46;"> Structure Synced!</strong><br>
                        <span style="font-size: 12px; color: #047857;">
                            Rebuilt Income Statement for ${targetYear} with ${totalAccounts} accounts.
                        </span>
                    </div>
                `;
                
            } catch (error) {
                console.error('Sync error:', error);
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Sync Failed</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
            }
        }

        // ================================================================
        // PRE-LOAD SHEET DATA - Cache data for selected date range
        // ================================================================

        function dismissPreload() {
            document.getElementById('preloadCard').classList.add('preload-hidden');
            localStorage.setItem('preloadDismissed', 'true');
        }

        function showPreload() {
            if (localStorage.getItem('preloadDismissed') !== 'true') {
                document.getElementById('preloadCard').classList.remove('preload-hidden');
            }
        }

        async function runPreloadSheet() {
            const btn = document.getElementById('preloadBtn');
            const btnText = document.getElementById('preloadBtnText');
            const progress = document.getElementById('preloadProgress');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Excel History Facts - shown during loading
            const excelHistory = [
                { year: '1985', fact: 'Excel 1.0 was released for Mac  before Windows even existed! Microsoft saw the Mac as the future of computing.' },
                { year: '1987', fact: 'Excel came to Windows, two years after Mac. There was no Windows Excel 1.0  it started at version 2.0!' },
                { year: '1988', fact: 'Excel 2.0 introduced the toolbar, revolutionizing how users interacted with spreadsheet commands.' },
                { year: '1990', fact: 'Excel 3.0 added 3D charts, drawing tools, and the ability to link worksheets  a game-changer for finance teams.' },
                { year: '1992', fact: 'Excel 4.0 introduced XLM macros, the predecessor to VBA. Some companies still use them today!' },
                { year: '1993', fact: 'Excel 5.0 brought VBA (Visual Basic for Applications), transforming Excel from a spreadsheet into a programming platform.' },
                { year: '1995', fact: 'Excel 95 was the first 32-bit version, bundled with Office 95 for Windows 95  the birth of modern Office.' },
                { year: '1997', fact: 'Excel 97 could handle 65,536 rows  4x more than before. Finance teams rejoiced!' },
                { year: '1998-2001', fact: 'Excel for Mac was discontinued for 3 years! Mac users had to use Virtual PC to run Windows Excel.' },
                { year: '2003', fact: 'Excel 2003 introduced XML data import and improved list functionality  early steps toward Power Query.' },
                { year: '2007', fact: 'Excel 2007 expanded to 1,048,576 rows (1 million+) and introduced the ribbon interface that we still use today.' },
                { year: '2010', fact: 'Excel Web App launched  the first time you could edit spreadsheets in a browser. Collaboration was born.' },
                { year: '2013', fact: 'Excel 2013 added Flash Fill  automatic pattern recognition that feels like magic. Try it!' },
                { year: '2016', fact: 'Power Query was integrated directly into Excel, making data transformation accessible to everyone.' },
                { year: '2019', fact: 'XLOOKUP finally arrived! After 35+ years, VLOOKUP got a worthy successor with backwards lookup capability.' },
                { year: '2020', fact: 'Dynamic arrays were introduced  formulas that automatically spill results into adjacent cells. Revolutionary!' },
                { year: '2023', fact: 'Excel added Python support! You can now write Python code directly in cells alongside your formulas.' },
                { year: 'Fun Fact', fact: 'The name "Excel" was originally trademarked by another company. Microsoft had to license it!' },
                { year: 'Fun Fact', fact: 'The $ symbol for absolute references ($A$1) has been used since Lotus 1-2-3 in 1983.' },
                { year: 'Fun Fact', fact: 'Excel can calculate faster than you think  it processes about 1 billion cells per second on modern hardware.' }
            ];
            let historyIndex = 0;

            btn.disabled = true;
            btnText.textContent = 'Reading selection...';
            
            // CRITICAL: Signal formulas to wait via localStorage
            // This works across contexts (taskpane iframe  custom functions)
            try {
                localStorage.setItem('netsuite_preload_status', 'running');
                localStorage.setItem('netsuite_preload_timestamp', Date.now().toString());
                console.log('Pre-load:  Preload status set - formulas will wait');
            } catch (e) {
                console.warn('Pre-load:  Could not set preload status:', e);
            }

            try {
                // Step 1: Read selected range from Excel and build period strings
                let selectedPeriods = [];  // ["Dec 2024", "Jan 2025", ...]
                let selectedYears = new Set();

                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    range.load(['values', 'valueTypes']);
                    await context.sync();

                    const values = range.values;
                    console.log('Pre-load: Selected range values:', values);

                    // Parse dates from the selection
                    for (const row of values) {
                        for (const cell of row) {
                            let dateValue = null;

                            // Handle different date formats
                            if (typeof cell === 'number' && cell > 0) {
                                // Excel serial date number
                                const excelEpoch = new Date(1899, 11, 30);
                                dateValue = new Date(excelEpoch.getTime() + cell * 86400000);
                            } else if (typeof cell === 'string') {
                                // Try to parse string as date
                                const parsed = new Date(cell);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed;
                                }
                                // Also try "Mon YYYY" format
                                const monthYearMatch = cell.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/i);
                                if (monthYearMatch) {
                                    const monthIndex = monthNames.findIndex(m => m.toLowerCase() === monthYearMatch[1].toLowerCase());
                                    if (monthIndex !== -1) {
                                        dateValue = new Date(parseInt(monthYearMatch[2]), monthIndex, 1);
                                    }
                                }
                            } else if (cell instanceof Date) {
                                dateValue = cell;
                            }

                            if (dateValue && !isNaN(dateValue.getTime())) {
                                const year = dateValue.getFullYear();
                                const month = dateValue.getMonth();
                                if (year >= 2000 && year <= 2100) { // Reasonable year range
                                    // Convert to period string like "Dec 2024"
                                    const periodStr = `${monthNames[month]} ${year}`;
                                    if (!selectedPeriods.includes(periodStr)) {
                                        selectedPeriods.push(periodStr);
                                    }
                                    selectedYears.add(year);
                                }
                            }
                        }
                    }
                });

                if (selectedPeriods.length === 0) {
                    throw new Error('No valid dates found in selection. Please select cells containing dates (e.g., 1/1/2025 or "Jan 2025").');
                }

                // Sort periods chronologically (handles both "Mon YYYY" and year-only "YYYY" formats)
                selectedPeriods.sort((a, b) => {
                    // Parse period a
                    let aMonth, aYear;
                    if (/^\d{4}$/.test(a)) {
                        aMonth = 0; aYear = parseInt(a); // Year-only: treat as Jan
                    } else {
                        [aMonth, aYear] = [monthNames.indexOf(a.split(' ')[0]), parseInt(a.split(' ')[1])];
                    }
                    // Parse period b
                    let bMonth, bYear;
                    if (/^\d{4}$/.test(b)) {
                        bMonth = 0; bYear = parseInt(b); // Year-only: treat as Jan
                    } else {
                        [bMonth, bYear] = [monthNames.indexOf(b.split(' ')[0]), parseInt(b.split(' ')[1])];
                    }
                    const aIdx = aMonth + aYear * 12;
                    const bIdx = bMonth + bYear * 12;
                    return aIdx - bIdx;
                });

                const yearsArray = Array.from(selectedYears).sort();
                console.log('Pre-load: Years spanned:', yearsArray);

                // Estimate time based on periods (not full years!)
                const periodCount = selectedPeriods.length;
                const estimatedTime = periodCount <= 4 ? '30-45 seconds' : 
                                     periodCount <= 8 ? '45-60 seconds' : 
                                     periodCount <= 13 ? '60-90 seconds' : '90-120 seconds';

                // Create and show loading overlay
                const overlay = document.createElement('div');
                overlay.className = 'preload-overlay';
                overlay.id = 'preloadOverlay';
                overlay.innerHTML = `
                    <div class="loading-spinner"></div>
                    <h2>Pre-loading ${periodCount} Periods</h2>
                    <div class="loading-subtitle" style="max-width: 320px; margin-bottom: 24px;">
                         Estimated time: <strong>${estimatedTime}</strong><br>
                        <span style="opacity: 0.7; font-size: 12px;">(Much faster than loading ${yearsArray.length * 12} months from full years!)</span>
                    </div>
                    
                    <div class="progress-container" style="max-width: 320px; margin-bottom: 20px;">
                        <div class="progress-bar-bg" style="background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden;">
                            <div class="progress-bar-fill" id="preloadProgressBar" style="height: 8px; background: linear-gradient(90deg, #7dffb3, #4ade80); width: 0%;"></div>
                        </div>
                        <div class="progress-text" id="preloadProgressText" style="font-size: 12px; opacity: 0.7; margin-top: 8px;">0% complete</div>
                    </div>
                    
                    <div class="loading-step" id="preloadStep" style="color: #7dffb3; font-weight: 600;">Connecting to NetSuite...</div>
                    <div class="loading-step-desc" id="preloadStepDesc" style="font-size: 12px; opacity: 0.7; margin-top: 6px; max-width: 300px;">
                        Loading: ${selectedPeriods.slice(0, 3).join(', ')}${selectedPeriods.length > 3 ? ` + ${selectedPeriods.length - 3} more` : ''}
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 14px; margin-top: 24px; max-width: 320px; text-align: left;">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; margin-bottom: 4px;"> Why the wait?</div>
                        <div style="font-size: 12px; line-height: 1.5; opacity: 0.85;">
                            Balance Sheet accounts are calculated from the <strong>beginning of time</strong>  every transaction ever recorded affects the balance. This one-time load saves minutes later!
                        </div>
                    </div>
                    
                    <div class="history-section">
                        <div class="history-label"> Excel History</div>
                        <div class="history-year" id="preloadHistoryYear">${excelHistory[0].year}</div>
                        <div class="history-fact" id="preloadHistoryFact">${excelHistory[0].fact}</div>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Rotate history facts every 4 seconds
                const historyInterval = setInterval(() => {
                    historyIndex = (historyIndex + 1) % excelHistory.length;
                    const yearEl = document.getElementById('preloadHistoryYear');
                    const factEl = document.getElementById('preloadHistoryFact');
                    if (yearEl && factEl) {
                        factEl.style.opacity = '0';
                        setTimeout(() => {
                            yearEl.textContent = excelHistory[historyIndex].year;
                            factEl.textContent = excelHistory[historyIndex].fact;
                            factEl.style.opacity = '1';
                        }, 200);
                    }
                }, 4000);

                const updateProgress = (percent, step, desc) => {
                    const bar = document.getElementById('preloadProgressBar');
                    const text = document.getElementById('preloadProgressText');
                    const stepEl = document.getElementById('preloadStep');
                    const descEl = document.getElementById('preloadStepDesc');
                    if (bar) bar.style.width = percent + '%';
                    if (text) text.textContent = percent + '% complete';
                    if (stepEl) stepEl.textContent = step;
                    if (descEl) descEl.textContent = desc;
                };

                // Step 2: Load data for specific periods only (optimized!)
                let allBalances = {};
                let allTypes = {};
                let allNames = {};
                
                updateProgress(5, ' Loading Data', `Fetching ${periodCount} periods for all accounts...`);
                
                // Use full_year_refresh for each year (same as formulas - works within timeout!)
                // This is more reliable than periods_refresh which can timeout on Cloudflare
                const yearsList = Array.from(selectedYears).sort();
                let yearProgress = 5;
                const progressPerYear = Math.floor(75 / yearsList.length);
                
                try {
                    for (let i = 0; i < yearsList.length; i++) {
                        const year = yearsList[i];
                        updateProgress(yearProgress, ' Loading Data', 
                            `Loading year ${year} (${i + 1}/${yearsList.length})...`);
                        
                        console.log(`Pre-load: Fetching year ${year}...`);
                        const startTime = Date.now();
                        
                        const response = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                                year: parseInt(year),
                            subsidiary: '',
                            department: '',
                            location: '',
                                class: '',
                                skip_bs: true  // FAST MODE: Skip BS accounts (load on-demand)
                        })
                    });

                    if (!response.ok) {
                            throw new Error(`Failed to load year ${year}: ${response.status}`);
                    }

                    const data = await response.json();
                        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                        const yearBalances = data.balances || {};
                        const accountCount = Object.keys(yearBalances).length;
                        
                        console.log(`Pre-load: Year ${year} loaded - ${accountCount} accounts in ${elapsed}s`);
                        
                        // Merge into allBalances
                        for (const acct in yearBalances) {
                            if (!allBalances[acct]) allBalances[acct] = {};
                            for (const period in yearBalances[acct]) {
                                allBalances[acct][period] = yearBalances[acct][period];
                            }
                        }
                        
                        // Merge types if available
                        if (data.account_types) {
                            Object.assign(allTypes, data.account_types);
                        }
                        
                        yearProgress += progressPerYear;
                    }
                    
                    console.log(`Pre-load: Total loaded - ${Object.keys(allBalances).length} accounts`);

                    // Fill in $0 for requested periods that have no data
                    for (const acctNum in allBalances) {
                        for (const period of selectedPeriods) {
                            if (allBalances[acctNum][period] === undefined) {
                                allBalances[acctNum][period] = 0;
                            }
                        }
                    }
                    
                    // Fetch account names if not already loaded
                    updateProgress(85, ' Loading Names', 'Fetching account names...');
                    try {
                        const namesResponse = await fetch(`${SERVER_URL}/account/preload_titles`);
                        if (namesResponse.ok) {
                            const namesData = await namesResponse.json();
                            allNames = namesData.titles || {};
                            console.log(`Pre-load: Loaded ${Object.keys(allNames).length} account names`);
                        }
                    } catch (namesError) {
                        console.warn('Pre-load: Could not fetch account names:', namesError.message);
                    }

                } catch (fetchError) {
                    console.error('Pre-load fetch error:', fetchError);
                    throw fetchError;
                }

                updateProgress(92, ' Preparing Data', 'Getting everything ready for fast analysis...');

                // Save to localStorage
                try {
                    const existingBalances = JSON.parse(localStorage.getItem('netsuite_balance_cache') || '{}');
                    const mergedBalances = { ...existingBalances };
                    
                    // Merge new balances with existing (overwrite same periods)
                    for (const acctNum in allBalances) {
                        if (!mergedBalances[acctNum]) {
                            mergedBalances[acctNum] = {};
                        }
                        Object.assign(mergedBalances[acctNum], allBalances[acctNum]);
                    }

                    const cacheJson = JSON.stringify(mergedBalances);
                    localStorage.setItem('netsuite_balance_cache', cacheJson);
                    localStorage.setItem('netsuite_balance_cache_timestamp', Date.now().toString());
                    
                    // Merge and save types
                    const existingTypes = JSON.parse(localStorage.getItem('netsuite_type_cache') || '{}');
                    localStorage.setItem('netsuite_type_cache', JSON.stringify({ ...existingTypes, ...allTypes }));
                    
                    // Merge and save names
                    const existingNames = JSON.parse(localStorage.getItem('netsuite_name_cache') || '{}');
                    localStorage.setItem('netsuite_name_cache', JSON.stringify({ ...existingNames, ...allNames }));

                    console.log(`Pre-load: Cached ${Object.keys(mergedBalances).length} accounts to localStorage`);

                    // Populate in-memory caches
                    if (typeof window.setFullYearCache === 'function') {
                        window.setFullYearCache(mergedBalances);
                    }
                    if (typeof window.setAccountTypeCache === 'function') {
                        window.setAccountTypeCache({ ...existingTypes, ...allTypes });
                    }
                    if (typeof window.setAccountNameCache === 'function') {
                        window.setAccountNameCache({ ...existingNames, ...allNames });
                    }
                    
                    // CRITICAL: Signal formulas that preload is complete via localStorage
                    localStorage.setItem('netsuite_preload_status', 'complete');
                } catch (cacheError) {
                    console.warn('Pre-load: Cache save warning:', cacheError);
                    // Still finish preload even if cache save fails
                    localStorage.setItem('netsuite_preload_status', 'complete');
                }

                updateProgress(100, ' P&L Complete!', 'Income/Expense accounts ready!');

                // Clean up overlay
                clearInterval(historyInterval);
                setTimeout(() => overlay.remove(), 500);
                    
                // Check if user wants Balance Sheet accounts too
                const includeBS = document.getElementById('includeBSCheckbox')?.checked || false;
                    const accountCount = Object.keys(allBalances).length;
                    
                // Show P&L success message
                    progress.style.display = 'block';
                
                if (includeBS) {
                    // Show P&L done, BS loading message
                    progress.innerHTML = ` <strong>P&L accounts ready!</strong> (${accountCount} accounts)<br><br>
                        <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid var(--anenome);">
                             <strong>Loading Balance Sheet...</strong><br>
                            <span style="font-size: 11px;">Cash, AR, AP, etc.  this takes 2-3 minutes</span><br>
                            <span id="bsLoadingStatus" style="font-size: 11px; color: var(--chrome);">Starting...</span>
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                             Start entering P&L formulas now  they'll resolve instantly!
                        </div>`;
                    progress.style.lineHeight = '1.6';
                    btnText.textContent = ' Loading BS...';
                    btn.style.background = 'var(--tidal-wave)';
                    
                    // Start BS loading in background
                    loadBalanceSheetInBackground(uniqueYears, progress, btn, btnText);
                } else {
                    // P&L only - show final success message
                    progress.innerHTML = ` <strong>You're all set!</strong><br><br>
                        <strong>${accountCount}</strong> Income/Expense accounts loaded<br>
                        <span style="font-size: 11px; color: #666;">${selectedPeriods.slice(0, 4).join(', ')}${selectedPeriods.length > 4 ? ` + ${selectedPeriods.length - 4} more` : ''}</span><br><br>
                        <div style="background: rgba(125, 255, 179, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #7dffb3;">
                             <strong>P&L accounts</strong> = instant results
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                             Need Balance Sheet? Check the box above and reload.
                        </div>`;
                    progress.style.lineHeight = '1.6';
                    btnText.textContent = ' Ready!';
                    btn.style.background = '#4CAF50';
                    btn.disabled = false;
                }

            } catch (error) {
                console.error('Pre-load error:', error);
                // Release any waiting formulas on error via localStorage
                localStorage.setItem('netsuite_preload_status', 'error');
                
                if (document.getElementById('preloadOverlay')) {
                    document.getElementById('preloadOverlay').remove();
                }
                
                // Provide user-friendly error messages
                let errorMessage = error.message;
                let helpTip = '';
                
                if (error.message.includes('524') || error.message.includes('timeout')) {
                    errorMessage = 'Request timed out';
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        <strong>Why this happens:</strong> NetSuite queries for Balance Sheet accounts can take several minutes. 
                        <strong>Try this:</strong> Your formulas will still work - they'll load data on-demand when you enter them.
                    </div>`;
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMessage = 'Could not reach server';
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        Check that the server is running and the tunnel URL is correct in your settings.
                    </div>`;
                } else if (error.message.includes('No valid dates')) {
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        Select cells containing dates like "Jan 2025" or "1/1/2025" before clicking this button.
                    </div>`;
                }
                
                progress.style.display = 'block';
                progress.innerHTML = `<div style="color: #ff6b6b;"> ${errorMessage}</div>${helpTip}`;
                btnText.textContent = 'Try Again';
                btn.disabled = false;
                btn.style.background = '';
            }
        }

        // Background Balance Sheet loading - runs after P&L is complete
        async function loadBalanceSheetInBackground(years, progressEl, btn, btnText) {
            console.log(' Starting background Balance Sheet loading for years:', years);
            const statusEl = document.getElementById('bsLoadingStatus');
            
            try {
                let totalBSAccounts = 0;
                
                for (let i = 0; i < years.length; i++) {
                    const year = years[i];
                    if (statusEl) {
                        statusEl.textContent = `Loading ${year}... (${i + 1}/${years.length} years)`;
                    }
                    
                    console.log(` Fetching BS data for ${year}...`);
                    const startTime = Date.now();
                    
                    const response = await fetch(`${SERVER_URL}/batch/full_year_refresh_bs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: parseInt(year),
                            subsidiary: '',
                            department: '',
                            location: '',
                            class: ''
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`BS load failed: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    console.log(` BS ${year}: ${Object.keys(data.balances || {}).length} accounts in ${elapsed}s`);
                    
                    // Merge BS data into localStorage cache
                    const existingBalances = JSON.parse(localStorage.getItem('netsuite_balance_cache') || '{}');
                    for (const [account, periods] of Object.entries(data.balances || {})) {
                        if (!existingBalances[account]) {
                            existingBalances[account] = {};
                        }
                        Object.assign(existingBalances[account], periods);
                        totalBSAccounts++;
                    }
                    localStorage.setItem('netsuite_balance_cache', JSON.stringify(existingBalances));
                    localStorage.setItem('netsuite_balance_timestamp', Date.now().toString());
                    
                    // Update fullYearCache if available
                    if (typeof window.setFullYearCache === 'function') {
                        window.setFullYearCache(existingBalances);
                    }
                }
                
                // Success!
                console.log(` Background BS loading complete: ${totalBSAccounts} accounts`);
                
                progressEl.innerHTML = ` <strong>All accounts ready!</strong><br><br>
                    <div style="background: rgba(125, 255, 179, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #7dffb3;">
                         <strong>P&L accounts</strong> = instant<br>
                         <strong>Balance Sheet</strong> = instant (${totalBSAccounts} accounts)
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 8px;">
                        All formulas will resolve instantly!
                    </div>`;
                
                btnText.textContent = ' All Ready!';
                btn.style.background = '#4CAF50';
                btn.disabled = false;
                
            } catch (error) {
                console.error(' Background BS loading error:', error);
                
                progressEl.innerHTML = ` <strong>P&L accounts ready!</strong><br><br>
                    <div style="background: rgba(255, 107, 107, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #ff6b6b;">
                         <strong>Balance Sheet loading failed</strong><br>
                        <span style="font-size: 11px;">${error.message}</span>
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 8px;">
                        P&L formulas work instantly. BS formulas will load on-demand (~45s each).
                    </div>`;
                
                btnText.textContent = ' P&L Ready';
                btn.style.background = '#4CAF50';
                btn.disabled = false;
            }
        }

        async function checkServerStatus() {
            // Find the status element in the VISIBLE settings panel (inline view)
            const settingsInline = document.getElementById('settingsViewInline');
            const statusEl = settingsInline ? settingsInline.querySelector('#serverStatus') : document.getElementById('serverStatus');
            
            if (!statusEl) {
                console.error('serverStatus element not found');
                return;
            }
            
            console.log('checkServerStatus: Starting check...');
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Checking...';

            try {
                // Use AbortController for broader browser compatibility
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(`${SERVER_URL}/health`, { 
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('checkServerStatus: Response received', response.status);
                
                if (response.ok) {
                    statusEl.className = 'status-indicator connected';
                    statusEl.innerHTML = '<span class="status-dot connected"></span> Connected ';
                } else {
                    throw new Error(`Status: ${response.status}`);
                }
            } catch (error) {
                console.error('checkServerStatus error:', error);
                statusEl.className = 'status-indicator error';
                statusEl.innerHTML = `<span class="status-dot error"></span> Error: ${error.message || 'Connection failed'}`;
            }
        }

        async function restartServer() {
            const statusEl = document.getElementById('serverStatus');
            
            if (!confirm('Restart the backend server? This will briefly interrupt connections.')) {
                return;
            }
            
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Restarting...';
            
            // Show toast notification
            const toastId = showToast({
                title: 'Restarting Server',
                message: 'Sending restart command...',
                type: 'calculating',
                duration: 0 // Don't auto-dismiss
            });
            
            try {
                const response = await fetch(`${SERVER_URL}/admin/restart`, { 
                    method: 'POST',
                    signal: AbortSignal.timeout(10000)
                });
                
                if (response.ok) {
                    statusEl.innerHTML = '<span class="status-dot checking"></span> Server restarting...';
                    updateToast(toastId, { message: 'Server is restarting...' });
                }
            } catch (error) {
                // Connection error is expected during restart
                console.log('Restart request sent (connection dropped as expected)');
            }
            
                statusEl.innerHTML = '<span class="status-dot checking"></span> Waiting for restart...';
            updateToast(toastId, { message: 'Waiting for server to come back online...' });
                
                // Keep checking until server is back
                let attempts = 0;
                const checkInterval = setInterval(async () => {
                    attempts++;
                    try {
                        const healthResponse = await fetch(`${SERVER_URL}/health`, { 
                            method: 'GET',
                            signal: AbortSignal.timeout(3000)
                        });
                        if (healthResponse.ok) {
                            clearInterval(checkInterval);
                            statusEl.className = 'status-indicator connected';
                            statusEl.innerHTML = '<span class="status-dot connected"></span> Restarted ';
                        
                        // Fetch and display tunnel URL
                        try {
                            const infoResponse = await fetch(`${SERVER_URL}/`, { 
                                method: 'GET',
                                signal: AbortSignal.timeout(3000)
                            });
                            if (infoResponse.ok) {
                                const data = await infoResponse.json();
                                // Update toast with success and show server info
                                updateToast(toastId, {
                                    title: 'Server Restarted',
                                    message: `Server is back online!<br><br><strong>Local:</strong> http://localhost:5002<br><strong>Note:</strong> Cloudflare tunnel URL may have changed. Check terminal or run tunnel command.`,
                                    type: 'success'
                                });
                                // Auto-dismiss after 8 seconds
                                setTimeout(() => removeToast(toastId), 8000);
                            }
                        } catch (e) {
                            updateToast(toastId, {
                                title: 'Server Restarted',
                                message: 'Server is back online!',
                                type: 'success'
                            });
                            setTimeout(() => removeToast(toastId), 5000);
                        }
                        }
                    } catch (e) {
                        if (attempts > 10) {
                            clearInterval(checkInterval);
                            statusEl.className = 'status-indicator error';
                            statusEl.innerHTML = '<span class="status-dot error"></span> Restart failed - check terminal';
                        
                        updateToast(toastId, {
                            title: 'Restart Failed',
                            message: 'Could not connect to server after restart. Check the terminal for errors.',
                            type: 'error'
                        });
                        setTimeout(() => removeToast(toastId), 8000);
                        }
                    }
                }, 2000);
        }

        function copyTunnelCommand() {
            const command = 'pkill cloudflared; cloudflared tunnel --url http://localhost:5002';
            navigator.clipboard.writeText(command).then(() => {
                alert('Command copied! Paste in Terminal to restart tunnel.');
            }).catch(err => {
                prompt('Copy this command:', command);
            });
        }

        function copyWorkerCode() {
            const newUrl = document.getElementById('newTunnelUrl').value.trim();
            if (!newUrl || !newUrl.includes('trycloudflare.com')) {
                alert('Please paste the new tunnel URL first (e.g., https://xxx.trycloudflare.com)');
                return;
            }
            
            const workerCode = `// Cloudflare Worker - NetSuite Proxy
// Updated: ${new Date().toISOString()}
const TUNNEL_URL = '${newUrl}';

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const targetUrl = TUNNEL_URL + url.pathname + url.search;
    
    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type',
          'Access-Control-Max-Age': '86400',
        },
      });
    }
    
    try {
      const response = await fetch(targetUrl, {
        method: request.method,
        headers: request.headers,
        body: request.method !== 'GET' ? await request.text() : undefined,
      });
      
      const newResponse = new Response(response.body, response);
      newResponse.headers.set('Access-Control-Allow-Origin', '*');
      return newResponse;
    } catch (error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 502,
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' },
      });
    }
  },
};`;
            
            navigator.clipboard.writeText(workerCode).then(() => {
                alert('Worker code copied with new tunnel URL!\\n\\nGo to Cloudflare Dashboard  Workers  netsuite-proxy  Edit Code  Paste  Deploy');
            }).catch(err => {
                // Fallback for browsers that don't support clipboard
                const textarea = document.createElement('textarea');
                textarea.value = workerCode;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('Worker code copied!');
            });
        }

        async function reloadLookups() {
            // Find the status element in the VISIBLE settings panel (inline view)
            const settingsInline = document.getElementById('settingsViewInline');
            const statusEl = settingsInline ? settingsInline.querySelector('#serverStatus') : document.getElementById('serverStatus');
            
            if (!statusEl) {
                console.error('serverStatus element not found');
                return;
            }
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Reloading lookups...';
            
            try {
                console.log('Reloading lookups...');
                await loadNetSuiteLookups();
                await preloadAccountTitles();
                statusEl.className = 'status-indicator connected';
                statusEl.innerHTML = '<span class="status-dot connected"></span> Lookups reloaded ';
                console.log('Lookups reloaded successfully');
            } catch (error) {
                console.error('reloadLookups error:', error);
                statusEl.className = 'status-indicator error';
                statusEl.innerHTML = `<span class="status-dot error"></span> Failed: ${error.message || 'Unknown error'}`;
            }
        }

        async function checkTunnelStatus() {
            // Find the status element in the VISIBLE settings panel (inline view)
            const settingsInline = document.getElementById('settingsViewInline');
            const statusEl = settingsInline ? settingsInline.querySelector('#tunnelStatus') : document.getElementById('tunnelStatus');
            
            if (!statusEl) {
                console.error('tunnelStatus element not found');
                return;
            }
            
            console.log('checkTunnelStatus: Starting check...');
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Checking...';

            try {
                // Use AbortController for broader browser compatibility
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                // The health check goes through the worker  tunnel  server
                // If it works, tunnel is working
                const response = await fetch(`${SERVER_URL}/health`, { 
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('checkTunnelStatus: Response received', response.status);
                
                if (response.ok) {
                    statusEl.className = 'status-indicator connected';
                    statusEl.innerHTML = '<span class="status-dot connected"></span> Tunnel Active ';
                } else if (response.status === 530) {
                    throw new Error('Tunnel offline (530)');
                } else {
                    throw new Error(`Status: ${response.status}`);
                }
            } catch (error) {
                console.error('checkTunnelStatus error:', error);
                statusEl.className = 'status-indicator error';
                if (error.message && error.message.includes('530')) {
                    statusEl.innerHTML = '<span class="status-dot error"></span> Tunnel Offline - needs restart';
                } else {
                    statusEl.innerHTML = `<span class="status-dot error"></span> ${error.message || 'Connection failed'}`;
                }
            }
        }

        function checkCacheStatus() {
            try {
                const STORAGE_KEY = 'netsuite_balance_cache';
                const STORAGE_TIMESTAMP_KEY = 'netsuite_balance_cache_timestamp';
                
                const cached = localStorage.getItem(STORAGE_KEY);
                const timestamp = localStorage.getItem(STORAGE_TIMESTAMP_KEY);
                
                // Find elements in the VISIBLE settings panel (inline view)
                const settingsInline = document.getElementById('settingsViewInline');
                const localStorageEl = settingsInline ? settingsInline.querySelector('#localStorageStatus') : document.getElementById('localStorageStatus');
                const accountsEl = settingsInline ? settingsInline.querySelector('#cachedAccountsCount') : document.getElementById('cachedAccountsCount');
                
                if (!localStorageEl || !accountsEl) {
                    console.error('Cache status elements not found');
                    return;
                }
                
                if (cached && timestamp) {
                    const balances = JSON.parse(cached);
                    const accountCount = Object.keys(balances).length;
                    const cacheAge = Math.round((Date.now() - parseInt(timestamp)) / 1000);
                    
                    localStorageEl.textContent = `Active (${cacheAge}s ago)`;
                    localStorageEl.style.color = '#059669';
                    accountsEl.textContent = `${accountCount} accounts`;
                } else {
                    localStorageEl.textContent = 'Empty';
                    localStorageEl.style.color = '#6b7280';
                    accountsEl.textContent = '0';
                }
            } catch (e) {
                console.error('checkCacheStatus error:', e);
                const settingsInline = document.getElementById('settingsViewInline');
                const localStorageEl = settingsInline ? settingsInline.querySelector('#localStorageStatus') : document.getElementById('localStorageStatus');
                const accountsEl = settingsInline ? settingsInline.querySelector('#cachedAccountsCount') : document.getElementById('cachedAccountsCount');
                if (localStorageEl) localStorageEl.textContent = 'Error';
                if (accountsEl) accountsEl.textContent = '-';
            }
        }

        // Permission descriptions for help tooltips
        const PERMISSION_HELP = {
            'Account': {
                description: 'Chart of Accounts access',
                impact: 'Required to retrieve account numbers, names, and types. Without this, XAVI cannot function.',
                required: true
            },
            'TransactionAccountingLine': {
                description: 'Transaction GL Lines access',
                impact: 'Required to calculate account balances from posted transactions. Without this, XAVI.BALANCE will not work.',
                required: true
            },
            'Transaction': {
                description: 'Transaction records access',
                impact: 'Required for drill-through to see transaction details. Without this, drilling into balances will show no data.',
                required: true
            },
            'AccountingPeriod': {
                description: 'Accounting Periods access',
                impact: 'Required to determine period dates and fiscal year boundaries. Without this, period-based queries will fail.',
                required: true
            },
            'Subsidiary': {
                description: 'Subsidiaries (OneWorld)',
                impact: 'Required for multi-subsidiary filtering. If disabled, subsidiary parameter in formulas will be ignored. Non-OneWorld accounts will show this as unavailable.',
                required: false
            },
            'Department': {
                description: 'Departments',
                impact: 'Required for department-based filtering. If disabled, you cannot filter balances by department.',
                required: false
            },
            'Classification': {
                description: 'Classes',
                impact: 'Required for class-based filtering. If disabled, you cannot filter balances by class.',
                required: false
            },
            'Location': {
                description: 'Locations',
                impact: 'Required for location-based filtering. If disabled, you cannot filter balances by location.',
                required: false
            },
            'Budget': {
                description: 'Budget records',
                impact: 'Required for XAVI.BUDGET function. If disabled or budgets not set up, budget queries will return errors.',
                required: false
            },
            'ConsolidatedExchangeRate': {
                description: 'Currency Exchange Rates',
                impact: 'Required for currency consolidation in multi-currency reports. If disabled, consolidated amounts may be incorrect.',
                required: false
            },
            'AccountingBook': {
                description: 'Accounting Books (Multi-Book)',
                impact: 'Required if using Multi-Book Accounting. If disabled, the accounting book parameter will be ignored.',
                required: false
            }
        };

        // Convert technical error messages to user-friendly messages
        function getFriendlyErrorMessage(error, tableName) {
            if (!error) return 'Access denied';
            
            const errorLower = error.toLowerCase();
            
            // Feature not enabled in NetSuite account
            if (errorLower.includes('invalid search type') || 
                errorLower.includes('record') && errorLower.includes('was not found')) {
                const featureNames = {
                    'Budget': 'Budgeting',
                    'AccountingBook': 'Multi-Book Accounting',
                    'Subsidiary': 'OneWorld (Multi-Subsidiary)'
                };
                const featureName = featureNames[tableName] || tableName;
                return `${featureName} feature not enabled in this NetSuite account`;
            }
            
            // Permission denied
            if (errorLower.includes('permission denied') || errorLower.includes('403')) {
                return 'Permission denied - contact your NetSuite admin';
            }
            
            // Timeout
            if (errorLower.includes('timed out') || errorLower.includes('timeout')) {
                return 'Query timed out - may indicate permission issue';
            }
            
            // Table doesn't exist (non-OneWorld, etc.)
            if (errorLower.includes('does not exist') || errorLower.includes('invalid table')) {
                return 'Feature not available in this account type';
            }
            
            // Generic fallback - but cleaner
            if (error.length > 50) {
                return 'Feature not accessible (check NetSuite role permissions)';
            }
            
            return error;
        }

        async function checkNetSuitePermissions() {
            // Find elements in the VISIBLE settings panel (inline view)
            const settingsInline = document.getElementById('settingsViewInline');
            const btn = settingsInline ? settingsInline.querySelector('#checkPermissionsBtn') : document.getElementById('checkPermissionsBtn');
            const resultsDiv = settingsInline ? settingsInline.querySelector('#permissionsResults') : document.getElementById('permissionsResults');
            const statusDiv = settingsInline ? settingsInline.querySelector('#permissionsStatus') : document.getElementById('permissionsStatus');
            const featuresSection = settingsInline ? settingsInline.querySelector('#featuresSection') : document.getElementById('featuresSection');
            const subsidiariesSection = settingsInline ? settingsInline.querySelector('#subsidiariesSection') : document.getElementById('subsidiariesSection');
            const subsidiariesList = settingsInline ? settingsInline.querySelector('#subsidiariesList') : document.getElementById('subsidiariesList');
            const tablePermissionsSection = settingsInline ? settingsInline.querySelector('#tablePermissionsSection') : document.getElementById('tablePermissionsSection');
            const listDiv = settingsInline ? settingsInline.querySelector('#permissionsList') : document.getElementById('permissionsList');
            
            // Show loading state
            btn.disabled = true;
            btn.textContent = ' Checking...';
            resultsDiv.style.display = 'block';
            statusDiv.style.background = '#f3f4f6';
            statusDiv.style.color = '#4b5563';
            statusDiv.textContent = 'Checking NetSuite account...';
            featuresSection.innerHTML = '';
            subsidiariesSection.style.display = 'none';
            tablePermissionsSection.style.display = 'none';
            listDiv.innerHTML = '';
            
            try {
                const response = await fetch(`${SERVER_URL}/check-permissions`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(60000)
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update status banner
                if (data.status === 'success') {
                    statusDiv.style.background = 'linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%)';
                    statusDiv.style.color = '#065f46';
                    statusDiv.innerHTML = ` ${data.message}`;
                } else if (data.status === 'warning') {
                    statusDiv.style.background = 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)';
                    statusDiv.style.color = '#92400e';
                    statusDiv.innerHTML = ` ${data.message}`;
                } else {
                    statusDiv.style.background = 'linear-gradient(135deg, #fee2e2 0%, #fecaca 100%)';
                    statusDiv.style.color = '#991b1b';
                    statusDiv.innerHTML = ` ${data.message}`;
                }
                
                // Helper function to build a feature card
                function buildFeatureCard(check) {
                    const enabled = check.enabled === true;
                    const accessible = check.accessible === true;
                    
                    let bgColor, borderColor, statusIcon;
                    if (enabled) {
                        bgColor = '#ecfdf5';
                        borderColor = '#10b981';
                        statusIcon = '';
                    } else if (!accessible) {
                        bgColor = '#eff6ff';
                        borderColor = '#3b82f6';
                        statusIcon = '';
                    } else {
                        bgColor = '#f9fafb';
                        borderColor = '#e5e7eb';
                        statusIcon = '';
                    }
                    
                    let resultDisplay = '';
                    if (check.details) {
                        resultDisplay = check.details;
                    } else if (check.query_result) {
                        if (Array.isArray(check.query_result)) {
                            if (check.query_result.length > 0) {
                                const items = check.query_result.slice(0, 5).map(r => 
                                    r.name || r.id || JSON.stringify(r)
                                ).join(', ');
                                resultDisplay = `${check.query_result.length} found: ${items}${check.query_result.length > 5 ? '...' : ''}`;
                    } else {
                                resultDisplay = 'Query returned 0 rows';
                            }
                        } else if (check.query_result.count !== undefined) {
                            resultDisplay = `${check.query_result.count} budget record(s) found`;
                        } else if (typeof check.query_result === 'string') {
                            resultDisplay = check.query_result;
                        } else {
                            resultDisplay = JSON.stringify(check.query_result);
                        }
                    } else if (check.error) {
                        resultDisplay = `Error: ${check.error}`;
                    }
                    
                    return `
                        <div style="padding: 10px 12px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 6px; font-weight: 600; font-size: 12px; color: #374151; margin-bottom: 4px;">
                                <span>${statusIcon}</span>
                                <span>${check.name}</span>
                                </div>
                            <div style="font-size: 10px; color: #6b7280; font-family: monospace; word-break: break-all;">${resultDisplay}</div>
                                </div>
                    `;
                }
                
                // Build features section with collapsible details
                let featuresHTML = '';
                
                // Add account ID at the top
                if (data.account_id) {
                    featuresHTML += `
                        <div style="padding: 8px 12px; background: #f3f4f6; border-radius: 6px; font-size: 11px; color: #6b7280; margin-bottom: 12px;">
                            Account ID: <strong>${data.account_id}</strong>
                            </div>
                    `;
                }
                
                // Budgets check
                const budgetCheck = data.checks.find(c => c.table === 'Budgets');
                if (budgetCheck) {
                    const budgetStatus = budgetCheck.enabled ? '' : '';
                    const budgetCount = budgetCheck.query_result?.count || 0;
                    featuresHTML += `
                        <div style="padding: 10px 12px; background: ${budgetCheck.enabled ? '#ecfdf5' : '#f9fafb'}; border: 1px solid ${budgetCheck.enabled ? '#10b981' : '#e5e7eb'}; border-radius: 6px; margin-bottom: 10px;">
                            <div style="font-size: 12px; font-weight: 600; color: #374151;">
                                ${budgetStatus} Budgets <span style="font-weight: normal; color: #6b7280;">(${budgetCount} records)</span>
                            </div>
                        </div>
                    `;
                }
                
                featuresSection.innerHTML = featuresHTML;
                
                // Build subsidiaries section (collapsible)
                if (data.subsidiaries && data.subsidiaries.length > 0) {
                    subsidiariesSection.style.display = 'block';
                    
                    const subsidiaryCheck = data.checks.find(c => c.table === 'Subsidiary');
                    const subStatus = subsidiaryCheck?.enabled ? '' : '';
                    
                    let subsHTML = `
                        <details style="border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden;">
                            <summary style="padding: 10px 12px; background: #ecfdf5; cursor: pointer; font-size: 12px; font-weight: 600; color: #374151;">
                                ${subStatus} OneWorld Subsidiaries <span style="font-weight: normal; color: #6b7280;">(${data.subsidiaries.length} found)</span>
                            </summary>
                            <div style="max-height: 200px; overflow-y: auto;">
                    `;
                    
                    for (const sub of data.subsidiaries) {
                        const isElim = sub.isElimination;
                        const badge = isElim ? '<span style="font-size: 9px; background: #fef3c7; color: #92400e; padding: 1px 4px; border-radius: 3px; margin-left: 6px;">Elimination</span>' : '';
                        subsHTML += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #f3f4f6; font-size: 11px;">
                                <span style="color: #374151;">${sub.name}${badge}</span>
                                <span style="color: #9ca3af;">ID: ${sub.id}</span>
                        </div>
                    `;
                }
                    subsHTML += '</div></details>';
                    
                    subsidiariesList.innerHTML = subsHTML;
                }
                
                // Build table permissions list (collapsible)
                const featureTableNames = ['Subsidiary', 'Budgets'];
                const tableChecks = data.checks.filter(c => !featureTableNames.includes(c.table));
                
                // Count verified permissions
                const verifiedCount = tableChecks.filter(c => c.accessible === true).length;
                const totalCount = tableChecks.length;
                const allVerified = verifiedCount === totalCount;
                
                // Override status banner if table permissions are not all verified
                if (!allVerified && data.status === 'success') {
                    statusDiv.style.background = 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)';
                    statusDiv.style.color = '#92400e';
                    statusDiv.innerHTML = ` ${verifiedCount}/${totalCount} table permissions verified`;
                }
                
                let listHTML = `
                    <details style="border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden;">
                        <summary style="padding: 10px 12px; background: ${allVerified ? '#ecfdf5' : '#fef3c7'}; cursor: pointer; font-size: 12px; font-weight: 600; color: #374151;">
                            ${allVerified ? '' : ''} Required Permissions <span style="font-weight: normal; color: #6b7280;">(${verifiedCount}/${totalCount} verified)</span>
                        </summary>
                        <div style="max-height: 250px; overflow-y: auto;">
                `;
                
                for (const check of tableChecks) {
                    let statusIcon;
                    if (check.accessible === true) {
                        statusIcon = '';
                    } else if (check.accessible === null) {
                        statusIcon = '';
                    } else {
                        statusIcon = check.required ? '' : '';
                    }
                    
                    listHTML += `
                        <div style="display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid #f3f4f6; font-size: 11px;">
                            <span style="margin-right: 8px;">${statusIcon}</span>
                            <span style="flex: 1; color: #374151;">${check.name}</span>
                        </div>
                    `;
                }
                
                listHTML += '</div></details>';
                listDiv.innerHTML = listHTML;
                
                // Show the table permissions section
                tablePermissionsSection.style.display = 'block';
                
            } catch (error) {
                statusDiv.style.background = 'linear-gradient(135deg, #fee2e2 0%, #fecaca 100%)';
                statusDiv.style.color = '#991b1b';
                
                if (error.name === 'TimeoutError') {
                    statusDiv.innerHTML = ' Check timed out';
                } else if (error.message.includes('Failed to fetch')) {
                    statusDiv.innerHTML = ' Cannot connect to server';
                } else {
                    statusDiv.innerHTML = ` ${error.message}`;
                }
                
                featuresSection.innerHTML = `
                    <div style="padding: 12px; background: #fef2f2; border-radius: 8px; color: #991b1b; font-size: 11px;">
                        <p style="margin-bottom: 6px;">Check that:</p>
                        <ul style="padding-left: 16px; line-height: 1.6; margin: 0;">
                            <li>Backend server is running</li>
                            <li>Cloudflare tunnel is active</li>
                        </ul>
                    </div>
                `;
            }
            
            btn.disabled = false;
            btn.textContent = ' Test NetSuite';
        }

        function copyTunnelInstructions() {
            const urlInput = document.getElementById('newTunnelUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please enter the new tunnel URL first');
                return;
            }
            
            const workerCode = `const TUNNEL_URL = '${url}';`;
            navigator.clipboard.writeText(workerCode).then(() => {
                alert('Copied! Paste this in the Cloudflare Worker to update the tunnel URL.');
            }).catch(() => {
                prompt('Copy this line to update the Worker:', workerCode);
            });
        }

        // ===== ACCORDION AND DRAG/DROP FUNCTIONS =====
        
        // Exclusive accordion behavior - close others when one opens
        function handleAccordionClick(event, sectionId) {
            // Don't handle if clicking on drag handle
            if (event.target.closest('.drag-handle')) {
                event.preventDefault();
                return;
            }
            
            const clickedSection = document.getElementById(sectionId);
            if (!clickedSection) return;
            
            // If opening this section, close all others
            if (!clickedSection.hasAttribute('open')) {
                const allSections = document.querySelectorAll('.collapsible-section');
                allSections.forEach(section => {
                    if (section.id !== sectionId && section.hasAttribute('open')) {
                        section.removeAttribute('open');
                    }
                });
            }
        }
        
        // Show success overlay for generated reports
        function showReportSuccessOverlay(reportType, data) {
            const overlay = document.createElement('div');
            overlay.className = 'report-success-overlay';
            overlay.id = 'reportSuccessOverlay';
            
            // Add header row if countLabel is provided (e.g., "Formula Type" for CFO Flash)
            const sectionHeaderHtml = data.countLabel ? 
                `<div style="display: flex; justify-content: space-between; padding: 3px 0; font-size: 10px; color: #6b7280; border-bottom: 1px solid #e5e7eb; margin-bottom: 4px;">
                    <span>Section</span>
                    <span>${data.countLabel}</span>
                </div>` : '';
            
            const sectionsHtml = data.sections.map(s => 
                `<div style="display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px;">
                    <span> ${s.name}</span>
                    <strong>${s.count}</strong>
                </div>`
            ).join('');
            
            const tipsHtml = data.tips.map(t => 
                `<div class="tip-box ${t.type}">
                    ${t.icon} <strong>${t.title}</strong> ${t.text}
                </div>`
            ).join('');
            
            // Format elapsed time nicely (compact)
            const timeDisplay = data.elapsedTime ? 
                `<div style="margin-top: 6px; font-size: 11px; color: #059669;">
                     Completed in <strong>${data.elapsedTime}s</strong>
                </div>` : '';
            
            // Custom header for Structure Sync (shows subsidiary + flag)
            const headerHtml = data.customHeader ? 
                `<div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">${data.customHeader}</div>` : '';
            
            // Determine title suffix based on report type
            const titleSuffix = (reportType === 'Structure Sync' || reportType === 'CFO Flash Sync') ? 'Complete!' : 'Generated!';
            
            overlay.innerHTML = `
                <div class="report-success-card">
                    <button class="close-x" onclick="dismissReportSuccess()" title="Close"></button>
                    ${headerHtml}
                    <h2> ${reportType} ${titleSuffix}</h2>
                    <div class="summary">
                        <div style="margin-bottom: 6px; font-size: 12px;"><strong>${data.totalAccounts} ${data.countLabel ? 'lines' : 'accounts'}</strong> in sections:</div>
                        ${sectionHeaderHtml}
                        ${sectionsHtml}
                        ${timeDisplay}
                    </div>
                    ${tipsHtml}
                    <button class="dismiss-btn" onclick="dismissReportSuccess()">
                        Got it! 
                    </button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Allow clicking outside to dismiss
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    dismissReportSuccess();
                }
            });
        }
        
        // Flag to suppress statusBar during report generation
        let suppressStatusBar = false;
        
        // ========================================================================
        // FORMULA COMPLETION DETECTION - CONFIGURATION
        // ========================================================================
        // Set to false to revert to old behavior (15s fallback wait)
        // Set to true to use smart detection (checks for numeric values vs formula count)
        const USE_SMART_FORMULA_DETECTION = true;  // <-- EASY REVERT: Change to false
        const SMART_DETECTION_THRESHOLD = 0.90;    // Require 90% of formulas to have numeric values
        const FALLBACK_WAIT_SECONDS = 15;          // Old behavior fallback (if smart detection disabled)
        // ========================================================================
        
        // Wait for formulas to complete - smart detection based on actual formula count
        // Counts XAVI formulas on sheet, then waits until ~90% have numeric values
        // This avoids waiting 15+ seconds when formulas resolve instantly from cache
        async function waitForFormulasToComplete(maxWaitMs = 120000, updateOverlayFn = null) {
            const startTime = Date.now();
            
            console.log(' Waiting for formulas to complete...');
            
            // Clear any existing status broadcasts
            localStorage.removeItem('netsuite_status');
            
            // First, count XAVI formulas on the sheet (for smart detection)
            let expectedFormulaCount = 0;
            if (USE_SMART_FORMULA_DETECTION) {
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load("formulas");
                        await context.sync();
                        
                        const formulas = usedRange.formulas;
                        for (const row of formulas) {
                            for (const cell of row) {
                                if (typeof cell === 'string' && cell.toUpperCase().includes('XAVI.')) {
                                    expectedFormulaCount++;
                                }
                            }
                        }
                    });
                    console.log(`   Smart detection: ENABLED - expecting ${expectedFormulaCount} XAVI formulas to resolve`);
                    console.log(`   Threshold: ${Math.round(SMART_DETECTION_THRESHOLD * 100)}% (${Math.ceil(expectedFormulaCount * SMART_DETECTION_THRESHOLD)} numeric values needed)`);
                } catch (e) {
                    console.warn('   Could not count formulas, using fallback mode');
                    expectedFormulaCount = 0;
                }
            } else {
                console.log(`   Smart detection: DISABLED (using ${FALLBACK_WAIT_SECONDS}s fallback)`);
            }
            
            // Brief initial wait for Excel to start calculating
            console.log(' Giving Excel a moment to start calculating...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            let consecutiveNoBusy = 0;
            const requiredConsecutive = 3; // Need 3 consecutive checks (3 seconds of stability)
            let sawBusyAtLeastOnce = false;
            const targetNumeric = Math.ceil(expectedFormulaCount * SMART_DETECTION_THRESHOLD);
            
            while (Date.now() - startTime < maxWaitMs) {
                await new Promise(resolve => setTimeout(resolve, 1000)); // Check every second
                
                let hasBusy = false;
                let busyCount = 0;
                let numericCount = 0;  // Smart detection: count actual numbers
                
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load("values");
                        await context.sync();
                        
                        const values = usedRange.values;
                        for (const row of values) {
                            for (const cell of row) {
                                const cellStr = String(cell || '');
                                if (cellStr.includes('#BUSY') || cellStr.includes('#BUSY!')) {
                                    hasBusy = true;
                                    busyCount++;
                                }
                                // Smart detection: count numeric values (indicates resolved formulas)
                                if (USE_SMART_FORMULA_DETECTION && typeof cell === 'number' && !isNaN(cell)) {
                                    numericCount++;
                                }
                            }
                        }
                    });
                    
                    const elapsed = Math.round((Date.now() - startTime) / 1000);
                    
                    if (hasBusy) {
                        sawBusyAtLeastOnce = true;
                        consecutiveNoBusy = 0; // Reset counter
                        console.log(` ${busyCount} #BUSY cells remaining (${elapsed}s elapsed)`);
                    } else {
                        // Determine if we should count this as "resolved"
                        let shouldCountAsResolved = false;
                        let resolveReason = '';
                        
                        if (sawBusyAtLeastOnce) {
                            // We saw #BUSY before and now it's gone - definitely resolved
                            shouldCountAsResolved = true;
                            resolveReason = 'saw #BUSY clear';
                        } else if (USE_SMART_FORMULA_DETECTION && expectedFormulaCount > 0 && numericCount >= targetNumeric) {
                            // SMART DETECTION: We have enough numeric values = formulas resolved from cache
                            console.log(` Smart detection: ${numericCount}/${expectedFormulaCount} formulas resolved (${Math.round(numericCount/expectedFormulaCount*100)}%) - cache hit!`);
                            shouldCountAsResolved = true;
                            resolveReason = 'smart detection';
                        } else if (elapsed > FALLBACK_WAIT_SECONDS) {
                            // Fallback: waited long enough, assume resolved
                            shouldCountAsResolved = true;
                            resolveReason = 'timeout fallback';
                        }
                        
                        if (shouldCountAsResolved) {
                            consecutiveNoBusy++;
                            const smartInfo = USE_SMART_FORMULA_DETECTION && expectedFormulaCount > 0 
                                ? ` [${numericCount}/${expectedFormulaCount} numeric]` 
                                : '';
                            console.log(` No #BUSY cells (check ${consecutiveNoBusy}/${requiredConsecutive})${smartInfo}`);
                            
                            if (consecutiveNoBusy >= requiredConsecutive) {
                                console.log(` All cells populated! (${resolveReason})`);
                                // Don't change suppressStatusBar here - let caller control it
                                localStorage.removeItem('netsuite_status');
                                return true;
                            }
                        } else {
                            const smartInfo = USE_SMART_FORMULA_DETECTION && expectedFormulaCount > 0 
                                ? ` [${numericCount}/${targetNumeric} needed]` 
                                : '';
                            console.log(` Waiting for formulas to resolve... (${elapsed}s)${smartInfo}`);
                        }
                    }
                } catch (e) {
                    console.warn('Error checking #BUSY:', e.message);
                }
            }
            
            console.warn(' Timed out waiting for formulas to complete');
            return false;
        }
        
        // Auto-fit all columns with data - call AFTER all formulas have resolved
        async function autoFitColumns() {
            console.log(' Auto-fitting column widths...');
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load(['columnCount', 'address']);
                    await context.sync();
                    
                    // Auto-fit each column in the used range
                    const format = usedRange.format;
                    format.autofitColumns();
                    await context.sync();
                    
                    console.log(' Columns auto-fitted');
                });
            } catch (e) {
                console.warn('Auto-fit columns failed:', e.message);
            }
        }
        
        function dismissReportSuccess() {
            const overlay = document.getElementById('reportSuccessOverlay');
            if (overlay) {
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.2s ease';
                setTimeout(() => overlay.remove(), 200);
            }
            
            // CRITICAL: Re-enable statusBar only AFTER user dismisses success overlay
            // Clear any stale status messages that might have accumulated
            suppressStatusBar = false;
            localStorage.removeItem('netsuite_status');
            hideStatus();  // Hide any visible status bar
        }
        
        // Close Quick Start accordion
        function closeQuickStart() {
            const quickStart = document.getElementById('quickStartSection');
            if (quickStart) {
                quickStart.removeAttribute('open');
            }
        }
        
        // Initialize drag and drop for accordion reordering
        function initDragAndDrop() {
            const container = document.querySelector('.tab-panel#panelFinancial');
            if (!container) return;
            
            const sections = container.querySelectorAll('.collapsible-section');
            let draggedElement = null;
            
            sections.forEach(section => {
                const handle = section.querySelector('.drag-handle');
                if (!handle) return;
                
                handle.addEventListener('dragstart', (e) => {
                    draggedElement = section;
                    section.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', section.id);
                });
                
                handle.addEventListener('dragend', () => {
                    section.classList.remove('dragging');
                    sections.forEach(s => s.classList.remove('drag-over'));
                    draggedElement = null;
                    
                    // Save order to localStorage
                    saveSectionOrder();
                });
                
                section.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedElement && draggedElement !== section) {
                        section.classList.add('drag-over');
                    }
                });
                
                section.addEventListener('dragleave', () => {
                    section.classList.remove('drag-over');
                });
                
                section.addEventListener('drop', (e) => {
                    e.preventDefault();
                    section.classList.remove('drag-over');
                    
                    if (draggedElement && draggedElement !== section) {
                        const rect = section.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        
                        if (e.clientY < midY) {
                            section.parentNode.insertBefore(draggedElement, section);
                        } else {
                            section.parentNode.insertBefore(draggedElement, section.nextSibling);
                        }
                    }
                });
            });
        }
        
        // Save section order to localStorage
        function saveSectionOrder() {
            const container = document.querySelector('.tab-panel#panelFinancial');
            if (!container) return;
            
            const sections = container.querySelectorAll('.collapsible-section');
            const order = Array.from(sections).map(s => s.id);
            localStorage.setItem('xavi_section_order', JSON.stringify(order));
        }
        
        // Restore section order from localStorage
        function restoreSectionOrder() {
            const savedOrder = localStorage.getItem('xavi_section_order');
            if (!savedOrder) return;
            
            try {
                const order = JSON.parse(savedOrder);
                const container = document.querySelector('.tab-panel#panelFinancial');
                if (!container) return;
                
                order.forEach(id => {
                    const section = document.getElementById(id);
                    if (section) {
                        container.appendChild(section);
                    }
                });
            } catch (e) {
                console.warn('Could not restore section order:', e);
            }
        }

        // Load NetSuite lookups into dropdowns
        async function loadNetSuiteLookups() {
            const statusEl = document.getElementById('lookupStatus');
            statusEl.textContent = 'Loading filters...';
            statusEl.style.color = '#0284c7';
            
            try {
                const response = await fetch(`${SERVER_URL}/lookups/all`);
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Lookups loaded:', data);
                
                // Populate subsidiary dropdown - Show NAMES with hierarchical indentation
                const subSelect = document.getElementById('subsidiarySelect');
                subSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                
                // Sort subsidiaries hierarchically
                const subsidiaries = data.subsidiaries || [];
                const sortedSubs = sortSubsidiariesHierarchically(subsidiaries);
                
                sortedSubs.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    // Add visual indentation based on depth
                    const indent = '\u00A0\u00A0\u00A0\u00A0'.repeat(item.depth || 0);  // 4 non-breaking spaces per level
                    const prefix = (item.depth || 0) > 0 ? ' ' : '';
                    option.textContent = indent + prefix + item.name;
                    subSelect.appendChild(option);
                });
                
                // Populate department dropdown - Show NAMES only
                const deptSelect = document.getElementById('departmentSelect');
                deptSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.departments || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    deptSelect.appendChild(option);
                });
                
                // Populate class dropdown - Show NAMES only
                const classSelect = document.getElementById('classSelect');
                classSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.classes || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    classSelect.appendChild(option);
                });
                
                // Populate location dropdown - Show NAMES only
                const locSelect = document.getElementById('locationSelect');
                locSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.locations || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    locSelect.appendChild(option);
                });
                
                // Populate accounting book dropdown - Show NAMES, use IDs as values
                // Multi-Book Accounting: Primary Book, Secondary Books (GAAP, IFRS, Tax, etc.)
                // Note: value="1" is the Primary Book ID in NetSuite
                const bookSelect = document.getElementById('accountingBookSelect');
                bookSelect.innerHTML = '<option value="1">Primary Book (Default)</option>';
                (data.accountingBooks || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;  // Use ID as value (backend expects numeric ID)
                    option.textContent = item.name;  // Show name (includes "(Primary)" marker)
                    bookSelect.appendChild(option);
                });
                
                // Populate budget category dropdown - Show NAMES (backend accepts name or ID)
                // Used with XAVI.BUDGET formula to filter by budget version
                const budgetCatSelect = document.getElementById('budgetCategorySelect');
                budgetCatSelect.innerHTML = '<option value="">-- All Categories --</option>';
                (data.budgetCategories || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (more user-friendly)
                    option.textContent = item.name;
                    budgetCatSelect.appendChild(option);
                });
                
                statusEl.textContent = ' Lookup lists loaded!';
                statusEl.style.color = '#059669';
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
                
            } catch (error) {
                console.error('Error loading lookups:', error);
                statusEl.textContent = ' Error loading lookups: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        // Insert lookup value into selected cell with auto-comment
        async function insertLookupValue(type) {
            const statusEl = document.getElementById('lookupStatus');
            
            try {
                let selectId, typeName, commentText;
                if (type === 'subsidiary') {
                    selectId = 'subsidiarySelect';
                    typeName = 'Subsidiary';
                    commentText = 'SUBSIDIARY FILTER: Reference this cell in your XAVI formulas to filter by subsidiary. Add "(Consolidated)" to include child subsidiaries.';
                } else if (type === 'department') {
                    selectId = 'departmentSelect';
                    typeName = 'Department';
                    commentText = 'DEPARTMENT FILTER: Reference this cell in your XAVI formulas to filter by department.';
                } else if (type === 'class') {
                    selectId = 'classSelect';
                    typeName = 'Class';
                    commentText = 'CLASS FILTER: Reference this cell in your XAVI formulas to filter by class.';
                } else if (type === 'location') {
                    selectId = 'locationSelect';
                    typeName = 'Location';
                    commentText = 'LOCATION FILTER: Reference this cell in your XAVI formulas to filter by location.';
                } else if (type === 'accountingBook') {
                    selectId = 'accountingBookSelect';
                    typeName = 'Accounting Book';
                    commentText = 'ACCOUNTING BOOK: Reference this cell in your XAVI formulas to specify which accounting book to query.';
                } else if (type === 'budgetCategory') {
                    selectId = 'budgetCategorySelect';
                    typeName = 'Budget Category';
                    commentText = 'BUDGET CATEGORY: Reference this cell in your XAVI.BUDGET formulas to filter by budget category.';
                }
                
                const select = document.getElementById(selectId);
                const selectedValue = select.value;
                
                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    
                    // Insert the value (NAME for most filters, ID for accounting book)
                    range.values = [[selectedValue]];
                    await context.sync();
                    
                    // Add a comment to explain the cell's purpose
                    try {
                        // Get the cell address to work with comments collection
                        range.load('address');
                        await context.sync();
                        const cellAddress = range.address;
                        
                        // Try to delete existing comment first using the comments collection
                        try {
                            const comments = context.workbook.comments;
                            const existingComment = comments.getItemByCell(cellAddress);
                            existingComment.load('id');
                            await context.sync();
                            existingComment.delete();
                            await context.sync();
                        } catch (e) { /* No existing comment - that's fine */ }
                        
                        // Add new comment using the comments collection
                        const comments = context.workbook.comments;
                        comments.add(cellAddress, commentText);
                        await context.sync();
                        console.log(` Added comment for ${typeName} filter at ${cellAddress}`);
                    } catch (commentError) {
                        console.warn('Could not add comment:', commentError.message);
                    }
                    
                    if (selectedValue === '') {
                        statusEl.textContent = ` Inserted: All ${typeName}s (no filter)`;
                    } else if (type === 'accountingBook') {
                        // For accounting book, show the selected text not the ID
                        const selectedText = select.options[select.selectedIndex].text;
                        statusEl.textContent = ` Inserted ${typeName} ID: ${selectedValue} (${selectedText})`;
                    } else {
                        statusEl.textContent = ` Inserted ${typeName}: "${selectedValue}"`;
                    }
                    statusEl.style.color = '#059669';
                    
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 3000);
                });
                
            } catch (error) {
                console.error('Error inserting value:', error);
                statusEl.textContent = ' Error: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        // Create a hidden lookup sheet with Name  ID mappings
        async function createLookupSheet() {
            const statusEl = document.getElementById('lookupSheetStatus');
            statusEl.textContent = 'Creating lookup sheet...';
            statusEl.style.color = '#0284c7';
            
            try {
                // First, fetch the lookup data
                const response = await fetch(`${SERVER_URL}/lookups/all`);
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Lookups data:', data);
                
                await Excel.run(async (context) => {
                    // Check if sheet exists, delete if it does
                    const sheets = context.workbook.worksheets;
                    sheets.load('items/name');
                    await context.sync();
                    
                    const existingSheet = sheets.items.find(s => s.name === 'NSLookups');
                    if (existingSheet) {
                        existingSheet.delete();
                        await context.sync();
                    }
                    
                    // Create new hidden sheet
                    const lookupSheet = sheets.add('NSLookups');
                    lookupSheet.visibility = Excel.SheetVisibility.hidden;
                    
                    let currentRow = 1;
                    
                    // Add Subsidiaries section
                    lookupSheet.getRange(`A${currentRow}`).values = [['SUBSIDIARIES']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const subStart = currentRow;
                    (data.subsidiaries || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const subEnd = currentRow - 1;
                    
                    // Define named range for subsidiaries
                    if (data.subsidiaries && data.subsidiaries.length > 0) {
                        context.workbook.names.add(`SubsidiaryLookup`, lookupSheet.getRange(`A${subStart}:B${subEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Departments section
                    lookupSheet.getRange(`A${currentRow}`).values = [['DEPARTMENTS']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const deptStart = currentRow;
                    (data.departments || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const deptEnd = currentRow - 1;
                    
                    if (data.departments && data.departments.length > 0) {
                        context.workbook.names.add(`DepartmentLookup`, lookupSheet.getRange(`A${deptStart}:B${deptEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Classes section
                    lookupSheet.getRange(`A${currentRow}`).values = [['CLASSES']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const classStart = currentRow;
                    (data.classes || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const classEnd = currentRow - 1;
                    
                    if (data.classes && data.classes.length > 0) {
                        context.workbook.names.add(`ClassLookup`, lookupSheet.getRange(`A${classStart}:B${classEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Locations section
                    lookupSheet.getRange(`A${currentRow}`).values = [['LOCATIONS']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const locStart = currentRow;
                    (data.locations || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const locEnd = currentRow - 1;
                    
                    if (data.locations && data.locations.length > 0) {
                        context.workbook.names.add(`LocationLookup`, lookupSheet.getRange(`A${locStart}:B${locEnd}`));
                    }
                    
                    // Auto-size columns
                    lookupSheet.getRange('A:B').format.autofitColumns();
                    
                    await context.sync();
                    
                    statusEl.innerHTML = ` Lookup sheet created!<br><small style="color: #1e40af;">Type names like "Hardware" or "Boston" in cells.<br>Use XLOOKUP to convert to IDs in formulas.</small>`;
                    statusEl.style.color = '#059669';
                });
                
            } catch (error) {
                console.error('Error creating lookup sheet:', error);
                statusEl.textContent = ' Error: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        Office.onReady(async (info) => {
            console.log('NetSuite Excel Add-in task pane loaded');
            console.log('   Platform:', info.platform);
            console.log('   Host:', info.host);
            console.log('   URL:', window.location.href);
            
            // TIMING FIX: On Mac, even inside Office.onReady, Excel.run can fail
            // if called too quickly during activation. Add small delay.
            await new Promise(r => setTimeout(r, 150));
            
            // Check for pending drilldown from sharedruntime.html (via localStorage)
            checkPendingDrilldown();
            
            // Also check URL param as fallback
            const urlParams = new URLSearchParams(window.location.search);
            const actionParam = urlParams.get('action');
            console.log('   action param:', actionParam);
            
            if (actionParam === 'drilldown') {
                console.log(' Opened via URL param - auto-triggering drill-down');
                await new Promise(r => setTimeout(r, 100));
                triggerContextMenuDrillDown();
            }
            
            // Start polling for pending drilldowns (from context menu)
            startPendingDrilldownListener();
            
            // SAFETY: Hide any stale loading overlays from previous sessions/crashes
            const staleOverlay = document.getElementById('loadingOverlay');
            if (staleOverlay) {
                staleOverlay.classList.remove('active');
            }
            
            // SAFETY: Hide status bar and clear stale status from localStorage
            const staleStatusBar = document.getElementById('statusBar');
            if (staleStatusBar) {
                staleStatusBar.style.display = 'none';
            }
            localStorage.removeItem('netsuite_status');
            
            // Start status polling AFTER cleanup - ignores any stale statuses
            startStatusPolling();
            
            // Set version in UI elements
            initializeVersion();
            
            // Start connection monitoring (checks every 60 seconds)
            startConnectionMonitor();
            
            // Auto-load lookups on open
            loadNetSuiteLookups();
            
            // CRITICAL: Preload ALL account titles to prevent 429 rate limit errors
            // This makes ONE query instead of 150+ concurrent queries
            preloadAccountTitles();
            
            // Show tutorial completion status if user has completed it before
            updateTutorialCompletionDisplay();
            
            // Handle Quick Start accordion for first-time users
            initializeQuickStart();
            
            // Set up worksheet change listener for auto-sync
            setupAutoSyncListener();
            
            // Initialize tab navigation
            initializeTabNavigation();
            
            // Initialize accordion drag/drop and restore saved order
            restoreSectionOrder();
            initDragAndDrop();
            
            // Initialize progressive disclosure view mode
            initViewMode();
            
            // Set up contextual UI with selection change listener
            setupSelectionChangeListener();
            
            // Initial contextual UI check (after short delay for Excel to be ready)
            setTimeout(() => updateContextualUI(), 500);
        });
        
        // Tab Navigation - switch between Data Management, Analytics, and Financial Reporting
        function initializeTabNavigation() {
            const tabs = {
                'tabDataMgmt': 'panelDataMgmt',
                'tabAnalytics': 'panelAnalytics',
                'tabFinancial': 'panelFinancial'
            };
            
            Object.keys(tabs).forEach(tabId => {
                const tabBtn = document.getElementById(tabId);
                if (tabBtn) {
                    tabBtn.addEventListener('click', () => switchTab(tabId, tabs));
                }
            });
        }
        
        function switchTab(activeTabId, tabs) {
            // Update tab buttons
            Object.keys(tabs).forEach(tabId => {
                const tabBtn = document.getElementById(tabId);
                const panel = document.getElementById(tabs[tabId]);
                
                if (tabId === activeTabId) {
                    tabBtn.classList.add('active');
                    panel.style.display = 'block';
                } else {
                    tabBtn.classList.remove('active');
                    panel.style.display = 'none';
                }
            });
        }
        
        // Initialize Quick Start section - expanded for first-time users, collapsed for returning users
        function initializeQuickStart() {
            const quickStartSection = document.getElementById('quickStartSection');
            const isReturningUser = localStorage.getItem('xavi_returning_user') === 'true';
            
            if (isReturningUser) {
                // Returning user - collapse the Quick Start section
                quickStartSection.removeAttribute('open');
                console.log('Returning user - Quick Start collapsed');
            } else {
                // First time user - keep it open (already open by default)
                console.log('First-time user - Quick Start expanded');
                // Mark as returning user for next time
                localStorage.setItem('xavi_returning_user', 'true');
            }
        }
        
        // ============================================
        // SUBSIDIARY CELL TRACKING - For smart currency format updates
        // ============================================
        let knownSubsidiaryCells = new Set();  // Cells that are referenced as subsidiary params
        let currencyFormatDebounceTimer = null;
        let formulaDetectionTimer = null;  // Timer for detecting new XAVI formulas
        let lastFormulaCount = 0;  // Track formula count to detect new additions
        
        // Track current sheet listener so we can re-register when switching sheets
        let currentSheetChangeHandler = null;
        let currentSheetName = null;
        
        // The actual change handler - extracted so it can be re-used when switching sheets
        async function handleSheetChange(event) {
            // Normalize the event address - strip sheet prefix and dollar signs
            let eventAddr = event.address;
            const rawAddr = eventAddr; // Keep for logging
            if (eventAddr.includes('!')) {
                eventAddr = eventAddr.split('!')[1];
            }
            eventAddr = eventAddr.replace(/\$/g, '').toUpperCase();
            
            // Debug: Log all cell changes to parameter row
            if (eventAddr.endsWith('3')) {
                console.log(` Cell changed: raw="${rawAddr}"  normalized="${eventAddr}"`);
            }
            
            // Check if the changed cell is P3 (YEAR parameter for auto-sync)
            if (eventAddr === 'P3') {
                console.log(' YEAR cell (P3) changed - raw address: ' + event.address);
                
                // CRITICAL: Suppress statusBar IMMEDIATELY to prevent "Fetching P&L" flash
                suppressStatusBar = true;
                localStorage.removeItem('netsuite_status');
                hideStatus();
                
                await handleYearChange();
            }
            
            // Check if the changed cell is Q3 (SUBSIDIARY parameter for auto-sync)
            // Use debounce to prevent rapid-fire triggering
            if (eventAddr === 'Q3') {
                console.log(' SUBSIDIARY cell (Q3) changed - raw address: ' + event.address);
                
                // CRITICAL: Suppress and HIDE statusBar IMMEDIATELY (not after debounce!)
                // This prevents the "Fetching P&L data" window from ever appearing
                suppressStatusBar = true;
                localStorage.removeItem('netsuite_status');
                hideStatus();  // Hide immediately if already showing
                
                if (window.subsidiaryChangeTimer) {
                    clearTimeout(window.subsidiaryChangeTimer);
                }
                window.subsidiaryChangeTimer = setTimeout(async () => {
                    console.log(' SUBSIDIARY debounce complete - triggering updates...');
                    
                    // Re-suppress in case polling started again
                    suppressStatusBar = true;
                    localStorage.removeItem('netsuite_status');
                    hideStatus();
                    
                    // Check for structure sync FIRST (shows the overlay immediately)
                    // This must happen BEFORE smartCurrencyFormatUpdate which triggers recalc
                    await handleSubsidiaryChange();
                    
                    // Currency update happens inside performStructureSync now
                }, 500); // Reduced to 500ms - we're hiding status anyway
            }
            
            // Check if the changed cell is a filter parameter (R3, S3, T3, U3)
            // These trigger CFO Sync OR Income Statement Filter Sync
            const filterCells = ['R3', 'S3', 'T3', 'U3'];
            if (filterCells.includes(eventAddr)) {
                console.log(` Filter cell ${eventAddr} changed! (raw: ${event.address}) `);
                
                // Suppress statusBar immediately
                suppressStatusBar = true;
                localStorage.removeItem('netsuite_status');
                hideStatus();
                
                if (window.filterChangeTimer) {
                    console.log(' Clearing previous filter timer');
                    clearTimeout(window.filterChangeTimer);
                }
                console.log(' Setting 500ms debounce timer for handleFilterChange()...');
                window.filterChangeTimer = setTimeout(async () => {
                    console.log(' Filter debounce complete - calling handleFilterChange() NOW');
                    
                    suppressStatusBar = true;
                    localStorage.removeItem('netsuite_status');
                    hideStatus();
                    
                    // Check if this is a CFO Flash Report or Income Statement and trigger sync
                    try {
                        await handleFilterChange();
                    } catch (e) {
                        console.error(' handleFilterChange() threw error:', e.message);
                    }
                }, 500);
            }
            
            // ============================================
            // DETECT NEW XAVI FORMULAS
            // When user adds/pastes/drags formulas, we need to:
            // 1. Re-scan for subsidiary cells
            // 2. Re-apply currency formatting
            // ============================================
            if (formulaDetectionTimer) {
                clearTimeout(formulaDetectionTimer);
            }
            formulaDetectionTimer = setTimeout(async () => {
                await checkForNewFormulas();
            }, 2000); // 2 second debounce after typing stops
            
            // ============================================
            // SMART CURRENCY FORMAT UPDATE
            // Check if changed cell is a known subsidiary reference
            // ============================================
            // Normalize address: remove sheet name prefix, dollar signs, convert to uppercase
            let normalizedAddress = event.address;
            if (normalizedAddress.includes('!')) {
                normalizedAddress = normalizedAddress.split('!')[1];
            }
            normalizedAddress = normalizedAddress.replace(/\$/g, '').toUpperCase();
            
            if (knownSubsidiaryCells.has(normalizedAddress)) {
                console.log(` Known subsidiary cell ${normalizedAddress} changed, triggering smart currency update...`);
                await smartCurrencyFormatUpdate(normalizedAddress);
            }
        }
        
        // Register change listener for the current active sheet
        async function registerSheetChangeListener() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    sheet.load('name');
                    await context.sync();
                    
                    const sheetName = sheet.name;
                    
                    // Skip if already registered for this sheet
                    if (currentSheetName === sheetName) {
                        console.log(` Change listener already registered for "${sheetName}"`);
                        return;
                    }
                    
                    // Register new listener
                    sheet.onChanged.add(handleSheetChange);
                    await context.sync();
                    
                    currentSheetName = sheetName;
                    console.log(` Change listener registered for sheet "${sheetName}"`);
                });
            } catch (e) {
                console.warn('Could not register sheet change listener:', e.message);
            }
        }
        
        // Set up listener to auto-sync Income Statement when YEAR changes
        // AND smart currency format updates when subsidiary cells change
        // AND detect new XAVI formulas being added
        async function setupAutoSyncListener() {
            // Register change listener for initial active sheet
            await registerSheetChangeListener();
            
            // Do an initial scan to populate knownSubsidiaryCells
            await scanForSubsidiaryCells();
            
            // Set up worksheet activation listener (separate Excel.run)
            // This re-registers the change listener when user switches sheets
            try {
                await Excel.run(async (ctx) => {
                    ctx.workbook.worksheets.onActivated.add(async (event) => {
                        console.log(' Worksheet activated - re-registering listeners and re-scanning...');
                        
                        // Reset formula count and subsidiary cells for new sheet
                        lastFormulaCount = 0;
                        knownSubsidiaryCells.clear();
                        
                        // Reset sync state for new sheet
                        lastSyncedYear = '';
                        lastSyncedSubsidiary = '';
                        isSyncInProgress = false;
                        
                        // Re-register change listener for the new sheet
                        await registerSheetChangeListener();
                        
                        // Re-scan the new sheet for subsidiary cells
                        await scanForSubsidiaryCells();
                    });
                    await ctx.sync();
                    console.log(' Worksheet activation listener registered');
                });
            } catch (e) {
                console.warn('Could not set up worksheet activation listener:', e.message);
            }
        }
        
        // Check if new XAVI formulas were added and apply formatting
        // Also auto-fetches TYPEBALANCE batch data when new TYPEBALANCE formulas are detected
        let lastTypeBalanceCount = 0;
        let typeBalanceBatchFetched = false;
        
        async function checkForNewFormulas() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load('formulas');
                    await context.sync();
                    
                    // Count XAVI.BALANCE and XAVI.TYPEBALANCE formulas
                    let balanceCount = 0;
                    let typeBalanceCount = 0;
                    const formulas = usedRange.formulas;
                    for (let row = 0; row < formulas.length; row++) {
                        for (let col = 0; col < formulas[row].length; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula === 'string') {
                                const upper = formula.toUpperCase();
                                if (upper.includes('XAVI.BALANCE') && !upper.includes('XAVI.TYPEBALANCE')) {
                                    balanceCount++;
                                }
                                if (upper.includes('XAVI.TYPEBALANCE')) {
                                    typeBalanceCount++;
                                }
                            }
                        }
                    }
                    
                    // If BALANCE formula count changed, we have new formulas - rescan and format
                    if (balanceCount !== lastFormulaCount) {
                        console.log(` BALANCE formula count changed: ${lastFormulaCount}  ${balanceCount}`);
                        lastFormulaCount = balanceCount;
                        
                        if (balanceCount > 0) {
                            // Re-scan for subsidiary cells
                            await scanForSubsidiaryCells();
                            
                            // Auto-apply currency formatting to new formulas
                            console.log(' Applying currency formatting to new formulas...');
                            await autoFormatCurrencies();
                        }
                    }
                    
                    // If TYPEBALANCE formulas detected and we haven't fetched batch data yet
                    if (typeBalanceCount > 0 && typeBalanceCount !== lastTypeBalanceCount && !typeBalanceBatchFetched) {
                        console.log(` TYPEBALANCE formulas detected: ${typeBalanceCount} - triggering batch pre-fetch...`);
                        lastTypeBalanceCount = typeBalanceCount;
                        
                        // Trigger batch fetch in background (don't await - let it run async)
                        autoFetchTypeBalanceBatch();
                    }
                });
            } catch (e) {
                console.warn('Formula detection check failed:', e.message);
            }
        }
        
        // Auto-fetch TYPEBALANCE batch data when new formulas are detected
        // This runs in the background so formulas can resolve from cache
        async function autoFetchTypeBalanceBatch() {
            if (typeBalanceBatchFetched) {
                console.log(' TypeBalance batch already fetched - skipping');
                return;
            }
            
            try {
                const currentYear = new Date().getFullYear();
                
                // Try to get subsidiary from P3/Q3 cells (standard report layout)
                let subsidiary = '';
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const subCell = sheet.getRange('Q3');
                        subCell.load('values');
                        await context.sync();
                        subsidiary = subCell.values[0][0] || '';
                    });
                } catch (e) {
                    // Ignore - use empty subsidiary
                }
                
                console.log(` Auto-fetching TYPEBALANCE batch for ${currentYear}, subsidiary: "${subsidiary || '(all)'}"`);
                
                const response = await fetch(`${SERVER_URL}/batch/typebalance_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: subsidiary,
                        department: '',
                        location: '',
                        classId: '',
                        accountingBook: ''
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const balances = data.balances || {};
                    const typesLoaded = Object.keys(balances).length;
                    
                    console.log(` Auto-fetched ${typesLoaded} account types  12 months`);
                    
                    // Populate the frontend cache
                    if (typeof window.setTypeBalanceCache === 'function') {
                        window.setTypeBalanceCache(
                            balances, currentYear, subsidiary, '', '', '', '', false
                        );
                        typeBalanceBatchFetched = true;
                        console.log(' TypeBalance cache populated - formulas should resolve instantly now!');
                    }
                } else {
                    console.warn(' TypeBalance batch fetch failed:', response.status);
                }
            } catch (e) {
                console.warn(' TypeBalance auto-fetch error:', e.message);
            }
        }
        
        // Scan sheet to find all cells referenced as subsidiary parameters
        // Handles BALANCE, TYPEBALANCE, NETINCOME, and BUDGET formulas
        async function scanForSubsidiaryCells() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load('formulas');
                    await context.sync();
                    
                    knownSubsidiaryCells.clear();
                    const formulas = usedRange.formulas;
                    let formulaCount = 0;
                    
                    for (let row = 0; row < formulas.length; row++) {
                        for (let col = 0; col < formulas[row].length; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula !== 'string') continue;
                            
                            const upperFormula = formula.toUpperCase();
                            let subsidiaryParam = '';
                            
                            // Extract subsidiary param based on formula type
                            // Subsidiary param positions:
                            // - XAVI.BALANCE(acct, from, to, [sub], ...) - index 3
                            // - XAVI.TYPEBALANCE(type, from, to, [sub], ...) - index 3
                            // - XAVI.NETINCOME(from, [to], [sub], ...) - index 2
                            // - XAVI.BUDGET(acct, from, to, [sub], ...) - index 3
                            if (upperFormula.includes('XAVI.BALANCE') && !upperFormula.includes('XAVI.TYPEBALANCE')) {
                                formulaCount++;
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                                formulaCount++;
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else if (upperFormula.includes('XAVI.NETINCOME')) {
                                formulaCount++;
                                subsidiaryParam = extractFormulaParam(formula, 2);
                            } else if (upperFormula.includes('XAVI.BUDGET')) {
                                formulaCount++;
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else {
                                continue;
                            }
                            
                                // If it's a cell reference (not a number or quoted string)
                                if (subsidiaryParam && 
                                    !subsidiaryParam.startsWith('"') && 
                                    !subsidiaryParam.startsWith("'") && 
                                    !/^\d+$/.test(subsidiaryParam)) {
                                    // Normalize and add to known cells
                                    const normalized = subsidiaryParam.replace(/\$/g, '').toUpperCase();
                                    knownSubsidiaryCells.add(normalized);
                            }
                        }
                    }
                    
                    // Update formula count for change detection
                    lastFormulaCount = formulaCount;
                    
                    if (knownSubsidiaryCells.size > 0) {
                        console.log(` Tracking ${knownSubsidiaryCells.size} subsidiary reference cells:`, [...knownSubsidiaryCells]);
                    }
                    console.log(` Initial XAVI formula count: ${formulaCount}`);
                });
            } catch (e) {
                console.warn('Could not scan for subsidiary cells:', e.message);
            }
        }
        
        // Smart currency format update - only runs if a subsidiary cell changed
        async function smartCurrencyFormatUpdate() {
            try {
                console.log(' Running smart currency format update...');
                
                // ============================================
                // CRITICAL: Clear ALL caches when subsidiary changes!
                // The taskpane and custom functions run in SEPARATE JavaScript
                // contexts, so we can't directly call window.clearAllCaches().
                // Instead, we use localStorage as a cross-context signal.
                // ============================================
                console.log(' Clearing caches for subsidiary change');
                
                // Clear localStorage cache
                try {
                    localStorage.removeItem('netsuite_balance_cache');
                    localStorage.removeItem('netsuite_balance_cache_timestamp');
                    localStorage.removeItem('netsuite_typebalance_cache');
                    localStorage.removeItem('netsuite_typebalance_cache_timestamp');
                } catch (e) {
                    console.warn('    localStorage clear failed:', e.message);
                }
                
                // CRITICAL: Signal to functions.js to clear its in-memory cache
                // The BALANCE function will check this flag and clear cache if needed
                try {
                    localStorage.setItem('netsuite_cache_clear_signal', JSON.stringify({
                        timestamp: Date.now(),
                        reason: 'subsidiary_change'
                    }));
                } catch (e) {
                    console.warn('    Cache signal failed:', e.message);
                }
                
                // Get year, subsidiary, and other filters from the sheet
                // CFO Flash uses: Q3=subsidiary, R3=department, S3=location, T3=class, U3=accountingBook
                let year = new Date().getFullYear();
                let subsidiary = '';
                let department = '';
                let location = '';
                let classId = '';
                let accountingBook = '';
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const yearCell = sheet.getRange("P3");
                        const subCell = sheet.getRange("Q3");
                        const deptCell = sheet.getRange("R3");
                        const locCell = sheet.getRange("S3");
                        const classCell = sheet.getRange("T3");
                        const bookCell = sheet.getRange("U3");
                        yearCell.load("values");
                        subCell.load("values");
                        deptCell.load("values");
                        locCell.load("values");
                        classCell.load("values");
                        bookCell.load("values");
                        await context.sync();
                        year = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                        subsidiary = String(subCell.values[0][0] || '').trim();
                        department = String(deptCell.values[0][0] || '').trim();
                        location = String(locCell.values[0][0] || '').trim();
                        classId = String(classCell.values[0][0] || '').trim();
                        accountingBook = String(bookCell.values[0][0] || '').trim();
                    });
                } catch (e) {
                    console.warn('Could not read year/subsidiary/filters:', e.message);
                }
                
                // Show user feedback
                try {
                    const statusEl = document.getElementById('filterStatus');
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #dbeafe; padding: 8px; border-radius: 4px; font-size: 11px;">
                            <strong style="color: #1e40af;"> Subsidiary changed to "${subsidiary}"</strong><br>
                            <small>Pre-fetching data for fast formula resolution...</small>
                        </div>`;
                    }
                } catch (e) {}
                
                // ============================================
                // PRE-FETCH TYPEBALANCE DATA FOR NEW SUBSIDIARY
                // This dramatically speeds up CFO Flash Report when subsidiary changes
                // ============================================
                try {
                    console.log(` Pre-fetching TYPEBALANCE data for ${year}, subsidiary="${subsidiary}"...`);
                    console.log(`   Filters: dept="${department}", loc="${location}", class="${classId}", book="${accountingBook}"`);
                    const typeBalanceResponse = await fetch(`${SERVER_URL}/batch/typebalance_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: year,
                            subsidiary: subsidiary,
                            department: department,
                            location: location,
                            classId: classId,
                            accountingBook: accountingBook
                        })
                    });
                    
                    if (typeBalanceResponse.ok) {
                        const data = await typeBalanceResponse.json();
                        const balances = data.balances || {};
                        console.log(` Pre-fetched ${Object.keys(balances).length} account types for TYPEBALANCE`);
                        
                        // Save to localStorage for functions.js to use
                        // IMPORTANT: functions.js expects { balances: { key: value, ... } } format
                        // Cache key must match exactly what TYPEBALANCE function generates
                        try {
                            const cacheEntries = {};
                            for (const accountType in balances) {
                                const monthData = balances[accountType];
                                for (const period in monthData) {
                                    // Single month entries - key format must match TYPEBALANCE function
                                    // Format: typebalance:${type}:${from}:${to}:${sub}:${dept}:${loc}:${class}:${book}:${special}
                                    // NOTE: We include all filter values to match what the formulas will generate
                                    // IMPORTANT: Must trim all values - TYPEBALANCE function uses .trim() on all parameters
                                    const key = `typebalance:${accountType}:${period}:${period}:${(subsidiary || '').trim()}:${(department || '').trim()}:${(location || '').trim()}:${(classId || '').trim()}:${(accountingBook || '').trim()}:0`;
                                    cacheEntries[key] = monthData[period];
                                }
                            }
                            // Wrap in { balances: ... } format that functions.js expects
                            localStorage.setItem('netsuite_typebalance_cache', JSON.stringify({ balances: cacheEntries }));
                            localStorage.setItem('netsuite_typebalance_cache_timestamp', Date.now().toString());
                            console.log(` Saved ${Object.keys(cacheEntries).length} TYPEBALANCE cache entries to localStorage`);
                            console.log(`   Filters: sub="${subsidiary}", dept="${department}", loc="${location}", class="${classId}", book="${accountingBook}"`);
                            console.log(`   Sample keys: ${Object.keys(cacheEntries).slice(0, 2).join(', ')}`);
                        } catch (e) {
                            console.warn('TYPEBALANCE cache save failed:', e.message);
                        }
                        
                        // Also populate in-memory cache if setTypeBalanceCache is available
                        if (typeof window.setTypeBalanceCache === 'function') {
                            window.setTypeBalanceCache(balances, year, subsidiary, department, location, classId, accountingBook, false);
                        }
                        
                        // ============================================
                        // CRITICAL: Force TYPEBALANCE formulas to recalculate NOW
                        // Excel already recalculated them BEFORE our pre-fetch completed,
                        // so we need to trigger a SECOND recalculation to hit the cache
                        // ============================================
                        console.log(` Triggering TYPEBALANCE formula recalculation to use pre-fetched cache...`);
                        try {
                            await Excel.run(async (context) => {
                                const sheet = context.workbook.worksheets.getActiveWorksheet();
                                const usedRange = sheet.getUsedRange();
                                // IMPORTANT: Must load rowCount, columnCount, AND formulas before using
                                usedRange.load(["formulas", "rowCount", "columnCount"]);
                                await context.sync();
                                
                                const formulas = usedRange.formulas;
                                const rowCount = usedRange.rowCount;
                                const columnCount = usedRange.columnCount;
                                let typebalanceCount = 0;
                                
                                for (let row = 0; row < rowCount; row++) {
                                    for (let col = 0; col < columnCount; col++) {
                                        const formula = formulas[row][col];
                                        if (typeof formula === 'string' && formula.toUpperCase().includes('XAVI.TYPEBALANCE')) {
                                            const cell = usedRange.getCell(row, col);
                                            cell.calculate();
                                            typebalanceCount++;
                                        }
                                    }
                                }
                                await context.sync();
                                console.log(` Triggered recalculation of ${typebalanceCount} TYPEBALANCE formulas - they should now hit cache`);
                            });
                        } catch (recalcError) {
                            console.warn('TYPEBALANCE recalculation trigger failed:', recalcError.message);
                        }
                    }
                } catch (e) {
                    console.warn('TYPEBALANCE pre-fetch failed:', e.message);
                }
                
                // Re-scan for subsidiary cells (in case new formulas were added)
                await scanForSubsidiaryCells();
                
                // Wait a bit for formulas to resolve before formatting
                // This ensures we format cells AFTER they show values, not #BUSY
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Re-apply currency formatting (uses cached data, very fast)
                await autoFormatCurrencies();
                
                console.log(' Currency formats updated - formulas will now refetch data with new subsidiary');
                
                // Update status to show completion
                try {
                    const statusEl = document.getElementById('filterStatus');
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #d1fae5; padding: 8px; border-radius: 4px; font-size: 11px;">
                            <strong style="color: #059669;"> Ready!</strong> Data pre-fetched for "${subsidiary}"
                        </div>`;
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    }
                } catch (e) {}
                
            } catch (e) {
                console.warn('Smart currency format update failed:', e.message);
            }
        }
        
        // Flag to prevent re-entry during sync operations
        let isSyncInProgress = false;
        let lastSyncedYear = null;
        let lastSyncedSubsidiary = null;
        
        // Handle automatic structure sync when YEAR changes
        async function handleYearChange() {
            // Prevent infinite loop - don't sync if already syncing
            if (isSyncInProgress) {
                console.log(' Sync already in progress, skipping...');
                return;
            }
            
            try {
                let shouldSync = false;
                let isCFOFlash = false;
                let newYear = null;
                let subsidiary = '';
                let department = '';
                let location = '';
                let classId = '';
                let accountingBook = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check for sync marker (V2 = label, V3 = value)
                    const markerCell = sheet.getRange("V2");
                    markerCell.load("values");
                    const syncCell = sheet.getRange("V3");
                    syncCell.load("values");
                    const yearCell = sheet.getRange("P3");
                    yearCell.load("values");
                    const subCell = sheet.getRange("Q3");
                    subCell.load("values");
                    const deptCell = sheet.getRange("R3");
                    deptCell.load("values");
                    const locCell = sheet.getRange("S3");
                    locCell.load("values");
                    const classCell = sheet.getRange("T3");
                    classCell.load("values");
                    const bookCell = sheet.getRange("U3");
                    bookCell.load("values");
                    
                    await context.sync();
                    
                    const marker = String(markerCell.values[0][0] || '').toLowerCase();
                    const sync = String(syncCell.values[0][0] || '').toUpperCase();
                    newYear = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                    department = deptCell.values[0][0] || '';
                    location = locCell.values[0][0] || '';
                    classId = classCell.values[0][0] || '';
                    accountingBook = bookCell.values[0][0] || '';
                    
                    // Check for CFO Flash Report marker
                    if (marker.includes('cfo sync') || marker.includes('cfo')) {
                        isCFOFlash = true;
                    }
                    
                    // Only sync if: has marker, sync enabled, AND year actually changed
                    if ((marker.includes('structure sync') || marker.includes('cfo sync') || marker.includes('')) &&
                        (sync === 'TRUE' || sync === 'YES' || sync === '1') &&
                        String(newYear) !== String(lastSyncedYear)) {
                        shouldSync = true;
                        subsidiary = subCell.values[0][0] || '';
                        console.log(` Year change detected: ${lastSyncedYear}  ${newYear} (CFO: ${isCFOFlash})`);
                    } else {
                        console.log(` Year sync check: marker="${marker}", sync="${sync}", year=${newYear}, lastSynced=${lastSyncedYear}`);
                    }
                });
                
                if (shouldSync && newYear) {
                    console.log(` Auto-syncing for year ${newYear}... (CFO Flash: ${isCFOFlash})`);
                    
                    // Set flag to prevent re-entry
                    isSyncInProgress = true;
                    lastSyncedYear = newYear;
                    
                    // Suppress statusBar immediately
                    suppressStatusBar = true;
                    localStorage.removeItem('netsuite_status');
                    hideStatus();
                    
                    try {
                        if (isCFOFlash) {
                            // CFO Flash: Simpler sync with all filter values
                            await performCFOSync(newYear, subsidiary, department, location, classId, accountingBook);
                        } else {
                            // Full Income Statement: Full structure rebuild
                        await performStructureSync(newYear, subsidiary);
                        }
                    } finally {
                        // Clear sync flag after a delay
                        setTimeout(() => {
                            isSyncInProgress = false;
                            console.log(' Year sync protection cleared');
                        }, 3000);
                    }
                }
            } catch (e) {
                console.warn('Auto-sync error:', e.message);
                setTimeout(() => { isSyncInProgress = false; }, 3000);
            }
        }
        
        // Handle subsidiary change - trigger structure sync if enabled
        async function handleSubsidiaryChange() {
            console.log(' handleSubsidiaryChange() called');
            console.log(`   isSyncInProgress: ${isSyncInProgress}`);
            console.log(`   lastSyncedSubsidiary: "${lastSyncedSubsidiary}"`);
            
            // Prevent infinite loop - don't sync if already syncing
            if (isSyncInProgress) {
                console.log(' Sync already in progress, skipping subsidiary change...');
                return;
            }
            
            try {
                let shouldSync = false;
                let isCFOFlash = false;  // Track if this is CFO Flash Report
                let year = null;
                let newSubsidiary = '';
                let department = '';
                let location = '';
                let classId = '';
                let accountingBook = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check for sync marker (V2 = label, V3 = value)
                    const markerCell = sheet.getRange("V2");
                    markerCell.load("values");
                    const syncCell = sheet.getRange("V3");
                    syncCell.load("values");
                    const yearCell = sheet.getRange("P3");
                    yearCell.load("values");
                    const subCell = sheet.getRange("Q3");
                    subCell.load("values");
                    const deptCell = sheet.getRange("R3");
                    deptCell.load("values");
                    const locCell = sheet.getRange("S3");
                    locCell.load("values");
                    const classCell = sheet.getRange("T3");
                    classCell.load("values");
                    const bookCell = sheet.getRange("U3");
                    bookCell.load("values");
                    
                    await context.sync();
                    
                    const marker = String(markerCell.values[0][0] || '').toLowerCase();
                    const sync = String(syncCell.values[0][0] || '').toUpperCase();
                    year = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                    newSubsidiary = subCell.values[0][0] || '';
                    department = deptCell.values[0][0] || '';
                    location = locCell.values[0][0] || '';
                    classId = classCell.values[0][0] || '';
                    accountingBook = bookCell.values[0][0] || '';
                    
                    // Check for CFO Flash Report marker
                    if (marker.includes('cfo sync') || marker.includes('cfo')) {
                        isCFOFlash = true;
                    }
                    
                    // Only sync if: has marker, sync enabled, AND subsidiary actually changed
                    if ((marker.includes('structure sync') || marker.includes('cfo sync') || marker.includes('')) &&
                        (sync === 'TRUE' || sync === 'YES' || sync === '1') &&
                        String(newSubsidiary).trim() !== String(lastSyncedSubsidiary).trim()) {
                        shouldSync = true;
                        console.log(` Subsidiary change detected: "${lastSyncedSubsidiary}"  "${newSubsidiary}" (CFO: ${isCFOFlash})`);
                    } else {
                        console.log(` Subsidiary sync check: marker="${marker}", sync="${sync}", sub="${newSubsidiary}", lastSynced="${lastSyncedSubsidiary}"`);
                    }
                });
                
                if (shouldSync && year) {
                    console.log(` Auto-syncing for subsidiary "${newSubsidiary}"... (CFO Flash: ${isCFOFlash})`);
                    
                    // Set flag to prevent re-entry
                    isSyncInProgress = true;
                    lastSyncedSubsidiary = newSubsidiary;
                    
                    try {
                        if (isCFOFlash) {
                            // CFO Flash: Simpler sync with all filter values
                            await performCFOSync(year, newSubsidiary, department, location, classId, accountingBook);
                        } else {
                            // Full Income Statement: Full structure rebuild
                        await performStructureSync(year, newSubsidiary);
                        }
                    } finally {
                        // Clear sync flag after a delay to let any queued change events fire first
                        setTimeout(() => {
                            isSyncInProgress = false;
                            console.log(' Subsidiary sync protection cleared');
                        }, 3000);
                    }
                }
            } catch (e) {
                console.warn('Auto-sync (subsidiary) error:', e.message);
                setTimeout(() => { isSyncInProgress = false; }, 3000);
            }
        }
        
        // Handle filter change (R3, S3, T3, U3) - triggers CFO Sync OR Income Statement Filter Sync
        async function handleFilterChange() {
            console.log(' handleFilterChange() called - checking report type...');
            
            // Prevent infinite loop - but also add a safety valve
            if (isSyncInProgress) {
                console.log(' Sync already in progress, skipping filter change...');
                return;
            }
            
            try {
                let syncType = null; // 'cfo' or 'income'
                let year = null;
                let subsidiary = '';
                let department = '';
                let location = '';
                let classId = '';
                let accountingBook = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check for Sync marker
                    const markerCell = sheet.getRange("V2");
                    markerCell.load("values");
                    const syncCell = sheet.getRange("V3");
                    syncCell.load("values");
                    
                    // Read all filter values
                    const yearCell = sheet.getRange("P3");
                    yearCell.load("values");
                    const subCell = sheet.getRange("Q3");
                    subCell.load("values");
                    const deptCell = sheet.getRange("R3");
                    deptCell.load("values");
                    const locCell = sheet.getRange("S3");
                    locCell.load("values");
                    const classCell = sheet.getRange("T3");
                    classCell.load("values");
                    const bookCell = sheet.getRange("U3");
                    bookCell.load("values");
                    
                    await context.sync();
                    
                    const rawMarker = String(markerCell.values[0][0] || '');
                    const marker = rawMarker.toLowerCase().trim();
                    const rawSync = String(syncCell.values[0][0] || '');
                    const sync = rawSync.toUpperCase().trim();
                    
                    console.log(` Filter change: V2 raw="${rawMarker}", V3 raw="${rawSync}"`);
                    console.log(` Filter change: marker="${marker}", sync="${sync}"`);
                    
                    year = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                    subsidiary = subCell.values[0][0] || '';
                    department = deptCell.values[0][0] || '';
                    location = locCell.values[0][0] || '';
                    classId = classCell.values[0][0] || '';
                    accountingBook = bookCell.values[0][0] || '';
                    
                    console.log(` Filter values: year=${year}, sub="${subsidiary}", dept="${department}", loc="${location}", class="${classId}", book="${accountingBook}"`);
                    
                    // Check for CFO Flash Reports - check multiple variations
                    const isCFO = marker.includes('cfo sync') || marker.includes('cfo flash') || marker.includes('cfo');
                    const syncEnabled = sync === 'TRUE' || sync === 'YES' || sync === '1';
                    
                    console.log(` Detection: isCFO=${isCFO}, isStructure=${marker.includes('structure sync')}, syncEnabled=${syncEnabled}`);
                    
                    if (isCFO && syncEnabled) {
                        syncType = 'cfo';
                        console.log(`  Detected CFO Flash Report - will trigger performCFOSync()`);
                    }
                    // Check for Income Statement (Structure Sync marker) - but NOT if it's a CFO report
                    else if ((marker.includes('structure sync') || (marker.includes('') && !marker.includes('cfo'))) && syncEnabled) {
                        syncType = 'income';
                        console.log(`  Detected Income Statement - will trigger performIncomeStatementFilterSync()`);
                    } else {
                        console.log(`  No matching report type - no sync will be triggered`);
                        console.log(`    (isCFO=${isCFO}, isStructure=${marker.includes('structure sync')}, syncEnabled=${syncEnabled})`);
                    }
                });
                
                if (syncType && year) {
                    console.log(` Starting Filter Sync (${syncType}): dept="${department}", loc="${location}", class="${classId}"`);
                    
                    isSyncInProgress = true;
                    
                    try {
                        if (syncType === 'cfo') {
                            console.log(' Calling performCFOSync()...');
                            await performCFOSync(year, subsidiary, department, location, classId, accountingBook);
                            console.log(' performCFOSync() completed');
                        } else if (syncType === 'income') {
                            // Use filter sync which waits for recalc + removes zero rows (NOT full Structure Sync)
                            console.log(' Calling performIncomeStatementFilterSync()...');
                            await performIncomeStatementFilterSync(year, subsidiary, department, location, classId, accountingBook);
                            console.log(' performIncomeStatementFilterSync() completed');
                        }
                    } catch (syncError) {
                        console.error(` Sync error (${syncType}):`, syncError.message);
                    } finally {
                        setTimeout(() => {
                            isSyncInProgress = false;
                            console.log(' Filter sync protection cleared');
                        }, 3000);
                    }
                } else {
                    console.log(` No sync triggered: syncType=${syncType}, year=${year}`);
                }
            } catch (e) {
                console.error(' Filter change error:', e.message);
                setTimeout(() => { isSyncInProgress = false; }, 3000);
            }
        }
        
        // Perform Income Statement filter sync - shows overlay while formulas recalculate
        async function performIncomeStatementFilterSync(targetYear, currentSubsidiary, department = '', location = '', classId = '', accountingBook = '') {
            console.log(` Income Statement Filter Sync starting for year=${targetYear}, subsidiary="${currentSubsidiary}"`);
            
            // Suppress the small status bar - we're showing our own overlay
            suppressStatusBar = true;
            localStorage.removeItem('netsuite_status');
            hideStatus();
            
            const syncStartTime = Date.now();
            
            // Get currency info
            let currencyFormat = '$#,##0.00';
            let currencySymbol = '$';
            let currencyFlag = '';
            
            try {
                const currencyData = await getCurrencyData();
                if (currencyData && currentSubsidiary) {
                    const subsidiaryNameToId = await getSubsidiaryLookup();
                    const subId = /^\d+$/.test(currentSubsidiary) ? 
                        currentSubsidiary : 
                        (subsidiaryNameToId[currentSubsidiary.toLowerCase()] || currencyData.default_subsidiary);
                    currencySymbol = currencyData.currencies[subId] || currencyData.currencies[currencyData.default_subsidiary] || '$';
                    currencyFormat = currencyData.formats[currencySymbol] || '$#,##0.00';
                    currencyFlag = getCurrencyFlag(currencySymbol);
                    console.log(` Income Statement Filter Sync currency: "${currentSubsidiary}"  ${currencyFlag} ${currencySymbol}`);
                }
            } catch (e) {
                console.warn('Currency lookup failed:', e.message);
            }
            
            // Build filter summary
            const filters = [];
            if (department) filters.push(`Dept: ${department}`);
            if (classId) filters.push(`Class: ${classId}`);
            if (location) filters.push(`Location: ${location}`);
            if (accountingBook) filters.push(`Book: ${accountingBook}`);
            const filterSummary = filters.length > 0 ? filters.join('  ') : 'No additional filters';
            
            // Show full-screen overlay
            const syncOverlay = document.createElement('div');
            syncOverlay.id = 'structureSyncOverlay';
            syncOverlay.className = 'guide-me-overlay';
            syncOverlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2> Filter Update</h2>
                <div class="loading-subtitle">
                    Recalculating <strong>${targetYear}</strong> Income Statement for <strong>"${currentSubsidiary || 'All Subsidiaries'}"</strong>
                </div>
                <div style="margin: 8px auto; font-size: 12px; color: #93c5fd;">${filterSummary}</div>
                <div style="margin: 16px auto; display: flex; align-items: center; justify-content: center; gap: 12px; 
                            padding: 12px 24px; background: rgba(10, 226, 193, 0.15); border-radius: 12px; border: 1px solid rgba(10, 226, 193, 0.3);">
                    <span style="font-size: 32px;">${currencyFlag}</span>
                    <div style="text-align: left;">
                        <div style="font-size: 11px; color: #93c5fd; text-transform: uppercase;">Currency</div>
                        <div style="font-size: 22px; font-weight: bold; color: #0AE2C1;">${currencySymbol}</div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="syncProgressBar" style="width: 30%; animation: syncPulse 1.5s infinite;"></div>
                    </div>
                    <div class="progress-text">Recalculating...</div>
                </div>
                <div class="loading-step"><span class="spreadsheet-animation"></span> Recalculating formulas...</div>
                <div class="loading-step-desc">BALANCE formulas are refreshing with new filter values.</div>
            `;
            document.body.appendChild(syncOverlay);
            
            // Add pulse animation
            const style = document.createElement('style');
            style.id = 'syncPulseStyle';
            style.textContent = `
                @keyframes syncPulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.7; }
                }
            `;
            document.head.appendChild(style);
            
            const loadingStep = syncOverlay.querySelector('.loading-step');
            const loadingDesc = syncOverlay.querySelector('.loading-step-desc');
            
            // Signal cache clear to functions.js
            localStorage.setItem('netsuite_cache_clear_signal', JSON.stringify({
                action: 'clear_balance',
                timestamp: Date.now()
            }));
            
            // Brief pause to let signal propagate
            await new Promise(r => setTimeout(r, 500));
            
            if (loadingStep) loadingStep.innerHTML = '<span class="spreadsheet-animation"></span> Tucking everything into place...';
            if (loadingDesc) loadingDesc.textContent = 'BALANCE formulas are refreshing with new filter values.';
            
            // Wait for formulas to resolve
            await waitForFormulasToComplete(90000, null);
            
            // Remove rows where ALL numeric values are zero (same as Structure Sync)
            if (loadingStep) loadingStep.innerHTML = '<span class="spreadsheet-animation"></span> Removing zero rows...';
            if (loadingDesc) loadingDesc.textContent = 'Cleaning up rows with no values.';
            
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load(['values', 'rowCount', 'columnCount']);
                    await context.sync();
                    
                    const values = usedRange.values;
                    const rowsToDelete = [];
                    
                    // Start from row 5 (index 4) - skip header rows and parameter row
                    // Check each data row
                    for (let i = 4; i < values.length; i++) {
                        const row = values[i];
                        // Check columns C through O (indices 2-14) for numeric values
                        let allZero = true;
                        let hasNumericValue = false;
                        
                        for (let j = 2; j <= 14 && j < row.length; j++) {
                            const val = row[j];
                            if (typeof val === 'number') {
                                hasNumericValue = true;
                                if (val !== 0) {
                                    allZero = false;
                                    break;
                                }
                            }
                        }
                        
                        // Only delete if we found numeric values and they're all zero
                        if (hasNumericValue && allZero) {
                            rowsToDelete.push(i + 1); // Excel rows are 1-indexed
                        }
                    }
                    
                    // Delete rows from bottom to top to preserve indices
                    if (rowsToDelete.length > 0) {
                        console.log(` Removing ${rowsToDelete.length} rows with all zeros`);
                        rowsToDelete.sort((a, b) => b - a); // Sort descending
                        
                        for (const rowNum of rowsToDelete) {
                            const rowRange = sheet.getRange(`${rowNum}:${rowNum}`);
                            rowRange.delete(Excel.DeleteShiftDirection.up);
                        }
                        await context.sync();
                        console.log(` Removed ${rowsToDelete.length} zero rows`);
                    } else {
                        console.log(' No zero rows to remove');
                    }
                });
            } catch (e) {
                console.warn('Zero row removal failed:', e.message);
            }
            
            // Auto-fit columns AFTER all formulas have resolved
            await autoFitColumns();
            
            // Apply currency formatting
            try {
                await scanForSubsidiaryCells();
                await autoFormatCurrencies();
            } catch (e) {
                console.warn('Currency format failed:', e.message);
            }
            
            // Remove overlay
            const syncOverlayEl = document.getElementById('structureSyncOverlay');
            if (syncOverlayEl) {
                syncOverlayEl.style.opacity = '0';
                syncOverlayEl.style.transition = 'opacity 0.3s ease';
                setTimeout(() => syncOverlayEl.remove(), 300);
            }
            const syncStyle = document.getElementById('syncPulseStyle');
            if (syncStyle) syncStyle.remove();
            
            // Keep suppressStatusBar true - dismissReportSuccess will handle it
            localStorage.removeItem('netsuite_status');
            hideStatus();
            
            // Calculate elapsed time
            const elapsedSeconds = ((Date.now() - syncStartTime) / 1000).toFixed(1);
            
            // Show success overlay
            showReportSuccessOverlay(
                ' Filters Applied!',
                `Income Statement updated in ${elapsedSeconds}s`,
                [{
                    label: 'Subsidiary',
                    value: currentSubsidiary || 'All',
                    icon: ''
                }, {
                    label: 'Currency',
                    value: `${currencyFlag} ${currencySymbol}`,
                    icon: ''
                }, {
                    label: 'Year',
                    value: String(targetYear),
                    icon: ''
                }, {
                    label: 'Filters',
                    value: filters.length > 0 ? filters.join(', ') : 'None',
                    icon: ''
                }],
                'Filter Update',
                'records'
            );
        }
        
        // Perform CFO Flash sync - simpler than full Structure Sync (no row rebuilding needed)
        async function performCFOSync(targetYear, currentSubsidiary, department = '', location = '', classId = '', accountingBook = '') {
            console.log(` CFO Sync starting for year=${targetYear}, subsidiary="${currentSubsidiary}"`);
            
            // Suppress the small status bar - we're showing our own overlay
            suppressStatusBar = true;
            localStorage.removeItem('netsuite_status');
            hideStatus();
            
            const syncStartTime = Date.now();
            
            // Get currency info
            let currencyFormat = '$#,##0.00';
            let currencySymbol = '$';
            let currencyFlag = '';
            
            try {
                const currencyData = await getCurrencyData();
                if (currencyData && currentSubsidiary) {
                    const subsidiaryNameToId = await getSubsidiaryLookup();
                    const subId = /^\d+$/.test(currentSubsidiary) ? 
                        currentSubsidiary : 
                        (subsidiaryNameToId[currentSubsidiary.toLowerCase()] || currencyData.default_subsidiary);
                    currencySymbol = currencyData.currencies[subId] || currencyData.currencies[currencyData.default_subsidiary] || '$';
                    currencyFormat = currencyData.formats[currencySymbol] || '$#,##0.00';
                    currencyFlag = getCurrencyFlag(currencySymbol);
                    console.log(` CFO Sync currency: "${currentSubsidiary}"  ${currencyFlag} ${currencySymbol}`);
                }
            } catch (e) {
                console.warn('Currency lookup failed:', e.message);
            }
            
            // Show full-screen overlay
            const syncOverlay = document.createElement('div');
            syncOverlay.id = 'structureSyncOverlay';
            syncOverlay.className = 'guide-me-overlay';
            syncOverlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2> CFO Flash Sync</h2>
                <div class="loading-subtitle">
                    Updating report for <strong>${targetYear}</strong> and <strong>"${currentSubsidiary || 'All Subsidiaries'}"</strong>
                </div>
                <div style="margin: 16px auto; display: flex; align-items: center; justify-content: center; gap: 12px; 
                            padding: 12px 24px; background: rgba(10, 226, 193, 0.15); border-radius: 12px; border: 1px solid rgba(10, 226, 193, 0.3);">
                    <span style="font-size: 32px;">${currencyFlag}</span>
                    <div style="text-align: left;">
                        <div style="font-size: 11px; color: #93c5fd; text-transform: uppercase;">Currency</div>
                        <div style="font-size: 22px; font-weight: bold; color: #0AE2C1;">${currencySymbol}</div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="syncProgressBar" style="width: 30%; animation: syncPulse 1.5s infinite;"></div>
                    </div>
                    <div class="progress-text">Recalculating...</div>
                </div>
                <div class="loading-step"><span class="spreadsheet-animation"></span> Tucking everything into place...</div>
                <div class="loading-step-desc">TYPEBALANCE formulas are refreshing with new filter values.</div>
            `;
            document.body.appendChild(syncOverlay);
            
            // Add pulse animation
            const style = document.createElement('style');
            style.id = 'syncPulseStyle';
            style.textContent = `
                @keyframes syncPulse {
                    0%, 100% { width: 30%; opacity: 0.8; }
                    50% { width: 70%; opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            try {
                // ========== PRE-FETCH TYPEBALANCE DATA ==========
                // This dramatically speeds up formula resolution
                const loadingStep = document.querySelector('#structureSyncOverlay .loading-step');
                const loadingDesc = document.querySelector('#structureSyncOverlay .loading-step-desc');
                
                if (loadingStep) loadingStep.innerHTML = ' Fetching data from NetSuite...';
                if (loadingDesc) loadingDesc.textContent = 'Pre-loading TYPEBALANCE data for instant formula resolution.';
                
                console.log(` Pre-fetching TYPEBALANCE data for ${targetYear}...`);
                console.log(`   Filters: sub="${currentSubsidiary}", dept="${department}", loc="${location}", class="${classId}", book="${accountingBook}"`);
                
                // Clear existing TYPEBALANCE cache to ensure fresh data
                localStorage.removeItem('netsuite_typebalance_cache');
                localStorage.removeItem('netsuite_typebalance_cache_timestamp');
                
                // Signal functions.js to clear its in-memory cache
                // CRITICAL: Must be JSON format with { timestamp, reason } that functions.js expects!
                localStorage.setItem('netsuite_cache_clear_signal', JSON.stringify({
                    timestamp: Date.now(),
                    reason: 'cfo_filter_change'
                }));
                
                try {
                    const typeBalanceResponse = await fetch(`${SERVER_URL}/batch/typebalance_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: targetYear,
                            subsidiary: currentSubsidiary,
                            department: department,
                            location: location,
                            classId: classId,
                            accountingBook: accountingBook
                        })
                    });
                    
                    if (typeBalanceResponse.ok) {
                        const typeBalanceData = await typeBalanceResponse.json();
                        const balances = typeBalanceData.balances || {};
                        const typesLoaded = Object.keys(balances).length;
                        
                        console.log(` CFO Sync: Pre-fetched ${typesLoaded} account types`);
                        
                        // Save to localStorage for functions.js to use
                        try {
                            const cacheEntries = {};
                            const specialFlag = '0';
                            
                            // Month name mapping
                            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                            
                            for (const [acctType, monthData] of Object.entries(balances)) {
                                for (let month = 0; month < 12; month++) {
                                    const period = `${monthNames[month]} ${targetYear}`;
                                    const value = monthData[period] || 0;
                                    
                                    // CRITICAL: Cache key format must match TYPEBALANCE function exactly!
                                    // Format: typebalance:${type}:${fromPeriod}:${toPeriod}:${subsidiary}:${dept}:${loc}:${class}:${book}:${specialFlag}
                                    // IMPORTANT: Must trim all values - TYPEBALANCE function uses .trim() on all parameters
                                    const cacheKey = `typebalance:${acctType}:${period}:${period}:${(currentSubsidiary || '').trim()}:${(department || '').trim()}:${(location || '').trim()}:${(classId || '').trim()}:${(accountingBook || '').trim()}:${specialFlag}`;
                                    
                                    cacheEntries[cacheKey] = value;
                                }
                            }
                            
                            const storageData = {
                                balances: cacheEntries,
                                timestamp: Date.now(),
                                year: targetYear,
                                subsidiary: currentSubsidiary
                            };
                            localStorage.setItem('netsuite_typebalance_cache', JSON.stringify(storageData));
                            localStorage.setItem('netsuite_typebalance_cache_timestamp', Date.now().toString());
                            
                            console.log(` CFO Sync: Saved ${Object.keys(cacheEntries).length} cache entries`);
                            
                            // Log sample keys for debugging
                            const sampleKeys = Object.keys(cacheEntries).slice(0, 3);
                            console.log('   Sample cache keys:', sampleKeys);
                            
                        } catch (e) {
                            console.error('CFO Sync: localStorage save failed:', e.message);
                        }
                        
                        // ============================================
                        // CRITICAL: Force TYPEBALANCE formulas to recalculate NOW
                        // Excel already recalculated them BEFORE our pre-fetch completed,
                        // so we need to trigger a SECOND recalculation to hit the cache
                        // ============================================
                        if (loadingStep) loadingStep.innerHTML = ' Refreshing formulas...';
                        if (loadingDesc) loadingDesc.textContent = 'Triggering formula recalculation with cached data.';
                        
                        console.log(` CFO Sync: Triggering TYPEBALANCE formula recalculation to use pre-fetched cache...`);
                        try {
                            await Excel.run(async (context) => {
                                const sheet = context.workbook.worksheets.getActiveWorksheet();
                                const usedRange = sheet.getUsedRange();
                                usedRange.load(["formulas", "rowCount", "columnCount"]);
                                await context.sync();
                                
                                const formulas = usedRange.formulas;
                                const rowCount = usedRange.rowCount;
                                const columnCount = usedRange.columnCount;
                                let typebalanceCount = 0;
                                
                                for (let row = 0; row < rowCount; row++) {
                                    for (let col = 0; col < columnCount; col++) {
                                        const formula = formulas[row][col];
                                        if (typeof formula === 'string' && formula.toUpperCase().includes('XAVI.TYPEBALANCE')) {
                                            const cell = usedRange.getCell(row, col);
                                            cell.calculate();
                                            typebalanceCount++;
                                        }
                                    }
                                }
                                await context.sync();
                                console.log(` CFO Sync: Triggered recalculation of ${typebalanceCount} TYPEBALANCE formulas - they should now hit cache`);
                            });
                        } catch (recalcError) {
                            console.warn('CFO Sync: TYPEBALANCE recalculation trigger failed:', recalcError.message);
                        }
                        
                    } else {
                        console.warn(' CFO Sync: Pre-fetch failed, formulas will load individually');
                    }
                } catch (e) {
                    console.warn(' CFO Sync: Pre-fetch error:', e.message);
                }
                
                if (loadingStep) loadingStep.innerHTML = '<span class="spreadsheet-animation"></span> Tucking everything into place...';
                if (loadingDesc) loadingDesc.textContent = 'Formulas are refreshing with cached data.';
                
                // Wait for formulas to resolve
                await waitForFormulasToComplete(60000, null);
                
                // Auto-fit columns AFTER all formulas have resolved
                await autoFitColumns();
                
                // Apply currency formatting
                try {
                    await scanForSubsidiaryCells();
                    await autoFormatCurrencies();
                } catch (e) {
                    console.warn('Currency format failed:', e.message);
                }
                
                // Remove overlay
                const syncOverlayEl = document.getElementById('structureSyncOverlay');
                if (syncOverlayEl) {
                    syncOverlayEl.style.opacity = '0';
                    syncOverlayEl.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => syncOverlayEl.remove(), 300);
                }
                const syncStyle = document.getElementById('syncPulseStyle');
                if (syncStyle) syncStyle.remove();
                
                // Keep suppressStatusBar true - dismissReportSuccess will handle it
                localStorage.removeItem('netsuite_status');
                hideStatus();
                
                // Calculate elapsed time
                const elapsedSeconds = ((Date.now() - syncStartTime) / 1000).toFixed(1);
                
                // Show success overlay
                showReportSuccessOverlay('CFO Flash Sync', {
                    totalAccounts: 5,
                    elapsedTime: elapsedSeconds,
                    countLabel: 'Formula Type',  // Header label for the count column
                    sections: [
                        { name: 'Revenue', count: 'TYPEBALANCE' },
                        { name: 'COGS', count: 'TYPEBALANCE' },
                        { name: 'Gross Margin', count: 'Calculated' },
                        { name: 'Operating Expenses', count: 'TYPEBALANCE' },
                        { name: 'Net Income', count: 'Calculated' }
                    ],
                    tips: [
                        { type: 'info', icon: currencyFlag, title: 'Currency:', text: `<strong>${currencySymbol}</strong> applied to all cells` },
                        { type: 'info', icon: '', title: 'Subsidiary:', text: `<strong>${currentSubsidiary || 'All Subsidiaries'}</strong>` },
                        { type: 'info', icon: '', title: 'Year:', text: `<strong>${targetYear}</strong>` }
                    ],
                    customHeader: `${currencyFlag} ${currentSubsidiary || 'All Subsidiaries'}`
                });
                
                console.log(` CFO Sync complete for ${targetYear}`);
                
            } catch (error) {
                console.error('CFO Sync error:', error);
                
                suppressStatusBar = false;
                
                const syncOverlay = document.getElementById('structureSyncOverlay');
                if (syncOverlay) syncOverlay.remove();
                const syncStyle = document.getElementById('syncPulseStyle');
                if (syncStyle) syncStyle.remove();
                
                showToast({
                    title: ' CFO Sync Failed',
                    message: error.message,
                    type: 'error',
                    icon: '',
                    duration: 8000
                });
            }
        }

        // Perform the structure sync (extracted for reuse)
        async function performStructureSync(targetYear, currentSubsidiary) {
            const statusEl = document.getElementById('refreshStatus');
            
            // Suppress the small status bar - we're showing our own overlay
            suppressStatusBar = true;
            localStorage.removeItem('netsuite_status');
            
            // Get currency info EARLY so we can show it on the overlay
                let currencyFormat = '$#,##0.00';  // Default to USD
            let currencySymbol = '$';
            let currencyFlag = '';
            
                try {
                    const currencyData = await getCurrencyData();
                    if (currencyData && currentSubsidiary) {
                        const subsidiaryNameToId = await getSubsidiaryLookup();
                        const subId = /^\d+$/.test(currentSubsidiary) ? 
                            currentSubsidiary : 
                            (subsidiaryNameToId[currentSubsidiary.toLowerCase()] || currencyData.default_subsidiary);
                    currencySymbol = currencyData.currencies[subId] || currencyData.currencies[currencyData.default_subsidiary] || '$';
                    currencyFormat = currencyData.formats[currencySymbol] || '$#,##0.00';
                    currencyFlag = getCurrencyFlag(currencySymbol);
                    console.log(` Structure Sync currency: "${currentSubsidiary}"  ${currencyFlag} ${currencySymbol}`);
                    }
                } catch (e) {
                    console.warn('Currency lookup failed:', e.message);
                }
            
            // Show prominent FULL-SCREEN overlay for Structure Sync (impossible to miss!)
            const syncOverlay = document.createElement('div');
            syncOverlay.id = 'structureSyncOverlay';
            syncOverlay.className = 'guide-me-overlay';  // Reuse existing full-screen overlay style
            syncOverlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2> Structure Sync</h2>
                <div class="loading-subtitle">
                    Analyzing accounts for <strong>${targetYear}</strong> and <strong>"${currentSubsidiary || 'All Subsidiaries'}"</strong>
                </div>
                <div style="margin: 16px auto; display: flex; align-items: center; justify-content: center; gap: 12px; 
                            padding: 12px 24px; background: rgba(10, 226, 193, 0.15); border-radius: 12px; border: 1px solid rgba(10, 226, 193, 0.3);">
                    <span style="font-size: 32px;">${currencyFlag}</span>
                    <div style="text-align: left;">
                        <div style="font-size: 11px; color: #93c5fd; text-transform: uppercase;">Currency</div>
                        <div style="font-size: 22px; font-weight: bold; color: #0AE2C1;">${currencySymbol}</div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="syncProgressBar" style="width: 20%; animation: syncPulse 1.5s infinite;"></div>
                    </div>
                    <div class="progress-text">Querying NetSuite...</div>
                </div>
                <div class="loading-step"> Filtering out rows with no activity</div>
                <div class="loading-step-desc">This keeps your report clean and focused on accounts that matter.</div>
                <div style="margin-top: 20px; padding: 12px 20px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; font-size: 12px; color: #93c5fd;">
                     This typically takes 10-15 seconds
                </div>
            `;
            document.body.appendChild(syncOverlay);
            
            // Add pulse animation for progress bar
            const style = document.createElement('style');
            style.id = 'syncPulseStyle';
            style.textContent = `
                @keyframes syncPulse {
                    0%, 100% { width: 20%; opacity: 0.8; }
                    50% { width: 60%; opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            // Hide the small status element - the overlay is the main UI
            if (statusEl) {
                statusEl.innerHTML = '';
            }
            
            try {
                // Update overlay to show we're fetching data
                const syncStep = document.querySelector('#structureSyncOverlay .loading-step');
                if (syncStep) syncStep.textContent = ' Fetching account data from NetSuite...';
                
                // Fetch accounts for the target year AND selected subsidiary
                console.log(`performStructureSync: year=${targetYear}, subsidiary="${currentSubsidiary}"`);
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: targetYear,
                        subsidiary: currentSubsidiary || '',  // Use selected subsidiary!
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                // Categorize accounts
                const categories = {
                    income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                };
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown'
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') categories.income.push(acctInfo);
                        else if (acctType === 'othincome') categories.othIncome.push(acctInfo);
                        else if (acctType === 'cogs' || acctType === 'cost of goods sold') categories.cogs.push(acctInfo);
                        else if (acctType === 'expense') categories.expense.push(acctInfo);
                        else if (acctType === 'othexpense') categories.othExpense.push(acctInfo);
                    }
                }
                
                // Sort categories
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                // Rebuild the sheet
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    const usedRange = sheet.getUsedRange();
                    usedRange.clear();
                    await context.sync();
                    
                    try { sheet.showGridlines = false; await context.sync(); } catch (e) {}
                    
                    // ROW 1: TITLE
                    sheet.getRange("A1").formulas = [['="Income Statement For: "&P3']];
                    await context.sync();
                    try {
                        sheet.getRange("A1").format.font.bold = true;
                        sheet.getRange("A1").format.font.size = 18;
                        sheet.getRange("A1").format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 2: PARAMETER LABELS (above values)
                    sheet.getRange("P2").values = [["YEAR"]];
                    sheet.getRange("Q2").values = [["Subsidiary"]];
                    sheet.getRange("R2").values = [["Department"]];
                    sheet.getRange("S2").values = [["Location"]];
                    sheet.getRange("T2").values = [["Class"]];
                    sheet.getRange("U2").values = [["Acct Book"]];
                    sheet.getRange("V2").values = [["Structure Sync"]];
                    await context.sync();
                    
                    try {
                        const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                        for (const cell of labelCells) {
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                            sheet.getRange(cell).format.font.size = 10;
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 3: PARAMETER VALUES (below labels)
                    // Set sync trackers BEFORE context.sync() to prevent race condition
                    lastSyncedYear = String(targetYear);
                    lastSyncedSubsidiary = currentSubsidiary || 'Celigo Inc. (Consolidated)';
                    
                    sheet.getRange("P3").values = [[targetYear]];
                    sheet.getRange("Q3").values = [[currentSubsidiary || 'Celigo Inc. (Consolidated)']];
                    sheet.getRange("R3").values = [[""]];  // Department
                    sheet.getRange("S3").values = [[""]];  // Location
                    sheet.getRange("T3").values = [[""]];  // Class
                    sheet.getRange("U3").values = [[""]];  // Accounting Book
                    sheet.getRange("V3").values = [["TRUE"]];
                    await context.sync();
                    
                    try {
                        const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                        for (const cell of valueCells) {
                            sheet.getRange(cell).format.fill.color = "#0AE2C1";
                            sheet.getRange(cell).format.font.bold = true;
                            sheet.getRange(cell).format.font.color = "#09235C";
                        }
                        await context.sync();
                    } catch (e) {}
                    
                    // NOTE: Filter cell comments removed - caused errors on Mac
                    
                    // ROW 4: KPI METRICS DASHBOARD
                    try {
                        sheet.getRange("4:4").format.rowHeight = 50;
                        await context.sync();
                    } catch (e) {}
                    
                    try {
                        sheet.getRange("A4:C4").merge();
                        sheet.getRange("D4:F4").merge();
                        sheet.getRange("G4:I4").merge();
                        sheet.getRange("J4:L4").merge();
                        await context.sync();
                    } catch (e) {}
                    
                    sheet.getRange("A4").formulas = [['=" YTD REVENUE\n"&TEXT(SUMIF(B:B,"*Total Revenue*",O:O),"#,##0")&"\nTotal Revenue YTD"']];
                    sheet.getRange("D4").formulas = [['=" GROSS MARGIN\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Gross Profit*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nGross Profit / Revenue"']];
                    sheet.getRange("G4").formulas = [['=" NET INCOME\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Net Income*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nNet Income / Revenue"']];
                    sheet.getRange("J4").formulas = [['=" OPEX RATIO\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Operating Expenses*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nOpEx / Revenue"']];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A4:C4").format.font.bold = true;
                        sheet.getRange("A4:C4").format.font.size = 11;
                        sheet.getRange("A4:C4").format.font.color = "#FFFFFF";
                        sheet.getRange("A4:C4").format.fill.color = "#22C55E";
                        sheet.getRange("A4:C4").format.horizontalAlignment = "Center";
                        sheet.getRange("A4:C4").format.verticalAlignment = "Center";
                        sheet.getRange("A4:C4").format.wrapText = true;
                        sheet.getRange("D4:F4").format.font.bold = true;
                        sheet.getRange("D4:F4").format.font.size = 11;
                        sheet.getRange("D4:F4").format.font.color = "#000000";
                        sheet.getRange("D4:F4").format.fill.color = "#FBBF24";
                        sheet.getRange("D4:F4").format.horizontalAlignment = "Center";
                        sheet.getRange("D4:F4").format.verticalAlignment = "Center";
                        sheet.getRange("D4:F4").format.wrapText = true;
                        sheet.getRange("G4:I4").format.font.bold = true;
                        sheet.getRange("G4:I4").format.font.size = 11;
                        sheet.getRange("G4:I4").format.font.color = "#FFFFFF";
                        sheet.getRange("G4:I4").format.fill.color = "#EF4444";
                        sheet.getRange("G4:I4").format.horizontalAlignment = "Center";
                        sheet.getRange("G4:I4").format.verticalAlignment = "Center";
                        sheet.getRange("G4:I4").format.wrapText = true;
                        sheet.getRange("J4:L4").format.font.bold = true;
                        sheet.getRange("J4:L4").format.font.size = 11;
                        sheet.getRange("J4:L4").format.font.color = "#FFFFFF";
                        sheet.getRange("J4:L4").format.fill.color = "#8B5CF6";
                        sheet.getRange("J4:L4").format.horizontalAlignment = "Center";
                        sheet.getRange("J4:L4").format.verticalAlignment = "Center";
                        sheet.getRange("J4:L4").format.wrapText = true;
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 5: HEADERS
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}5`).formulas = [[`=DATE($P$3,${m + 1},1)`]];
                    }
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A5:O5").format.font.bold = true;
                        sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                        sheet.getRange("A5:O5").format.fill.color = "#09235C";
                        sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    // Set column widths to prevent parameter text from affecting month columns
                    try {
                        sheet.getRange("A:A").format.columnWidth = 80;  // Account #
                        sheet.getRange("B:B").format.columnWidth = 180; // Account Name
                        sheet.getRange("C:N").format.columnWidth = 85;  // Month columns (fixed width)
                        sheet.getRange("O:O").format.columnWidth = 90;  // YTD Total
                        await context.sync();
                    } catch (e) {}
                    
                    let currentRow = 6;
                    
                    const writeSectionHeader = async (text, row) => {
                        sheet.getRange(`A${row}`).values = [[text]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    const writeAccountRow = (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).formulas = [[`=XAVI.NAME($A${row})`]];  // Reference account number for drag-ability
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},${col}$5,${col}$5,$Q$3,$R$3,$S$3,$T$3,$U$3)`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    const writeSubtotalRow = async (text, startRow, endRow, row) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    // Helper to create named ranges (makes formulas robust against row changes)
                    const createNamedRange = async (name, row) => {
                        try {
                            try { sheet.names.getItem(name).delete(); await context.sync(); } catch (e) {}
                            sheet.names.add(name, sheet.getRange(`C${row}:O${row}`));
                            await context.sync();
                        } catch (e) { console.warn(`Could not create ${name}:`, e.message); }
                    };
                    
                    let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                    let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                    
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                        revenueTotalRow = currentRow;
                        await createNamedRange('_Total_Revenue', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                        cogsTotalRow = currentRow;
                        await createNamedRange('_Total_COGS', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // GROSS PROFIT - Always create if we have revenue or COGS
                    if (revenueTotalRow || cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        // LET formula: cleaner, more efficient than INDIRECT
                        const gpFormula = '=LET(rev,IFERROR(@_Total_Revenue,0),cogs,IFERROR(@_Total_COGS,0),IF(cogs<0,ABS(rev)+ABS(cogs),ABS(rev)-ABS(cogs)))';
                        for (let m = 0; m < 13; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[gpFormula]];
                        }
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                            await context.sync();
                        } catch (e) {}
                        grossProfitRow = currentRow;
                        await createNamedRange('_Gross_Profit', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                        expenseTotalRow = currentRow;
                        await createNamedRange('_Total_Operating_Expenses', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // OPERATING INCOME - Always create if we have gross profit or expenses
                    if (grossProfitRow || expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        // LET formula: cleaner, more efficient than INDIRECT
                        const oiFormula = '=LET(gp,IFERROR(@_Gross_Profit,0),opex,IFERROR(@_Total_Operating_Expenses,0),IF(opex<0,ABS(gp)+ABS(opex),ABS(gp)-ABS(opex)))';
                        for (let m = 0; m < 13; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[oiFormula]];
                        }
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                            await context.sync();
                        } catch (e) {}
                        operatingIncomeRow = currentRow;
                        await createNamedRange('_Operating_Income', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                        othIncomeTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Income', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                        othExpenseTotalRow = currentRow;
                        await createNamedRange('_Total_Other_Expense', currentRow);
                        currentRow++;
                        currentRow++;
                    }
                    
                    // NET INCOME - LET formula: ADD otherExp (already signed correctly)
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    // Net Income = Operating Income + Other Income - Other Expense
                    // Simple formula works because raw data has correct signs:
                    // - Positive expenses hurt income (subtract)
                    // - Negative expenses (credits/gains) help income (subtracting negative = adding)
                    const niFormula = '=LET(opInc,IFERROR(@_Operating_Income,IFERROR(@_Gross_Profit,IFERROR(@_Total_Revenue,0))),otherInc,IFERROR(@_Total_Other_Income,0),otherExp,IFERROR(@_Total_Other_Expense,0),opInc+otherInc-otherExp)';
                    for (let m = 0; m < 13; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}${currentRow}`).formulas = [[niFormula]];
                    }
                    await context.sync();
                    
                    try {
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                        await context.sync();
                    } catch (e) {}
                    netIncomeRow = currentRow;
                    await createNamedRange('_Net_Income', currentRow);
                    
                    // Apply currency format to all number cells
                    try {
                        const rows = netIncomeRow - 5;
                        const formatArray = Array(rows).fill(null).map(() => Array(13).fill(currencyFormat));
                        sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {}
                    
                    try { sheet.freezePanes.freezeRows(5); await context.sync(); } catch (e) {}
                });
                
                // Update overlay to show we're waiting for formulas
                const syncStepFinal = document.querySelector('#structureSyncOverlay .loading-step');
                const syncDesc = document.querySelector('#structureSyncOverlay .loading-step-desc');
                if (syncStepFinal) syncStepFinal.innerHTML = '<span class="spreadsheet-animation"></span> Tucking everything into place...';
                if (syncDesc) syncDesc.textContent = 'Your data is being populated. Almost done!';
                
                // Track start time for elapsed calculation
                const syncStartTime = Date.now();
                
                // Wait for formulas to resolve before showing success
                await waitForFormulasToComplete(120000, null);
                
                // Auto-fit columns AFTER all formulas have resolved
                await autoFitColumns();
                
                // Remove the full-screen overlay
                const syncOverlayEl = document.getElementById('structureSyncOverlay');
                if (syncOverlayEl) {
                    syncOverlayEl.style.opacity = '0';
                    syncOverlayEl.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => syncOverlayEl.remove(), 300);
                }
                const syncStyle = document.getElementById('syncPulseStyle');
                if (syncStyle) syncStyle.remove();
                
                // KEEP suppressStatusBar = true - it will be set to false when user dismisses success overlay
                // This prevents "Fetching P&L data" from appearing after sync completes
                localStorage.removeItem('netsuite_status');
                hideStatus();  // Hide any status bar just in case
                
                // Calculate elapsed time
                const elapsedSeconds = ((Date.now() - syncStartTime) / 1000).toFixed(1);
                
                // Show success using the SAME large overlay as Income Statement generation
                showReportSuccessOverlay('Structure Sync', {
                    totalAccounts,
                    elapsedTime: elapsedSeconds,
                    sections: [
                        { name: 'Revenue', count: categories.income.length },
                        { name: 'Cost of Sales', count: categories.cogs.length },
                        { name: 'Operating Expenses', count: categories.expense.length },
                        { name: 'Other Income/Expense', count: categories.othIncome.length + categories.othExpense.length }
                    ],
                    tips: [
                        { type: 'info', icon: currencyFlag, title: 'Currency:', text: `<strong>${currencySymbol}</strong> applied to all cells` },
                        { type: 'info', icon: '', title: 'Subsidiary:', text: `<strong>${currentSubsidiary || 'All Subsidiaries'}</strong>` },
                        { type: 'info', icon: '', title: 'Year:', text: `<strong>${targetYear}</strong>` }
                    ],
                    customHeader: `${currencyFlag} ${currentSubsidiary || 'All Subsidiaries'}`
                });
                
                // Clear status element
                if (statusEl) {
                    statusEl.innerHTML = '';
                }
                
                console.log(` Auto-sync complete for ${targetYear}`);
                
                // Apply currency formatting after structure rebuild
                // Wait a bit for formulas to start resolving
                setTimeout(async () => {
                    try {
                        console.log(' Applying currency formatting after structure sync...');
                        await scanForSubsidiaryCells();
                        await autoFormatCurrencies();
                    } catch (e) {
                        console.warn('Post-sync currency format failed:', e.message);
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Structure sync error:', error);
                
                // Re-enable status bar
                suppressStatusBar = false;
                
                // Remove the full-screen overlay
                const syncOverlay = document.getElementById('structureSyncOverlay');
                if (syncOverlay) syncOverlay.remove();
                const syncStyle = document.getElementById('syncPulseStyle');
                if (syncStyle) syncStyle.remove();
                
                // Show error toast
                showToast({
                    title: ' Structure Sync Failed',
                    message: error.message,
                    type: 'error',
                    icon: '',
                    duration: 8000
                });
                
                if (statusEl) {
                    statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;">
                        <strong style="color: #dc2626;">Sync Error:</strong> ${error.message}
                    </div>`;
                }
            }
        }
        
        async function preloadAccountTitles() {
            try {
                console.log(' Preloading account titles...');
                const response = await fetch(`${SERVER_URL}/account/preload_titles`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(` Preloaded ${data.loaded} account titles`);
                } else {
                    console.warn('  Failed to preload account titles:', response.status);
                }
            } catch (error) {
                console.error('Error preloading account titles:', error);
                // Don't throw - taskpane should still work even if preload fails
            }
        }

        async function clearCache() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                btn.textContent = 'Clearing...';
                
                showLoading('Clear Cache', 'Clearing all cached data...', 20);
                
                // STEP 1: Clear localStorage (shared across all contexts)
                try {
                    localStorage.removeItem('netsuite_balance_cache');
                    localStorage.removeItem('netsuite_balance_cache_timestamp');
                    localStorage.removeItem('netsuite_budget_cache');
                    localStorage.removeItem('netsuite_budget_cache_timestamp');
                    localStorage.removeItem('netsuite_preload_status');
                    localStorage.removeItem('netsuite_cache_invalidate');
                    localStorage.removeItem('netsuite_status');
                } catch (e) {
                    console.warn('    localStorage clear failed:', e.message);
                }
                
                updateLoading('Clearing in-memory caches...', 50);
                
                // STEP 2: Clear in-memory caches in custom functions runtime via __CLEARCACHE__ command
                // Use "ALL" as the items string to signal full cache clear
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    // Find an empty cell to use temporarily
                    const tempRange = sheet.getRange('ZZ9999');
                    
                    // Call BALANCE with __CLEARCACHE__ and "ALL" to clear everything
                    tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","ALL","")`]];
                    await context.sync();
                    
                    // Wait for the function to execute
                    await new Promise(r => setTimeout(r, 1000));
                    
                    tempRange.load('values');
                    await context.sync();
                    
                    const result = tempRange.values[0][0];
                    
                    // Clean up temp cell
                    tempRange.clear();
                    await context.sync();
                });
                
                console.log(' All caches cleared successfully!');
                
                updateLoading('Cache cleared!', 100);
                await new Promise(resolve => setTimeout(resolve, 500));
                hideLoading();
                
                // Show success message
                statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Cache cleared!</strong><br><span style="font-size: 11px;">Formulas will fetch fresh data from NetSuite</span></div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
                
            } catch (error) {
                console.error('Error clearing cache:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Clear Cache';
            }
        }
        
        // ============================================
        // AUTO-FORMAT CURRENCIES - Silent version for after refresh
        // Uses cached data for performance
        // Also updates knownSubsidiaryCells for smart change detection
        // ============================================
        async function autoFormatCurrencies() {
            console.log(' AUTO-FORMAT: Starting currency formatting...');
            
            // Get cached currency data (should already be cached from previous calls)
            const currencyData = await getCurrencyData();
            if (!currencyData) {
                console.warn(' AUTO-FORMAT: No currency data available');
                return;
            }
            
            const currencies = currencyData.currencies;
            const formats = currencyData.formats;
            const defaultSub = currencyData.default_subsidiary;
            const defaultSymbol = currencies[defaultSub] || '$';
            const defaultFormat = formats[defaultSymbol] || '$#,##0.00';
            
            await Excel.run(async (context) => {
                const sheet = context.workbook.worksheets.getActiveWorksheet();
                const usedRange = sheet.getUsedRange();
                usedRange.load(['formulas', 'rowCount', 'columnCount']);
                
                // Also check for Income Statement marker and subsidiary cell
                const markerCell = sheet.getRange("R2");
                markerCell.load("values");
                const subCell = sheet.getRange("Q3");
                subCell.load("values");
                
                await context.sync();
                
                const formulas = usedRange.formulas;
                const cellRefsToResolve = new Set();
                const pendingCells = [];
                
                // Check if this is an auto-generated Income Statement
                const markerValue = String(markerCell.values[0][0] || '').toLowerCase();
                const isIncomeStatement = markerValue.includes('structure sync') || markerValue.includes('');
                
                // Clear and rebuild known subsidiary cells
                knownSubsidiaryCells.clear();
                
                // First pass: Collect cell references for ALL XAVI formula types
                // Subsidiary param positions:
                // - XAVI.BALANCE(acct, from, to, [sub], ...) - index 3
                // - XAVI.TYPEBALANCE(type, from, to, [sub], ...) - index 3
                // - XAVI.NETINCOME(from, [to], [sub], ...) - index 2
                // - XAVI.BUDGET(acct, from, to, [sub], ...) - index 3
                for (let row = 0; row < usedRange.rowCount; row++) {
                    for (let col = 0; col < usedRange.columnCount; col++) {
                        const formula = formulas[row][col];
                        if (typeof formula !== 'string') continue;
                        
                        const upperFormula = formula.toUpperCase();
                        let subsidiaryParam = '';
                        
                        if (upperFormula.includes('XAVI.BALANCE') && !upperFormula.includes('XAVI.TYPEBALANCE')) {
                            subsidiaryParam = extractFormulaParam(formula, 3);
                        } else if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                            subsidiaryParam = extractFormulaParam(formula, 3);
                        } else if (upperFormula.includes('XAVI.NETINCOME')) {
                            subsidiaryParam = extractFormulaParam(formula, 2);
                        } else if (upperFormula.includes('XAVI.BUDGET')) {
                            subsidiaryParam = extractFormulaParam(formula, 3);
                        } else {
                            continue; // Not a XAVI formula we format
                        }
                        
                            pendingCells.push({ row, col, subsidiaryParam });
                            
                            if (subsidiaryParam && !subsidiaryParam.startsWith('"') && !subsidiaryParam.startsWith("'") && !/^\d+$/.test(subsidiaryParam)) {
                                cellRefsToResolve.add(subsidiaryParam);
                                // Track this cell reference for change detection
                                const normalized = subsidiaryParam.replace(/\$/g, '').toUpperCase();
                                knownSubsidiaryCells.add(normalized);
                        }
                    }
                }
                
                if (pendingCells.length === 0) {
                    console.log(' AUTO-FORMAT: No XAVI balance formulas found');
                    return;
                }
                
                console.log(` AUTO-FORMAT: Tracking ${knownSubsidiaryCells.size} subsidiary cells:`, [...knownSubsidiaryCells]);
                
                // Resolve cell references
                const resolvedRefs = {};
                for (const cellRef of cellRefsToResolve) {
                    try {
                        const refRange = sheet.getRange(cellRef);
                        refRange.load('values');
                        await context.sync();
                        resolvedRefs[cellRef] = String(refRange.values[0][0] || '').trim();
                    } catch (e) {
                        resolvedRefs[cellRef] = '';
                    }
                }
                
                // Get subsidiary lookup (cached)
                const subsidiaryNameToId = await getSubsidiaryLookup();
                
                // Apply formats to XAVI.BALANCE cells
                let formatted = 0;
                for (const { row, col, subsidiaryParam } of pendingCells) {
                    let subId = '';
                    
                    if (subsidiaryParam) {
                        if (/^\d+$/.test(subsidiaryParam)) {
                            subId = subsidiaryParam;
                        } else if (subsidiaryParam.startsWith('"') || subsidiaryParam.startsWith("'")) {
                            const cleaned = subsidiaryParam.replace(/['"]/g, '').trim();
                            subId = /^\d+$/.test(cleaned) ? cleaned : (subsidiaryNameToId[cleaned.toLowerCase()] || '');
                        } else if (resolvedRefs[subsidiaryParam] !== undefined) {
                            const resolvedValue = resolvedRefs[subsidiaryParam];
                            subId = /^\d+$/.test(resolvedValue) ? resolvedValue : (subsidiaryNameToId[resolvedValue.toLowerCase()] || '');
                        }
                    }
                    
                    const symbol = subId && currencies[subId] ? currencies[subId] : defaultSymbol;
                    const format = formats[symbol] || defaultFormat;
                    
                    const range = usedRange.getCell(row, col);
                    range.numberFormat = [[format]];
                    formatted++;
                }
                
                await context.sync();
                
                // ============================================
                // NATIVE FORMULAS: Also format SUM cells, subtotals, etc.
                // Determine the "sheet currency" from the most common subsidiary used
                // ============================================
                    
                // Determine sheet currency: prefer Q3 value, else use most common subsidiary from XAVI formulas
                    let sheetSubId = '';
                    
                // First try Q3 (Income Statement standard location)
                const subValue = String(subCell.values[0][0] || '').trim();
                    if (subValue) {
                        if (/^\d+$/.test(subValue)) {
                            sheetSubId = subValue;
                        } else {
                            sheetSubId = subsidiaryNameToId[subValue.toLowerCase()] || '';
                        }
                    }
                
                // If Q3 didn't have a value, use the most common subsidiary from XAVI formulas
                if (!sheetSubId && pendingCells.length > 0) {
                    const subCounts = {};
                    for (const { subsidiaryParam } of pendingCells) {
                        let subId = '';
                        if (subsidiaryParam) {
                            if (/^\d+$/.test(subsidiaryParam)) {
                                subId = subsidiaryParam;
                            } else if (subsidiaryParam.startsWith('"') || subsidiaryParam.startsWith("'")) {
                                const cleaned = subsidiaryParam.replace(/['"]/g, '').trim();
                                subId = /^\d+$/.test(cleaned) ? cleaned : (subsidiaryNameToId[cleaned.toLowerCase()] || '');
                            } else if (resolvedRefs[subsidiaryParam] !== undefined) {
                                const resolvedValue = resolvedRefs[subsidiaryParam];
                                subId = /^\d+$/.test(resolvedValue) ? resolvedValue : (subsidiaryNameToId[resolvedValue.toLowerCase()] || '');
                            }
                        }
                        if (subId) {
                            subCounts[subId] = (subCounts[subId] || 0) + 1;
                        }
                    }
                    // Use the most frequently used subsidiary
                    const sorted = Object.entries(subCounts).sort((a, b) => b[1] - a[1]);
                    if (sorted.length > 0) {
                        sheetSubId = sorted[0][0];
                        }
                    }
                    
                    const sheetSymbol = sheetSubId && currencies[sheetSubId] ? currencies[sheetSubId] : defaultSymbol;
                    const sheetFormat = formats[sheetSymbol] || defaultFormat;
                console.log(` AUTO-FORMAT: Sheet currency  ${sheetSymbol} (sub ID: ${sheetSubId})`);
                
                // Format ALL native Excel formulas (SUM, subtotals, etc.) with the sheet currency
                let nativeFormatted = 0;
                for (let row = 0; row < usedRange.rowCount; row++) {
                    for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                        if (typeof formula !== 'string' || !formula.startsWith('=')) continue;
                        
                        // Skip XAVI formulas (already formatted with their specific subsidiary)
                        const upperFormula = formula.toUpperCase();
                        const isXaviFormula = upperFormula.includes('XAVI.BALANCE') || 
                                              upperFormula.includes('XAVI.TYPEBALANCE') ||
                                              upperFormula.includes('XAVI.NETINCOME') ||
                                              upperFormula.includes('XAVI.BUDGET');
                        if (isXaviFormula) continue;
                        
                        // Skip DATE/TEXT formulas used for month headers (preserve mmmm format)
                        if (upperFormula.includes('DATE(') || upperFormula.includes('TEXT(')) continue;
                        
                        // Format native formulas (SUM, arithmetic, etc.)
                                const range = usedRange.getCell(row, col);
                                range.numberFormat = [[sheetFormat]];
                        nativeFormatted++;
                        }
                    }
                    
                if (nativeFormatted > 0) {
                    await context.sync();
                    console.log(` AUTO-FORMAT: Also formatted ${nativeFormatted} native Excel formulas`);
                }
            });
        }
        
        // ============================================
        // FORMAT CURRENCIES - Apply currency symbols to XAVI formula cells (with UI)
        // Handles BALANCE, TYPEBALANCE, NETINCOME, and BUDGET formulas
        // ============================================
        async function formatCurrencies() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target.closest('button');
            
            try {
                btn.disabled = true;
                const originalText = btn.querySelector('.action-text').textContent;
                btn.querySelector('.action-text').textContent = 'Formatting...';
                
                showLoading('Format Currencies', 'Loading currency data...', 10);
                
                // Step 1: Get currency mappings (uses cache if available)
                console.log(' FORMAT CURRENCIES: Getting currency data...');
                const currencyData = await getCurrencyData();
                
                if (!currencyData) {
                    throw new Error('Failed to fetch currency data');
                }
                
                const currencies = currencyData.currencies;     // { "1": "$", "3": "A$", ... }
                const formats = currencyData.formats;           // { "$": "$#,##0.00", ... }
                const defaultSub = currencyData.default_subsidiary;
                const defaultSymbol = currencies[defaultSub] || '$';
                const defaultFormat = formats[defaultSymbol] || '$#,##0.00';
                
                console.log('   Using currency data:', Object.keys(currencies).length, 'subsidiaries');
                
                updateLoading('Scanning sheet for XAVI formulas...', 30);
                
                // Step 2: Find all cells with XAVI balance formulas (BALANCE, TYPEBALANCE, NETINCOME, BUDGET)
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load(['formulas', 'address', 'rowCount', 'columnCount']);
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    const cellsToFormat = [];
                    const cellRefsToResolve = new Set();  // Unique cell references to evaluate
                    
                    // First pass: Find all XAVI balance formulas and collect cell references
                    // Subsidiary param positions:
                    // - XAVI.BALANCE(acct, from, to, [sub], ...) - index 3
                    // - XAVI.TYPEBALANCE(type, from, to, [sub], ...) - index 3
                    // - XAVI.NETINCOME(from, [to], [sub], ...) - index 2
                    // - XAVI.BUDGET(acct, from, to, [sub], ...) - index 3
                    const pendingCells = [];
                    for (let row = 0; row < usedRange.rowCount; row++) {
                        for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula !== 'string') continue;
                            
                            const upperFormula = formula.toUpperCase();
                            let subsidiaryParam = '';
                            
                            if (upperFormula.includes('XAVI.BALANCE') && !upperFormula.includes('XAVI.TYPEBALANCE')) {
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else if (upperFormula.includes('XAVI.TYPEBALANCE')) {
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else if (upperFormula.includes('XAVI.NETINCOME')) {
                                subsidiaryParam = extractFormulaParam(formula, 2);
                            } else if (upperFormula.includes('XAVI.BUDGET')) {
                                subsidiaryParam = extractFormulaParam(formula, 3);
                            } else {
                                continue; // Not a XAVI formula we format
                            }
                            
                                pendingCells.push({ row, col, subsidiaryParam });
                                
                                // If it looks like a cell reference (contains $ or letter+number pattern)
                                if (subsidiaryParam && !subsidiaryParam.startsWith('"') && !subsidiaryParam.startsWith("'") && !/^\d+$/.test(subsidiaryParam)) {
                                    // It's likely a cell reference like $Q$3, F2, etc.
                                    cellRefsToResolve.add(subsidiaryParam);
                            }
                        }
                    }
                    
                    console.log(`   Found ${pendingCells.length} XAVI formula cells`);
                    console.log(`   Cell references to resolve: ${[...cellRefsToResolve].join(', ') || 'none'}`);
                    
                    // Second pass: Resolve cell references to their values
                    const resolvedRefs = {};  // cellRef  subsidiary name/ID
                    if (cellRefsToResolve.size > 0) {
                        updateLoading('Resolving subsidiary references...', 40);
                        
                        for (const cellRef of cellRefsToResolve) {
                            try {
                                const refRange = sheet.getRange(cellRef);
                                refRange.load('values');
                                await context.sync();
                                const value = refRange.values[0][0];
                                resolvedRefs[cellRef] = String(value || '').trim();
                                console.log(`   Resolved ${cellRef}  "${resolvedRefs[cellRef]}"`);
                            } catch (e) {
                                console.warn(`   Could not resolve ${cellRef}:`, e.message);
                                resolvedRefs[cellRef] = '';
                            }
                        }
                    }
                    
                    // Get nameID lookup (uses cache if available)
                    const subsidiaryNameToId = await getSubsidiaryLookup();
                    
                    updateLoading('Determining currencies...', 50);
                    
                    // Third pass: Determine currency for each cell
                    for (const { row, col, subsidiaryParam } of pendingCells) {
                        let subId = '';
                        
                        if (subsidiaryParam) {
                            // If it's a number, use directly
                            if (/^\d+$/.test(subsidiaryParam)) {
                                subId = subsidiaryParam;
                            } else if (subsidiaryParam.startsWith('"') || subsidiaryParam.startsWith("'")) {
                                // It's a quoted string - could be name or ID
                                const cleaned = subsidiaryParam.replace(/['"]/g, '').trim();
                                if (/^\d+$/.test(cleaned)) {
                                    subId = cleaned;
                                } else {
                                    // Look up name to ID
                                    subId = subsidiaryNameToId[cleaned.toLowerCase()] || '';
                                }
                            } else if (resolvedRefs[subsidiaryParam] !== undefined) {
                                // It's a cell reference we resolved
                                const resolvedValue = resolvedRefs[subsidiaryParam];
                                if (/^\d+$/.test(resolvedValue)) {
                                    subId = resolvedValue;
                                } else {
                                    // Look up the resolved name to ID
                                    subId = subsidiaryNameToId[resolvedValue.toLowerCase()] || '';
                                }
                            }
                        }
                        
                        // Determine currency symbol and format
                        const symbol = subId && currencies[subId] ? currencies[subId] : defaultSymbol;
                        const format = formats[symbol] || defaultFormat;
                        
                        cellsToFormat.push({
                            row: row,
                            col: col,
                            format: format,
                            symbol: symbol,
                            subId: subId
                        });
                    }
                    
                    console.log(`   Prepared ${cellsToFormat.length} cells for formatting`);
                    
                    if (cellsToFormat.length === 0) {
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #d97706;"> No XAVI formulas found</strong><br><span style="font-size: 11px;">Add some BALANCE, TYPEBALANCE, NETINCOME, or BUDGET formulas first!</span></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    updateLoading(`Applying currency formats to ${cellsToFormat.length} cells...`, 60);
                    
                    // Step 3: Apply formatting in batches to avoid API limits
                    const batchSize = 100;
                    let formatted = 0;
                    
                    for (let i = 0; i < cellsToFormat.length; i += batchSize) {
                        const batch = cellsToFormat.slice(i, i + batchSize);
                        
                        for (const cell of batch) {
                            const range = usedRange.getCell(cell.row, cell.col);
                            range.numberFormat = [[cell.format]];
                        }
                        
                        await context.sync();
                        formatted += batch.length;
                        
                        const progress = 60 + (formatted / cellsToFormat.length) * 35;
                        updateLoading(`Formatted ${formatted}/${cellsToFormat.length} cells...`, progress);
                    }
                    
                    // Count unique currencies used
                    const symbolCounts = {};
                    for (const cell of cellsToFormat) {
                        symbolCounts[cell.symbol] = (symbolCounts[cell.symbol] || 0) + 1;
                    }
                    
                    const symbolSummary = Object.entries(symbolCounts)
                        .map(([sym, count]) => `${sym} (${count})`)
                        .join(', ');
                    
                    console.log(` Formatted ${cellsToFormat.length} XAVI cells: ${symbolSummary}`);
                    
                    // ============================================
                    // NATIVE FORMULAS: Also format SUM cells, subtotals, etc.
                    // ============================================
                    updateLoading('Formatting native Excel formulas...', 80);
                    
                    // Determine sheet currency from the most common subsidiary used in XAVI formulas
                    const subCounts = {};
                    for (const cell of cellsToFormat) {
                        if (cell.subId) {
                            subCounts[cell.subId] = (subCounts[cell.subId] || 0) + 1;
                        }
                    }
                    const sortedSubs = Object.entries(subCounts).sort((a, b) => b[1] - a[1]);
                    const sheetSubId = sortedSubs.length > 0 ? sortedSubs[0][0] : defaultSub;
                    const sheetSymbol = currencies[sheetSubId] || defaultSymbol;
                    const sheetFormat = formats[sheetSymbol] || defaultFormat;
                    
                    console.log(` Sheet currency for native formulas: ${sheetSymbol} (sub ID: ${sheetSubId})`);
                    
                    // Format all native Excel formulas (non-XAVI) with the sheet currency
                    let nativeFormatted = 0;
                    for (let row = 0; row < usedRange.rowCount; row++) {
                        for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula !== 'string' || !formula.startsWith('=')) continue;
                            
                            // Skip XAVI formulas (already formatted with their specific subsidiary)
                            const upperFormula = formula.toUpperCase();
                            const isXaviFormula = upperFormula.includes('XAVI.BALANCE') || 
                                                  upperFormula.includes('XAVI.TYPEBALANCE') ||
                                                  upperFormula.includes('XAVI.NETINCOME') ||
                                                  upperFormula.includes('XAVI.BUDGET');
                            if (isXaviFormula) continue;
                            
                            // Skip DATE/TEXT formulas used for month headers (preserve mmmm format)
                            if (upperFormula.includes('DATE(') || upperFormula.includes('TEXT(')) continue;
                            
                            // Format native formulas (SUM, arithmetic, etc.)
                            const range = usedRange.getCell(row, col);
                            range.numberFormat = [[sheetFormat]];
                            nativeFormatted++;
                        }
                    }
                    
                    if (nativeFormatted > 0) {
                        await context.sync();
                        console.log(` Also formatted ${nativeFormatted} native Excel formulas`);
                    }
                    
                    updateLoading('Done!', 100);
                    await new Promise(r => setTimeout(r, 500));
                    hideLoading();
                    
                    const nativeNote = nativeFormatted > 0 ? ` + ${nativeFormatted} Excel formulas` : '';
                    statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Formatted ${cellsToFormat.length} XAVI cells${nativeNote}</strong><br><span style="font-size: 11px;">Currency: ${sheetSymbol}</span></div>`;
                    setTimeout(() => statusEl.textContent = '', 5000);
                });
                
            } catch (error) {
                console.error('Error formatting currencies:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                setTimeout(() => statusEl.textContent = '', 5000);
            } finally {
                btn.disabled = false;
                btn.querySelector('.action-text').textContent = 'Format Currencies';
            }
        }
        
        // Helper: Extract parameter from formula string by index (0-based)
        function extractFormulaParam(formula, paramIndex) {
            try {
                // Find the opening parenthesis
                const start = formula.indexOf('(');
                if (start === -1) return '';
                
                // Extract everything between the parentheses
                let depth = 1;
                let end = start + 1;
                while (end < formula.length && depth > 0) {
                    if (formula[end] === '(') depth++;
                    if (formula[end] === ')') depth--;
                    end++;
                }
                
                const paramsStr = formula.substring(start + 1, end - 1);
                
                // Split by comma, but respect nested parentheses and quotes
                const params = [];
                let current = '';
                let inQuotes = false;
                let quoteChar = '';
                let parenDepth = 0;
                
                for (let i = 0; i < paramsStr.length; i++) {
                    const char = paramsStr[i];
                    
                    if ((char === '"' || char === "'") && !inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                        current += char;
                    } else if (char === quoteChar && inQuotes) {
                        inQuotes = false;
                        current += char;
                    } else if (char === '(' && !inQuotes) {
                        parenDepth++;
                        current += char;
                    } else if (char === ')' && !inQuotes) {
                        parenDepth--;
                        current += char;
                    } else if (char === ',' && !inQuotes && parenDepth === 0) {
                        params.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if (current.trim()) {
                    params.push(current.trim());
                }
                
                return params[paramIndex] || '';
            } catch (e) {
                console.error('Error parsing formula:', e);
                return '';
            }
        }

        async function refreshCurrentSheet() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                btn.textContent = 'Checking connection...';
                
                // Reset cancellation flag and show cancel button
                refreshCancelled = false;
                showCancelButton();
                
                // Clear any stale flags from previous runs
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts'); // Don't show toasts during Refresh All
                
                // ============================================
                // STEP 0: Verify connection before starting
                // ============================================
                showLoading('Refresh All', 'Verifying connection to NetSuite...', 2);
                
                const isConnected = await checkConnectionStatus(true);
                if (!isConnected) {
                    hideLoading();
                    hideCancelButton();
                    btn.disabled = false;
                    btn.innerHTML = '<span class="action-icon"></span>Refresh All';
                    
                    showPersistentError(
                        'Connection Failed',
                        'Cannot reach the backend server. The Cloudflare tunnel may have expired.',
                        'Action Required:<br>1. Check the terminal for a new tunnel URL<br>2. Update the Cloudflare Worker with the new URL<br>3. Click "Refresh All" to retry'
                    );
                    
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px; border-left: 4px solid #dc2626;">
                            <strong style="color: #dc2626;"> Connection Failed</strong><br>
                            <small style="color: #7f1d1d;">The tunnel may have expired. Check terminal for new URL.</small>
                        </div>`;
                    }
                    return;
                }
                
                btn.textContent = 'Analyzing...';
                showLoading('Refresh All', 'Checking sheet type...', 5);
                
                // ============================================
                // CHECK FOR AUTO-GENERATED INCOME STATEMENT
                // If Structure Sync = TRUE, rebuild structure first
                // ============================================
                let shouldSyncStructure = false;
                let syncYear = null;
                let syncSubsidiary = null;
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check V2 for sync marker label (Structure Sync is now in column V)
                    const markerCell = sheet.getRange("V2");
                    markerCell.load("values");
                    
                    // Check V3 for sync flag value
                    const syncCell = sheet.getRange("V3");
                    syncCell.load("values");
                    
                    // Get year and subsidiary if this is an auto-generated sheet
                    const yearCell = sheet.getRange("P3");
                    yearCell.load("values");
                    
                    const subCell = sheet.getRange("Q3");
                    subCell.load("values");
                    
                    await context.sync();
                    
                    const markerValue = String(markerCell.values[0][0] || '').toLowerCase();
                    const syncValue = String(syncCell.values[0][0] || '').toUpperCase();
                    
                    // DEBUG: Show exactly what values we're reading
                    console.log(` SYNC CHECK - V2 raw: "${markerCell.values[0][0]}", lowercased: "${markerValue}"`);
                    console.log(` SYNC CHECK - V3 raw: "${syncCell.values[0][0]}", uppercased: "${syncValue}"`);
                    console.log(` SYNC CHECK - includes 'structure sync': ${markerValue.includes('structure sync')}`);
                    console.log(` SYNC CHECK - syncValue === 'TRUE': ${syncValue === 'TRUE'}`);
                    
                    // Check if this is an auto-generated sheet with sync enabled
                    if ((markerValue.includes('structure sync') || markerValue.includes('')) &&
                        (syncValue === 'TRUE' || syncValue === 'YES' || syncValue === '1')) {
                        shouldSyncStructure = true;
                        syncYear = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                        syncSubsidiary = subCell.values[0][0] || '';
                        console.log(` Auto-generated Income Statement detected. Year: ${syncYear}, Subsidiary: "${syncSubsidiary}", Sync: enabled`);
                    } else {
                        console.log(` SYNC CHECK FAILED - not an auto-generated sheet or sync disabled`);
                    }
                });
                
                // If this is an auto-generated sheet with sync enabled, rebuild structure
                console.log(` STRUCTURE SYNC CHECK: shouldSyncStructure = ${shouldSyncStructure}`);
                if (shouldSyncStructure) {
                    showLoading('Refresh All', `Syncing structure for ${syncYear}...`, 10);
                    console.log(` ENTERING STRUCTURE SYNC for year ${syncYear}, subsidiary: "${syncSubsidiary}"`);
                    
                    // Get currency format for the selected subsidiary
                    let currencyFormat = '$#,##0.00';  // Default to USD
                    try {
                        const currencyData = await getCurrencyData();
                        if (currencyData && syncSubsidiary) {
                            const subsidiaryNameToId = await getSubsidiaryLookup();
                            const subId = /^\d+$/.test(syncSubsidiary) ? 
                                syncSubsidiary : 
                                (subsidiaryNameToId[syncSubsidiary.toLowerCase()] || currencyData.default_subsidiary);
                            const symbol = currencyData.currencies[subId] || currencyData.currencies[currencyData.default_subsidiary] || '$';
                            currencyFormat = currencyData.formats[symbol] || '$#,##0.00';
                            console.log(` refreshSelected currency: "${syncSubsidiary}"  ${currencyFormat}`);
                        }
                    } catch (e) {
                        console.warn('Currency lookup failed:', e.message);
                    }
                    
                    // Fetch accounts for the target year AND selected subsidiary
                    console.log(` STRUCTURE SYNC: Calling API with year=${syncYear}, subsidiary="${syncSubsidiary}"`);
                    
                    const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: syncYear,
                            subsidiary: syncSubsidiary || '',  // Use selected subsidiary!
                            department: '',
                            location: '',
                            class: ''
                        })
                    });
                    
                    console.log(` STRUCTURE SYNC: API response status = ${refreshResponse.status}`);
                    
                    if (refreshResponse.ok) {
                        const refreshData = await refreshResponse.json();
                        const allBalances = refreshData.balances || {};
                        const accountTypes = refreshData.account_types || {};
                        const accountNames = refreshData.account_names || {};
                        
                        console.log(` Auto-sync: ${Object.keys(allBalances).length} accounts for "${syncSubsidiary}"`);
                        
                        // Categorize accounts
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        const categories = {
                            income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                        };
                        
                        let skippedZeroData = 0;
                        let categorizedCount = 0;
                        
                        for (const acctNum in allBalances) {
                            const monthData = allBalances[acctNum];
                            const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                            
                            if (hasData) {
                                const acctInfo = {
                                    number: acctNum,
                                    name: accountNames[acctNum] || `Account ${acctNum}`,
                                    type: accountTypes[acctNum] || 'Unknown'
                                };
                                
                                const acctType = (accountTypes[acctNum] || '').toLowerCase();
                                
                                if (acctType === 'income') { categories.income.push(acctInfo); categorizedCount++; }
                                else if (acctType === 'othincome') { categories.othIncome.push(acctInfo); categorizedCount++; }
                                else if (acctType === 'cogs' || acctType === 'cost of goods sold') { categories.cogs.push(acctInfo); categorizedCount++; }
                                else if (acctType === 'expense') { categories.expense.push(acctInfo); categorizedCount++; }
                                else if (acctType === 'othexpense') { categories.othExpense.push(acctInfo); categorizedCount++; }
                                // Skip unknown account types silently - not relevant for P&L
                            } else {
                                skippedZeroData++;
                            }
                        }
                        
                        // Sort categories
                        for (const cat in categories) {
                            categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                        }
                        
                        const totalAccounts = categories.income.length + categories.othIncome.length + 
                                             categories.cogs.length + categories.expense.length + categories.othExpense.length;
                        
                        console.log(` Found ${totalAccounts} P&L accounts for ${syncYear}`);
                        showLoading('Refresh All', `Rebuilding with ${totalAccounts} accounts...`, 20);
                        
                        // Rebuild the sheet
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            
                            // Clear existing content
                            const usedRange = sheet.getUsedRange();
                            usedRange.clear();
                            await context.sync();
                            
                            // Remove gridlines
                            try {
                                sheet.showGridlines = false;
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 1: TITLE =====
                            sheet.getRange("A1").formulas = [['="Income Statement For: "&P3']];
                            await context.sync();
                            try {
                                sheet.getRange("A1").format.font.bold = true;
                                sheet.getRange("A1").format.font.size = 18;
                                sheet.getRange("A1").format.font.color = "#09235C";
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 2: PARAMETER LABELS =====
                            sheet.getRange("P2").values = [["YEAR"]];
                            sheet.getRange("Q2").values = [["Subsidiary"]];
                            sheet.getRange("R2").values = [["Department"]];
                            sheet.getRange("S2").values = [["Location"]];
                            sheet.getRange("T2").values = [["Class"]];
                            sheet.getRange("U2").values = [["Acct Book"]];
                            sheet.getRange("V2").values = [["Structure Sync"]];
                            await context.sync();
                            
                            try {
                                const labelCells = ["P2", "Q2", "R2", "S2", "T2", "U2", "V2"];
                                for (const cell of labelCells) {
                                    sheet.getRange(cell).format.font.bold = true;
                                    sheet.getRange(cell).format.font.color = "#09235C";
                                    sheet.getRange(cell).format.font.size = 10;
                                }
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 3: PARAMETER VALUES =====
                            // Set sync trackers BEFORE context.sync() to prevent race condition
                            lastSyncedYear = String(syncYear);
                            lastSyncedSubsidiary = syncSubsidiary || 'Celigo Inc. (Consolidated)';
                            
                            sheet.getRange("P3").values = [[syncYear]];
                            sheet.getRange("Q3").values = [[syncSubsidiary || 'Celigo Inc. (Consolidated)']];
                            sheet.getRange("R3").values = [[""]];  // Department
                            sheet.getRange("S3").values = [[""]];  // Location
                            sheet.getRange("T3").values = [[""]];  // Class
                            sheet.getRange("U3").values = [[""]];  // Accounting Book
                            sheet.getRange("V3").values = [["TRUE"]];
                            await context.sync();
                            
                            try {
                                const valueCells = ["P3", "Q3", "R3", "S3", "T3", "U3", "V3"];
                                for (const cell of valueCells) {
                                    sheet.getRange(cell).format.fill.color = "#0AE2C1";
                                    sheet.getRange(cell).format.font.bold = true;
                                    sheet.getRange(cell).format.font.color = "#09235C";
                                }
                                await context.sync();
                            } catch (e) {}
                            
                            // NOTE: Filter cell comments removed - caused errors on Mac
                            
                            // ===== ROW 4: KPI METRICS =====
                            try {
                                sheet.getRange("4:4").format.rowHeight = 50;
                                await context.sync();
                            } catch (e) {}
                            
                            try {
                                sheet.getRange("A4:C4").merge();
                                sheet.getRange("D4:F4").merge();
                                sheet.getRange("G4:I4").merge();
                                sheet.getRange("J4:L4").merge();
                                await context.sync();
                            } catch (e) {}
                            
                            sheet.getRange("A4").formulas = [['=" YTD REVENUE\n"&TEXT(SUMIF(B:B,"*Total Revenue*",O:O),"#,##0")&"\nTotal Revenue YTD"']];
                            sheet.getRange("D4").formulas = [['=" GROSS MARGIN\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Gross Profit*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nGross Profit / Revenue"']];
                            sheet.getRange("G4").formulas = [['=" NET INCOME\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Net Income*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nNet Income / Revenue"']];
                            sheet.getRange("J4").formulas = [['=" OPEX RATIO\n"&IF(SUMIF(B:B,"*Total Revenue*",O:O)=0,"N/A",TEXT(SUMIF(B:B,"*Operating Expenses*",O:O)/SUMIF(B:B,"*Total Revenue*",O:O),"0.0%"))&"\nOpEx / Revenue"']];
                            await context.sync();
                            
                            try {
                                sheet.getRange("A4:C4").format.font.bold = true;
                                sheet.getRange("A4:C4").format.font.size = 11;
                                sheet.getRange("A4:C4").format.font.color = "#FFFFFF";
                                sheet.getRange("A4:C4").format.fill.color = "#22C55E";
                                sheet.getRange("A4:C4").format.horizontalAlignment = "Center";
                                sheet.getRange("A4:C4").format.verticalAlignment = "Center";
                                sheet.getRange("A4:C4").format.wrapText = true;
                                sheet.getRange("D4:F4").format.font.bold = true;
                                sheet.getRange("D4:F4").format.font.size = 11;
                                sheet.getRange("D4:F4").format.font.color = "#000000";
                                sheet.getRange("D4:F4").format.fill.color = "#FBBF24";
                                sheet.getRange("D4:F4").format.horizontalAlignment = "Center";
                                sheet.getRange("D4:F4").format.verticalAlignment = "Center";
                                sheet.getRange("D4:F4").format.wrapText = true;
                                sheet.getRange("G4:I4").format.font.bold = true;
                                sheet.getRange("G4:I4").format.font.size = 11;
                                sheet.getRange("G4:I4").format.font.color = "#FFFFFF";
                                sheet.getRange("G4:I4").format.fill.color = "#EF4444";
                                sheet.getRange("G4:I4").format.horizontalAlignment = "Center";
                                sheet.getRange("G4:I4").format.verticalAlignment = "Center";
                                sheet.getRange("G4:I4").format.wrapText = true;
                                sheet.getRange("J4:L4").format.font.bold = true;
                                sheet.getRange("J4:L4").format.font.size = 11;
                                sheet.getRange("J4:L4").format.font.color = "#FFFFFF";
                                sheet.getRange("J4:L4").format.fill.color = "#8B5CF6";
                                sheet.getRange("J4:L4").format.horizontalAlignment = "Center";
                                sheet.getRange("J4:L4").format.verticalAlignment = "Center";
                                sheet.getRange("J4:L4").format.wrapText = true;
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 5: HEADERS =====
                            sheet.getRange("A5").values = [["Account #"]];
                            sheet.getRange("B5").values = [["Account Name"]];
                            for (let m = 0; m < 12; m++) {
                                const col = String.fromCharCode(67 + m);
                                sheet.getRange(`${col}5`).formulas = [[`=DATE($P$3,${m + 1},1)`]];
                            }
                            sheet.getRange("O5").values = [["YTD Total"]];
                            await context.sync();
                            
                            try {
                                sheet.getRange("A5:O5").format.font.bold = true;
                                sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                                sheet.getRange("A5:O5").format.fill.color = "#09235C";
                                sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                                await context.sync();
                            } catch (e) {}
                            
                            // Set column widths to prevent parameter text from affecting month columns
                            try {
                                sheet.getRange("A:A").format.columnWidth = 80;  // Account #
                                sheet.getRange("B:B").format.columnWidth = 180; // Account Name
                                sheet.getRange("C:N").format.columnWidth = 85;  // Month columns (fixed width)
                                sheet.getRange("O:O").format.columnWidth = 90;  // YTD Total
                                await context.sync();
                            } catch (e) {}
                            
                            let currentRow = 6;
                            
                            // Helper functions
                            const writeSectionHeader = async (text, row) => {
                                sheet.getRange(`A${row}`).values = [[text]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                                    sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                                    await context.sync();
                                } catch (e) {}
                            };
                            
                            const writeAccountRow = (acct, row) => {
                                sheet.getRange(`A${row}`).values = [[acct.number]];
                                sheet.getRange(`B${row}`).formulas = [[`=XAVI.NAME($A${row})`]];  // Reference account number for drag-ability
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},${col}$5,${col}$5,$Q$3,$R$3,$S$3,$T$3,$U$3)`]];
                                }
                                sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                            };
                            
                            const writeSubtotalRow = async (text, startRow, endRow, row) => {
                                sheet.getRange(`B${row}`).values = [[text]];
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                                }
                                sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                                    sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                                    await context.sync();
                                } catch (e) {}
                            };
                            
                            // Helper to create named ranges (makes formulas robust against row changes)
                            const createNamedRange = async (name, row) => {
                                try {
                                    try { sheet.names.getItem(name).delete(); await context.sync(); } catch (e) {}
                                    sheet.names.add(name, sheet.getRange(`C${row}:O${row}`));
                                    await context.sync();
                                } catch (e) { console.warn(`Could not create ${name}:`, e.message); }
                            };
                            
                            let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                            let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                            
                            // REVENUE
                            if (categories.income.length > 0) {
                                await writeSectionHeader('REVENUE', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                                revenueTotalRow = currentRow;
                                await createNamedRange('_Total_Revenue', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // COGS
                            if (categories.cogs.length > 0) {
                                await writeSectionHeader('COST OF SALES', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                                cogsTotalRow = currentRow;
                                await createNamedRange('_Total_COGS', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // GROSS PROFIT - Always create if we have revenue or COGS
                            if (revenueTotalRow || cogsTotalRow) {
                                sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                                // LET formula: cleaner, more efficient than INDIRECT
                                const gpFormula = '=LET(rev,IFERROR(@_Total_Revenue,0),cogs,IFERROR(@_Total_COGS,0),IF(cogs<0,ABS(rev)+ABS(cogs),ABS(rev)-ABS(cogs)))';
                                for (let m = 0; m < 13; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${currentRow}`).formulas = [[gpFormula]];
                                }
                                await context.sync();
                                try {
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                                    await context.sync();
                                } catch (e) {}
                                grossProfitRow = currentRow;
                                await createNamedRange('_Gross_Profit', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // OPERATING EXPENSES
                            if (categories.expense.length > 0) {
                                await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                                expenseTotalRow = currentRow;
                                await createNamedRange('_Total_Operating_Expenses', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // OPERATING INCOME - Always create if we have gross profit or expenses
                            if (grossProfitRow || expenseTotalRow) {
                                sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                                // LET formula: cleaner, more efficient than INDIRECT
                                const oiFormula = '=LET(gp,IFERROR(@_Gross_Profit,0),opex,IFERROR(@_Total_Operating_Expenses,0),IF(opex<0,ABS(gp)+ABS(opex),ABS(gp)-ABS(opex)))';
                                for (let m = 0; m < 13; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${currentRow}`).formulas = [[oiFormula]];
                                }
                                await context.sync();
                                try {
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                                    await context.sync();
                                } catch (e) {}
                                operatingIncomeRow = currentRow;
                                await createNamedRange('_Operating_Income', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // OTHER INCOME
                            if (categories.othIncome.length > 0) {
                                await writeSectionHeader('OTHER INCOME', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                                othIncomeTotalRow = currentRow;
                                await createNamedRange('_Total_Other_Income', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // OTHER EXPENSE
                            if (categories.othExpense.length > 0) {
                                await writeSectionHeader('OTHER EXPENSE', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                                othExpenseTotalRow = currentRow;
                                await createNamedRange('_Total_Other_Expense', currentRow);
                                currentRow++;
                                currentRow++;
                            }
                            
                            // NET INCOME - LET formula: ADD otherExp (already signed correctly)
                            sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                            // Net Income = Operating Income + Other Income - Other Expense
                    // Simple formula works because raw data has correct signs:
                    // - Positive expenses hurt income (subtract)
                    // - Negative expenses (credits/gains) help income (subtracting negative = adding)
                    const niFormula = '=LET(opInc,IFERROR(@_Operating_Income,IFERROR(@_Gross_Profit,IFERROR(@_Total_Revenue,0))),otherInc,IFERROR(@_Total_Other_Income,0),otherExp,IFERROR(@_Total_Other_Expense,0),opInc+otherInc-otherExp)';
                            for (let m = 0; m < 13; m++) {
                                const col = String.fromCharCode(67 + m);
                                sheet.getRange(`${col}${currentRow}`).formulas = [[niFormula]];
                            }
                            await context.sync();
                            
                            try {
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                                await context.sync();
                            } catch (e) {}
                            netIncomeRow = currentRow;
                            await createNamedRange('_Net_Income', currentRow);
                            
                            // Format numbers with correct currency
                            try {
                                const rows = netIncomeRow - 5;
                                const formatArray = Array(rows).fill(null).map(() => Array(13).fill(currencyFormat));
                                sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                                await context.sync();
                            } catch (e) {}
                            
                            // Freeze header rows
                            try {
                                sheet.freezePanes.freezeRows(5);
                                await context.sync();
                            } catch (e) {}
                        });
                        
                        console.log(` Income Statement structure synced for ${syncYear}`);
                    }
                    
                    // After sync, the formulas are already set up - we're done!
                    hideLoading();
                    hideCancelButton();
                    btn.disabled = false;
                    btn.innerHTML = '<span class="action-icon"></span>Refresh All';
                    
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px; border-left: 4px solid #10b981;">
                            <strong style="color: #065f46;"> Structure Synced for ${syncYear}</strong><br>
                            <small style="color: #047857;">Income Statement rebuilt with all accounts for ${syncYear}. Formulas will resolve shortly.</small>
                        </div>`;
                    }
                    return; // Exit early - structure sync handles everything
                }
                
                // Continue with normal refresh for non-auto-generated sheets...
                showLoading('Refresh All', 'Scanning formulas on sheet...', 5);
                
                // NOTE: We do NOT set netsuite_show_toasts during Refresh All
                // All status updates go to the task pane instead of toast popups
                // This prevents toasts from appearing during bulk operations
                console.log(' Refresh All mode - toasts will NOT appear (status in task pane only)');
                
                const start = Date.now();
                let formulasFound = [];
                let detectedYears = new Set();
                let detectedPeriods = new Set();  // Specific periods like "Dec 2024", "Jan 2025"
                let detectedAccounts = new Set();
                let cellsToUpdate = [];  // BALANCE formulas
                let specialFormulas = []; // RETAINEDEARNINGS, NETINCOME, CTA formulas
                
                // ============================================
                // STEP 1: Scan sheet to detect years & accounts
                // ============================================
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("formulas, values, rowCount, columnCount, address");
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    const values = usedRange.values;
                    const rowCount = usedRange.rowCount;
                    const colCount = usedRange.columnCount;
                    
                    console.log(` Scanning ${rowCount}  ${colCount} cells...`);
                    
                    // Find all XAVI formulas (BALANCE and special formulas)
                    for (let row = 0; row < rowCount; row++) {
                        for (let col = 0; col < colCount; col++) {
                            const formula = formulas[row][col];
                            if (formula && typeof formula === 'string') {
                                const upperFormula = formula.toUpperCase();
                                
                                // BALANCE formulas - refresh first
                                if (upperFormula.includes('XAVI.BALANCE')) {
                                cellsToUpdate.push({ row, col, formula });
                                
                                // Try to extract account from formula
                                const accountMatch = formula.match(/XAVI\.BALANCE\s*\(\s*["']?(\d+)["']?/i);
                                if (accountMatch) {
                                    detectedAccounts.add(accountMatch[1]);
                                    }
                                }
                                
                                // Special formulas - refresh AFTER BALANCE data is loaded
                                if (upperFormula.includes('XAVI.RETAINEDEARNINGS') ||
                                    upperFormula.includes('XAVI.NETINCOME') ||
                                    upperFormula.includes('XAVI.CTA')) {
                                    const formulaType = upperFormula.includes('RETAINEDEARNINGS') ? 'RETAINEDEARNINGS' :
                                                       upperFormula.includes('NETINCOME') ? 'NETINCOME' : 'CTA';
                                    specialFormulas.push({ row, col, formula, type: formulaType });
                                }
                            }
                        }
                    }
                    
                    // Also scan for date values to detect SPECIFIC PERIODS (not just years)
                    // Support multiple formats: "Jan 2025", "12/1/24", Excel serial dates
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const dateSlashFormat = /^\d{1,2}\/\d{1,2}\/\d{2,4}$/;  // "12/1/24" or "12/1/2024"
                    
                    // Helper to convert date to "Mon YYYY" format
                    function toPeriodFormat(date) {
                        if (!date || isNaN(date.getTime())) return null;
                        return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
                    }
                    
                    for (let row = 0; row < Math.min(rowCount, 20); row++) {
                        for (let col = 0; col < Math.min(colCount, 50); col++) {
                            const cellValue = values[row][col];
                            const val = String(cellValue || '').trim();
                            
                            // Check for "Jan 2025" format - already in correct format!
                            const monYearMatch = val.match(/^([A-Za-z]{3})\s+(20\d{2})$/);
                            if (monYearMatch) {
                                const monthIdx = monthNames.findIndex(m => m.toLowerCase() === monYearMatch[1].toLowerCase());
                                if (monthIdx >= 0) {
                                    const period = `${monthNames[monthIdx]} ${monYearMatch[2]}`;
                                    detectedPeriods.add(period);
                                    detectedYears.add(parseInt(monYearMatch[2]));
                                    continue;
                                }
                            }
                            
                            // Check for "12/1/24" or "1/1/25" or "12/1/2024" format
                            if (dateSlashFormat.test(val)) {
                                const parts = val.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                                if (parts) {
                                    let year = parseInt(parts[3]);
                                    // Convert 2-digit year: 24 -> 2024, 25 -> 2025
                                    if (year < 100) year += 2000;
                                    const month = parseInt(parts[1]) - 1; // 0-indexed
                                    if (month >= 0 && month < 12) {
                                        const period = `${monthNames[month]} ${year}`;
                                        detectedPeriods.add(period);
                                        detectedYears.add(year);
                                    }
                                }
                                continue;
                            }
                            
                            // Check for Excel serial date number (e.g., 45627)
                            if (typeof cellValue === 'number' && cellValue > 30000 && cellValue < 60000) {
                                // Convert Excel serial to JS date
                                const excelEpoch = new Date(1899, 11, 30);
                                const jsDate = new Date(excelEpoch.getTime() + cellValue * 86400000);
                                const period = toPeriodFormat(jsDate);
                                if (period) {
                                    detectedPeriods.add(period);
                                    detectedYears.add(jsDate.getFullYear());
                                }
                            }
                        }
                    }
                    
                });
                
                console.log(` Found ${cellsToUpdate.length} XAVI.BALANCE formulas`);
                console.log(` Found ${specialFormulas.length} special formulas (RETAINEDEARNINGS/NETINCOME/CTA)`);
                
                if (cellsToUpdate.length === 0 && specialFormulas.length === 0) {
                    hideLoading();
                    statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #92400e;">No XAVI formulas found</strong></div>`;
                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    return;
                }
                
                // Default to current year if none detected
                if (detectedYears.size === 0) {
                    detectedYears.add(new Date().getFullYear());
                }
                
                const yearsArray = [...detectedYears].sort();
                
                // ============================================
                // STEP 2: Get account types to classify P&L vs BS
                // ============================================
                updateLoading('Classifying accounts...', 10, `${detectedAccounts.size} accounts found`);
                
                let plAccounts = [];
                let bsAccounts = [];
                
                if (detectedAccounts.size > 0) {
                    try {
                        const typeResponse = await fetch(`${SERVER_URL}/batch/account_types`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ accounts: [...detectedAccounts] })
                        });
                        
                        if (typeResponse.ok) {
                            const typeData = await typeResponse.json();
                            // All Balance Sheet account types in NetSuite
                            // Assets: Bank, AcctRec, OthCurrAsset, FixedAsset, OthAsset, DeferExpense (Prepaid), UnbilledRec
                            // Liabilities: AcctPay, CredCard (NOT CreditCard!), OthCurrLiab, LongTermLiab, DeferRevenue
                            // Equity: Equity, RetainedEarnings
                            const bsTypes = ['Bank', 'AcctRec', 'OthCurrAsset', 'FixedAsset', 'OthAsset', 'DeferExpense',
                                           'AcctPay', 'CredCard', 'OthCurrLiab', 'LongTermLiab', 'DeferRevenue',
                                           'Equity', 'RetainedEarnings', 'UnbilledRec'];
                            
                            // Log which types we received for debugging
                            console.log(' Account types from API:', JSON.stringify(typeData.types));
                            
                            for (const [acct, type] of Object.entries(typeData.types || {})) {
                                const isBsType = bsTypes.includes(type);
                                console.log(`   Account ${acct}: type="${type}"  ${isBsType ? 'BS' : 'P&L'}`);
                                if (isBsType) {
                                    bsAccounts.push(acct);
                                } else {
                                    plAccounts.push(acct);
                                }
                            }
                            console.log(` P&L accounts: ${plAccounts.length}, BS accounts: ${bsAccounts.length}`);
                        }
                    } catch (e) {
                        // If type API fails, fetch BOTH P&L and BS to be safe
                        // This is slower but ensures no accounts are missed
                        console.error(' Type API failed! Will fetch BOTH P&L and BS:', e);
                        plAccounts = [...detectedAccounts];
                        bsAccounts = [...detectedAccounts];
                        showToast({ type: 'warning', title: 'Account Classification Failed', 
                            message: 'Could not classify accounts. Fetching both P&L and BS data to be safe (slower).', duration: 8000 });
                    }
                }
                
                // Clear cache before fetching - MUST use __CLEARCACHE__ formula
                // because functions.js runs in a separate iframe context
                localStorage.removeItem('netsuite_balance_cache');
                localStorage.removeItem('netsuite_balance_cache_timestamp');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const tempRange = sheet.getRange('ZZ9999');
                    tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","ALL","")`]];
                    await context.sync();
                    await new Promise(r => setTimeout(r, 500));
                    tempRange.clear();
                    await context.sync();
                });
                
                let totalAccountsLoaded = 0;
                let allBalances = {};
                
                // ============================================
                // STEP 3: Fetch P&L accounts (fast ~30s/year)
                // ONLY fetch P&L if there are actually P&L accounts detected
                // If detectedAccounts is empty AND there are BALANCE formulas, 
                // we still need to classify them - skip P&L in that case
                // ============================================
                
                // ONLY fetch P&L if we actually have P&L accounts identified
                if (plAccounts.length > 0) {
                    console.log(` Fetching P&L data for ${plAccounts.length} accounts: ${plAccounts.join(', ')}`);
                    updateLoading('Fetching P&L accounts...', 15, `${plAccounts.length} P&L accounts, Years: ${yearsArray.join(', ')}`);
                    
                    for (let i = 0; i < yearsArray.length; i++) {
                        // Check for cancellation
                        if (refreshCancelled) {
                            console.log(` Refresh cancelled - stopping P&L fetch at year ${i + 1}/${yearsArray.length}`);
                            break;
                        }
                        
                        const year = yearsArray[i];
                        const progress = 15 + (i / yearsArray.length) * 35;
                        updateLoading(`Fetching P&L data for ${year}...`, progress, 
                            `Year ${i + 1} of ${yearsArray.length}  ${plAccounts.length} P&L accounts`);
                        
                        try {
                const response = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: year,
                                    skip_bs: true, // P&L only
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                            if (response.ok) {
                                const data = await response.json();
                                Object.assign(allBalances, data.balances || {});
                                totalAccountsLoaded += Object.keys(data.balances || {}).length;
                                console.log(` Year ${year}: ${Object.keys(data.balances || {}).length} P&L accounts`);
                            } else if (response.status === 502 || response.status === 524 || response.status === 522 || response.status === 530) {
                                // Tunnel/proxy error - this is critical
                                console.error(` P&L fetch FAILED: Tunnel error ${response.status}`);
                                
                                let errorTitle = 'Connection Lost';
                                let errorDesc = '';
                                let errorAction = '';
                                
                                if (response.status === 530 || response.status === 522) {
                                    errorTitle = ' Tunnel Expired (Error ' + response.status + ')';
                                    errorDesc = 'The Cloudflare tunnel has expired and needs to be restarted.';
                                    errorAction = `
                                        <strong>To fix:</strong><br>
                                        1. Run in terminal: <code>cloudflared tunnel --url http://localhost:5002</code><br>
                                        2. Copy the new <code>*.trycloudflare.com</code> URL<br>
                                        3. Go to <a href="https://dash.cloudflare.com" target="_blank">dash.cloudflare.com</a>  Workers  Update TUNNEL_URL`;
                                } else if (response.status === 502) {
                                    errorTitle = ' Server Not Running (Error 502)';
                                    errorDesc = 'The backend server is not responding.';
                                    errorAction = `
                                        <strong>To fix:</strong><br>
                                        1. Check if server.py is running on port 5002<br>
                                        2. Run: <code>cd backend && python3 server.py</code>`;
                                } else {
                                    errorTitle = ' Connection Timeout (Error ' + response.status + ')';
                                    errorDesc = 'The connection timed out. Server may be overloaded.';
                                    errorAction = 'Try again in a moment, or check the terminal for errors.';
                                }
                                
                                showPersistentError(errorTitle, errorDesc, errorAction);
                                // Update connection status
                                await checkConnectionStatus(true);
                            } else {
                                console.error(` P&L fetch error: ${response.status}`);
                                showToast({ type: 'warning', title: 'P&L Fetch Warning', 
                                    message: `Error ${response.status} loading P&L for ${year}. Some data may be missing.`, duration: 6000 });
                            }
                        } catch (e) {
                            console.error(`Error fetching year ${year}:`, e);
                            showPersistentError(
                                'P&L Data Fetch Failed',
                                `Could not load P&L data for ${year}. Your formulas may show $0 or stale values.`,
                                `Error: ${e.message}<br>Try: Click "Refresh All" to retry.`
                            );
                            // Update connection status
                            await checkConnectionStatus(true);
                        }
                    }
                } else {
                    updateLoading('No P&L accounts to fetch', 50, 'All detected accounts are Balance Sheet type');
                }
                
                // ============================================
                // STEP 4: Fetch Balance Sheet accounts (OPTIMIZED!)
                // Uses batch_bs_periods endpoint - ONE query for ALL periods
                // Instead of 12 queries (~14 min), runs 1 query (~36 sec)
                // ============================================
                
                // ONLY fetch BS if we have BS accounts, OR if we have no accounts at all (fallback for all BALANCE formulas)
                if (bsAccounts.length > 0 || (detectedAccounts.size === 0 && cellsToUpdate.length > 0)) {
                    const bsCount = bsAccounts.length || 'All detected';
                    console.log(` Fetching BS for ${bsCount} accounts`);
                    updateLoading('Fetching Balance Sheet accounts...', 50, 
                        `Unlike P&L accounts, Balance Sheet accounts must be summed from the beginning of time (inception-to-date). Using OPTIMIZED single-query approach.`);
                    
                    // Use ONLY the specific periods detected on the sheet (not all 12 months per year!)
                    const allPeriods = [...detectedPeriods];
                    
                    // If no specific periods detected, fall back to all months for detected years
                    if (allPeriods.length === 0 && yearsArray.length > 0) {
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        for (const year of yearsArray) {
                            for (const month of months) {
                                allPeriods.push(`${month} ${year}`);
                            }
                        }
                    } else {
                        console.log(` BS: Fetching ONLY ${allPeriods.length} specific periods (optimized!)`);
                    }
                    updateLoading(`Fetching BS data (${allPeriods.length} periods)...`, 55, 
                        `Running single query for ${allPeriods.length} BS periods. ~${Math.max(10, allPeriods.length * 2)} seconds.`);
                    
                    try {
                        // Use the EFFICIENT batch_bs_periods endpoint
                        const response = await fetch(`${SERVER_URL}/batch/bs_periods`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                periods: allPeriods,
                                    subsidiary: '',
                                    department: '',
                                    location: '',
                                    class: ''
                                })
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                // Merge BS balances into allBalances
                                for (const [acct, periods] of Object.entries(data.balances || {})) {
                                    if (!allBalances[acct]) allBalances[acct] = {};
                                    Object.assign(allBalances[acct], periods);
                                }
                                totalAccountsLoaded += Object.keys(data.balances || {}).length;
                            console.log(` BS: ${Object.keys(data.balances || {}).length} accounts loaded in ${data.query_time?.toFixed(1) || '?'}s`);
                            updateLoading('BS data loaded!', 85, 
                                `${Object.keys(data.balances || {}).length} BS accounts in ${data.query_time?.toFixed(1) || '?'}s`);
                        } else if (response.status === 524 || response.status === 522 || response.status === 504) {
                            // Tunnel timeout - show warning
                            console.error(` BS fetch TIMEOUT (${response.status})`);
                            updateLoading(`BS fetch timed out`, 85, 
                                `Tunnel timeout (${response.status}). BS formulas may show stale data.`);
                            showToast({ type: 'warning', title: 'Balance Sheet Timeout', 
                                message: `BS query timed out (${response.status}). Use "Refresh Selected" on individual cells.`, duration: 10000 });
                        } else {
                            console.error(` BS fetch error: ${response.status}`);
                            showPersistentError(
                                'Balance Sheet Fetch Failed',
                                `Error ${response.status} loading Balance Sheet data. BS formulas may show incorrect values.`,
                                `HTTP Status: ${response.status}<br>Try: Use "Refresh Selected" on individual cells, or "Refresh All" to retry.`
                            );
                            }
                    } catch (e) {
                        console.error(`Error fetching BS data:`, e);
                        showPersistentError(
                            'Balance Sheet Fetch Failed',
                            'Could not load Balance Sheet data. BS formulas may show incorrect values.',
                            `Error: ${e.message}<br>Try: Click "Refresh All" to retry.`
                        );
                        // Update connection status
                        await checkConnectionStatus(true);
                    }
                }
                
                // ============================================
                // STEP 5: Save to localStorage cache
                // ============================================
                updateLoading('Saving to cache...', 88, `${totalAccountsLoaded} accounts loaded`);
                
                const accountsLoaded = Object.keys(allBalances).length;
                let periodsLoaded = 0;
                for (const acct in allBalances) {
                    periodsLoaded += Object.keys(allBalances[acct]).length;
                }
                
                console.log(` Preparing to save: ${accountsLoaded} accounts, ${periodsLoaded} period values`);
                
                // Log the data status (not an error if there are simply no accounts on the sheet)
                if (accountsLoaded === 0) {
                    // Only show error if we had accounts to fetch but got nothing back
                    // This is NOT an error if the sheet simply has no BALANCE formulas
                    if (cellsToUpdate.length > 0) {
                        console.warn(' No balance data loaded but BALANCE formulas exist on sheet');
                        // Don't show error toast - formulas will individually resolve via cache misses
                    } else {
                    }
                } else {
                }
                
                try {
                    const cacheJson = JSON.stringify(allBalances);
                    const cacheTimestamp = Date.now().toString();
                    
                    localStorage.setItem('netsuite_balance_cache', cacheJson);
                    localStorage.setItem('netsuite_balance_cache_timestamp', cacheTimestamp);
                    
                    // Verify the save was successful - but don't show error for empty cache
                    const verifyData = localStorage.getItem('netsuite_balance_cache');
                    const verifyTimestamp = localStorage.getItem('netsuite_balance_cache_timestamp');
                    
                    if (!verifyData) {
                        // Only show error if localStorage actually failed (not just empty data)
                        console.error(' localStorage save FAILED - could not write to storage');
                        showToast({ type: 'error', title: 'Cache Save Failed', 
                            message: 'Failed to save balance data to cache. Check browser storage settings.', duration: 10000 });
                    } else {
                        console.log(` localStorage save VERIFIED: ${verifyData.length} chars, timestamp=${verifyTimestamp}`);
                    }
                    
                    // Small delay to ensure localStorage is fully synced across contexts
                    await new Promise(r => setTimeout(r, 200));
                    
                } catch (e) {
                    console.error('localStorage save error:', e);
                    showToast({ type: 'error', title: 'Cache Error', 
                        message: `Failed to save data: ${e.message}`, duration: 10000 });
                }
                
                // Also populate the in-memory cache if Shared Runtime is available
                if (typeof window.setFullYearCache === 'function') {
                    try { 
                        window.setFullYearCache(allBalances); 
                        console.log(' setFullYearCache called successfully');
                    } catch (e) {
                        console.warn('setFullYearCache failed:', e.message);
                    }
                } else {
                    console.log(' setFullYearCache not available (Shared Runtime may not be active)');
                }
                
                // ============================================
                // STEP 6: Re-apply formulas to force evaluation
                // ============================================
                updateLoading('Re-evaluating formulas...', 90, `${cellsToUpdate.length} formulas`);
                
                let formulasRefreshed = 0;
                const BATCH_SIZE = 100;
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("address");
                    await context.sync();
                    
                    const totalBatches = Math.ceil(cellsToUpdate.length / BATCH_SIZE);
                    
                    for (let batchNum = 0; batchNum < totalBatches; batchNum++) {
                        const batchStart = batchNum * BATCH_SIZE;
                        const batchEnd = Math.min(batchStart + BATCH_SIZE, cellsToUpdate.length);
                        const batch = cellsToUpdate.slice(batchStart, batchEnd);
                        
                        const progress = 90 + Math.round((batchNum / totalBatches) * 8);
                        updateLoading(`Refreshing formulas...`, progress, 
                            `Batch ${batchNum + 1}/${totalBatches}`);
                        
                        for (const { row, col, formula } of batch) {
                            const cell = usedRange.getCell(row, col);
                            cell.formulas = [[formula]];
                            formulasRefreshed++;
                        }
                        
                        await context.sync();
                        
                        if (batchNum < totalBatches - 1) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                    
                    updateLoading('Recalculating BALANCE formulas...', 92);
                    usedRange.calculate();
                    await context.sync();
                });
                
                // ============================================
                // CRITICAL: Wait for BALANCE formulas to actually resolve
                // context.sync() only sends the command - formulas may still be #BUSY#
                // We need to poll and wait for them to finish before moving on
                // ============================================
                updateLoading('Waiting for BALANCE formulas to resolve...', 93);
                console.log(' Waiting for BALANCE formulas to resolve (up to 2 minutes)...');
                
                const balanceWaitStart = Date.now();
                const maxBalanceWait = 120000; // 2 minutes max wait for BALANCE formulas
                let balanceResolved = false;
                
                while (Date.now() - balanceWaitStart < maxBalanceWait) {
                    let busyCount = 0;
                    let resolvedCount = 0;
                    
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load('values');
                        await context.sync();
                        
                        const values = usedRange.values;
                        for (let row = 0; row < values.length; row++) {
                            for (let col = 0; col < values[row].length; col++) {
                                const val = String(values[row][col] || '');
                                if (val.includes('BUSY') || val === '#BUSY!' || val === '#BUSY#') {
                                    busyCount++;
                                }
                            }
                        }
                        resolvedCount = cellsToUpdate.length - busyCount;
                    });
                    
                    const elapsed = ((Date.now() - balanceWaitStart) / 1000).toFixed(1);
                    
                    if (busyCount === 0) {
                        console.log(` All BALANCE formulas resolved in ${elapsed}s`);
                        balanceResolved = true;
                        break;
                    }
                    
                    console.log(`    Still waiting: ${busyCount} formulas still calculating (${elapsed}s)...`);
                    updateLoading('Waiting for BALANCE formulas...', 93, 
                        `${busyCount} formulas still calculating...`);
                    
                    // Wait 2 seconds before checking again
                    await new Promise(r => setTimeout(r, 2000));
                }
                
                if (!balanceResolved) {
                    console.warn(` BALANCE formulas did not fully resolve within ${maxBalanceWait/1000}s - proceeding anyway`);
                }
                
                // ============================================
                // BALANCE formulas complete - notify user
                // NOTE: Special formulas (NI/RE/CTA) are NOT refreshed here
                // Use "Recalculate RE/NI/CTA" button for those
                // ============================================
                const balanceElapsed = ((Date.now() - start) / 1000).toFixed(1);
                console.log(` BALANCE formulas complete in ${balanceElapsed}s`);
                
                // Clear bulk refresh flag
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts');
                
                const elapsed = ((Date.now() - start) / 1000).toFixed(1);
                
                if (refreshCancelled) {
                    // Cancelled - already handled
                } else {
                    updateLoading('Complete!', 100, `${formulasRefreshed} formulas refreshed`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ============================================
                    // AUTO-FORMAT: Apply currency formatting to all BALANCE cells
                    // Uses cached currency data for performance
                    // ============================================
                    try {
                        updateLoading('Applying currency formats...', 100);
                        await autoFormatCurrencies();
                        console.log(' Auto-format currencies complete');
                    } catch (formatError) {
                        console.warn('Currency formatting failed (non-critical):', formatError.message);
                    }
                }
                
                hideLoading();
                hideCancelButton();
                
                // Check if data was actually loaded - use multiple indicators for robustness
                // Data is loaded if: accounts were fetched OR formulas were refreshed (meaning cache hit)
                const dataLoaded = totalAccountsLoaded > 0 || formulasRefreshed > 0 || Object.keys(allBalances).length > 0;
                
                // Build summary message
                let summaryParts = [];
                if (plAccounts.length > 0 || bsAccounts.length === 0) {
                    summaryParts.push(`P&L: ${yearsArray.length} year(s)`);
                }
                if (bsAccounts.length > 0) {
                    summaryParts.push(`Balance Sheet: ${bsAccounts.length} accounts`);
                }
                
                // Check if there are special formulas on the sheet that need manual refresh
                const hasSpecialFormulas = specialFormulas.length > 0;
                
                if (!dataLoaded) {
                    // WARNING: No data was loaded - likely connection issue
                    // Show at TOP of add-in for visibility
                    const topBanner = document.getElementById('topNotificationBanner');
                    if (topBanner) {
                        topBanner.style.display = 'block';
                        topBanner.innerHTML = `
                            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 14px; border-radius: 8px; margin-bottom: 12px; border-left: 5px solid #f59e0b; box-shadow: 0 2px 8px rgba(245,158,11,0.2);">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div>
                                    <strong style="color: #b45309; font-size: 14px;"> Refresh Complete - No Data Loaded</strong><br>
                                    <span style="font-size: 12px; color: #92400e; display: block; margin-top: 4px;">
                                        Formulas were refreshed but no account data was retrieved.
                                    </span>
                                    <div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 11px; color: #78350f;">
                                        <strong>Possible causes:</strong><br>
                                         Cloudflare tunnel may have expired<br>
                                         Backend server may not be running<br>
                                         Network connectivity issues<br><br>
                                        <strong>Try:</strong> Check connection status in Settings, then Refresh All again.
                                    </div>
                                </div>
                                    <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #b45309; padding: 0; margin-left: 8px;">&times;</button>
                            </div>
                        </div>
                    `;
                    }
                    statusEl.textContent = ''; // Clear inline status
                } else {
                    let specialNote = '';
                    if (hasSpecialFormulas) {
                        specialNote = `<br><span style="color: #92400e; font-style: italic;"> ${specialFormulas.length} RE/NI/CTA formula(s) detected. Use "Recalculate RE/NI/CTA" button to refresh them.</span>`;
                }
                
                statusEl.innerHTML = `
                    <div style="background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); padding: 14px; border-radius: 8px; margin-top: 10px; animation: fadeIn 0.3s; border-left: 5px solid #10b981;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div>
                                <strong style="color: #059669; font-size: 14px;"> Account Balances Refreshed!</strong><br>
                                <span style="font-size: 12px; color: #047857;">
                                    ${summaryParts.join('  ')}<br>
                                    ${totalAccountsLoaded} accounts loaded  ${formulasRefreshed} BALANCE formulas refreshed in ${elapsed}s
                                    ${specialNote}
                                </span>
                            </div>
                            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; cursor: pointer; font-size: 16px; color: #059669; padding: 0; margin-left: 8px; opacity: 0.7;">&times;</button>
                        </div>
                    </div>
                `;
                }
                
                // Success message auto-clears after 30 seconds (but can be dismissed earlier)
                setTimeout(() => { if (statusEl.innerHTML.includes('Refreshed!')) statusEl.textContent = ''; }, 30000);
                
            } catch (error) {
                console.error('Error refreshing sheet:', error);
                hideLoading();
                hideCancelButton();
                hideToast(); // Clear any lingering toast
                
                // Clear bulk refresh flag on error
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts');
                
                // Show error at TOP of add-in for visibility
                const topBanner = document.getElementById('topNotificationBanner');
                if (topBanner) {
                    topBanner.style.display = 'block';
                    topBanner.innerHTML = `
                        <div style="background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); padding: 14px; border-radius: 8px; margin-bottom: 12px; border-left: 5px solid #dc2626; box-shadow: 0 2px 8px rgba(220,38,38,0.2);">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div>
                                    <strong style="color: #dc2626; font-size: 14px;"> Refresh Failed</strong><br>
                                    <span style="font-size: 12px; color: #991b1b; display: block; margin-top: 4px;">${error.message}</span>
                                    <div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 11px; color: #7f1d1d;">
                                        <strong>What to try:</strong><br>
                                        1. Check if the tunnel is running (ask your admin)<br>
                                        2. Click "Refresh All" to retry<br>
                                        3. Check the terminal for errors
                                    </div>
                                </div>
                                <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #dc2626; padding: 0; margin-left: 8px;">&times;</button>
                            </div>
                        </div>
                    `;
                }
                
                // Also show inline for legacy support
                statusEl.innerHTML = `
                    <div style="background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); padding: 14px; border-radius: 8px; margin-top: 10px; border-left: 5px solid #dc2626; box-shadow: 0 2px 8px rgba(220,38,38,0.2);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div>
                                <strong style="color: #dc2626; font-size: 14px;"> Refresh Failed</strong><br>
                                <span style="font-size: 12px; color: #991b1b; display: block; margin-top: 4px;">${error.message}</span>
                                <div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 11px; color: #7f1d1d;">
                                    <strong>What to try:</strong><br>
                                    1. Check if the tunnel is running (ask your admin)<br>
                                    2. Click "Refresh All" to retry<br>
                                    3. Check the terminal for errors
                                </div>
                            </div>
                            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #dc2626; padding: 0; margin-left: 8px;">&times;</button>
                        </div>
                    </div>
                `;
                // Error stays until dismissed - no auto-clear
            } finally {
                // Always clean up
                localStorage.removeItem('netsuite_bulk_refresh');
                hideToast();
                btn.disabled = false;
                btn.innerHTML = '<span class="action-icon"></span><span class="action-text">Refresh All</span>';
            }
        }

        // ============================================
        // RECALCULATE SPECIAL FORMULAS (RE, NI, CTA)
        // Separate from Refresh All because these require
        // scanning entire transaction history and take up to 5 minutes
        // Uses floating status so user can continue working
        // ============================================
        async function recalculateSpecialFormulas() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            // Light orange color for highlighting pending cells
            const PENDING_COLOR = '#FEF3C7'; // Light amber/orange
            
            try {
                btn.disabled = true;
                const start = Date.now();
                
                // Check connection first (brief full overlay just for connection check)
                showLoading('Recalculate Retained Earnings', 'Verifying connection...', 5);
                const isConnected = await checkConnectionStatus(true);
                if (!isConnected) {
                    hideLoading();
                    btn.disabled = false;
                    statusEl.innerHTML = `
                        <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #dc2626;"> Not Connected</strong><br>
                            <span style="font-size: 12px; color: #991b1b;">Cannot reach NetSuite server. Please check your connection.</span>
                        </div>
                    `;
                    return;
                }
                
                updateLoading('Scanning for formulas...', 10);
                
                // Scan sheet for special formulas AND resolve cell references to actual dates
                let specialFormulas = [];
                let detectedPeriods = new Set();
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("values, formulas, rowCount, columnCount, address");
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    const values = usedRange.values;
                    
                    // Helper to resolve cell reference to value
                    const resolveCellRef = async (cellRef) => {
                        try {
                            const refRange = sheet.getRange(cellRef);
                            refRange.load('values');
                            await context.sync();
                            return refRange.values[0][0];
                        } catch (e) {
                            return cellRef; // Return as-is if can't resolve
                        }
                    };
                    
                    for (let row = 0; row < usedRange.rowCount; row++) {
                        for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula === 'string' && formula.startsWith('=')) {
                                const upperFormula = formula.toUpperCase();
                                
                                if (upperFormula.includes('XAVI.RETAINEDEARNINGS') ||
                                    upperFormula.includes('XAVI.NETINCOME') ||
                                    upperFormula.includes('XAVI.CTA')) {
                                    const formulaType = upperFormula.includes('RETAINEDEARNINGS') ? 'RETAINEDEARNINGS' :
                                                       upperFormula.includes('NETINCOME') ? 'NETINCOME' : 'CTA';
                                    
                                    // Extract period - could be a string literal or a cell reference
                                    const periodMatch = formula.match(/\(([^,)]+)/);
                                    let rawPeriod = '';
                                    let resolvedPeriod = '';
                                    
                                    if (periodMatch) {
                                        rawPeriod = periodMatch[1].replace(/["']/g, '').trim();
                                        
                                        // Check if it's a cell reference (like L$3, $L3, L3, etc.)
                                        if (rawPeriod.match(/^\$?[A-Z]+\$?\d+$/i)) {
                                            // It's a cell reference - resolve it
                                            const refValue = await resolveCellRef(rawPeriod);
                                            if (refValue) {
                                                // Could be a date serial number or a string
                                                if (typeof refValue === 'number') {
                                                    // Excel date serial - convert to readable date
                                                    const date = new Date((refValue - 25569) * 86400 * 1000);
                                                    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                                                                   'July', 'August', 'September', 'October', 'November', 'December'];
                                                    resolvedPeriod = `${months[date.getMonth()]} ${date.getFullYear()}`;
                                                } else {
                                                    resolvedPeriod = String(refValue);
                                                }
                                            }
                                        } else if (rawPeriod.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}$/i)) {
                                            // It's already a period string
                                            resolvedPeriod = rawPeriod;
                                            detectedPeriods.add(rawPeriod);
                                        }
                                    }
                                    
                                    specialFormulas.push({ 
                                        row, col, formula, type: formulaType, 
                                        rawPeriod, resolvedPeriod: resolvedPeriod || rawPeriod 
                                    });
                                }
                            }
                        }
                    }
                });
                
                if (specialFormulas.length === 0) {
                    hideLoading();
                    statusEl.innerHTML = `
                        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #92400e;">No Formulas Found</strong><br>
                            <span style="font-size: 12px; color: #a16207;">This sheet doesn't contain any XAVI.RETAINEDEARNINGS, XAVI.NETINCOME, or XAVI.CTA formulas.</span>
                        </div>
                    `;
                    btn.disabled = false;
                    setTimeout(() => { statusEl.textContent = ''; }, 8000);
                    return;
                }
                
                console.log(` Found ${specialFormulas.length} special formulas to recalculate`);
                
                // Sort by type: NETINCOME first (fastest), then RETAINEDEARNINGS, then CTA (slowest)
                const typeOrder = { 'NETINCOME': 1, 'RETAINEDEARNINGS': 2, 'CTA': 3 };
                specialFormulas.sort((a, b) => (typeOrder[a.type] || 99) - (typeOrder[b.type] || 99));
                
                // Highlight ALL cells that will be recalculated with light orange
                console.log(' Highlighting cells to be recalculated...');
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    
                    for (const { row, col } of specialFormulas) {
                        const cell = usedRange.getCell(row, col);
                        cell.format.fill.color = PENDING_COLOR;
                    }
                    await context.sync();
                });
                
                // Hide full overlay - switch to floating status
                hideLoading();
                
                // Show floating status (smaller, non-blocking)
                showFloatingStatus(
                    `Recalculating ${specialFormulas.length} formulas...`,
                    `You can continue working. Highlighted cells will update.`,
                    0
                );
                
                // Pre-clear ALL special formula caches
                for (const period of detectedPeriods) {
                    try {
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const tempRange = sheet.getRange('ZZ9997');
                            const clearCmd = `SPECIAL:ALL:${period}`;
                            tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${clearCmd}","")`]];
                            await context.sync();
                            await new Promise(r => setTimeout(r, 200));
                            tempRange.clear();
                            await context.sync();
                        });
                    } catch (e) {
                        console.warn(`Cache clear failed for ${period}:`, e.message);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Helper function to wait for a cell to resolve
                async function waitForCellToResolve(row, col, maxWaitMs = 300000) {
                    const pollInterval = 2000;
                    const startTime = Date.now();
                    
                    while (Date.now() - startTime < maxWaitMs) {
                        let cellValue = null;
                        
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const usedRange = sheet.getUsedRange();
                            const cell = usedRange.getCell(row, col);
                            cell.load("values");
                            await context.sync();
                            cellValue = cell.values[0][0];
                        });
                        
                        const valueStr = String(cellValue || '');
                        const isResolved = valueStr !== '' && 
                                          !valueStr.includes('BUSY') &&
                                          !valueStr.includes('CALC') &&
                                          cellValue !== null;
                        
                        if (isResolved) {
                            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                            return { resolved: true, value: cellValue, elapsed };
                        }
                        
                        await new Promise(r => setTimeout(r, pollInterval));
                    }
                    
                    return { resolved: false, value: null, elapsed: maxWaitMs / 1000 };
                }
                
                // Helper to format period for display
                const formatPeriodDisplay = (resolvedPeriod) => {
                    const monthMap = {
                        'Jan': 'January', 'Feb': 'February', 'Mar': 'March', 'Apr': 'April',
                        'May': 'May', 'Jun': 'June', 'Jul': 'July', 'Aug': 'August',
                        'Sep': 'September', 'Oct': 'October', 'Nov': 'November', 'Dec': 'December'
                    };
                    const periodParts = resolvedPeriod.match(/^(\w+)\s+(\d{4})$/);
                    if (periodParts) {
                        const fullMonth = monthMap[periodParts[1]] || periodParts[1];
                        return `${fullMonth} ${periodParts[2]}`;
                    }
                    return resolvedPeriod;
                };
                
                // Process formulas ONE AT A TIME
                let successCount = 0;
                let errorCount = 0;
                
                for (let i = 0; i < specialFormulas.length; i++) {
                    const { row, col, formula, type, rawPeriod, resolvedPeriod } = specialFormulas[i];
                    const progress = Math.round((i / specialFormulas.length) * 100);
                    
                    const periodDisplay = formatPeriodDisplay(resolvedPeriod);
                    
                    // Set max wait time and message based on type
                    let maxWaitTime = 300000; // 5 minutes default
                    let typeLabel = type;
                    if (type === 'NETINCOME') {
                        typeLabel = 'Net Income';
                        maxWaitTime = 120000; // 2 minutes
                    } else if (type === 'RETAINEDEARNINGS') {
                        typeLabel = 'Retained Earnings';
                        maxWaitTime = 300000; // 5 minutes
                    } else if (type === 'CTA') {
                        typeLabel = 'CTA';
                        maxWaitTime = 300000; // 5 minutes
                    }
                    
                    // Update floating status
                    updateFloatingStatus(
                        `${typeLabel} (${i + 1}/${specialFormulas.length})`,
                        `${periodDisplay}`,
                        progress
                    );
                    console.log(` Processing ${type} for ${periodDisplay}...`);
                    
                    // Clear cache for THIS specific formula (use resolved period for cache key)
                    const cacheKeyPeriod = resolvedPeriod.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}$/i) 
                        ? resolvedPeriod : rawPeriod;
                    try {
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const tempRange = sheet.getRange('ZZ9998');
                            const clearCmd = `SPECIAL:${type}:${cacheKeyPeriod}`;
                            tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${clearCmd}","")`]];
                            await context.sync();
                            await new Promise(r => setTimeout(r, 300));
                            tempRange.clear();
                            await context.sync();
                        });
                    } catch (e) {
                        console.warn(`Cache clear failed for ${type}:${periodDisplay}:`, e.message);
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                    
                    // Trigger formula recalculation
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        const cell = usedRange.getCell(row, col);
                        cell.formulas = [[formula]];
                        await context.sync();
                        cell.calculate();
                        await context.sync();
                    });
                    
                    // Wait for resolution
                    const result = await waitForCellToResolve(row, col, maxWaitTime);
                    
                    // Remove highlight from this cell (clear fill)
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        const cell = usedRange.getCell(row, col);
                        cell.format.fill.clear();
                        await context.sync();
                    });
                    
                    if (result.resolved) {
                        const valueDisplay = typeof result.value === 'number' 
                            ? result.value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
                            : String(result.value);
                        console.log(`    ${type} [${periodDisplay}] = ${valueDisplay} (${result.elapsed}s)`);
                        successCount++;
                    } else {
                        console.log(`    ${type} [${periodDisplay}] TIMEOUT after ${result.elapsed}s`);
                        errorCount++;
                    }
                    
                    // Brief pause before next
                    await new Promise(r => setTimeout(r, 500));
                }
                
                const elapsed = ((Date.now() - start) / 1000).toFixed(1);
                
                // Hide floating status
                hideFloatingStatus();
                
                // Show result in status area
                if (errorCount === 0) {
                    statusEl.innerHTML = `
                        <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #059669; font-size: 14px;"> Recalculation Complete!</strong><br>
                            <span style="font-size: 12px; color: #047857;">
                                ${successCount} formula(s) updated in ${elapsed}s
                            </span>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #b45309; font-size: 14px;"> Completed with Issues</strong><br>
                            <span style="font-size: 12px; color: #92400e;">
                                ${successCount} succeeded, ${errorCount} timed out in ${elapsed}s<br>
                                Timed out cells may show #TIMEOUT# - try again or check connection.
                            </span>
                        </div>
                    `;
                }
                
                setTimeout(() => { statusEl.textContent = ''; }, 15000);
                
            } catch (error) {
                console.error('Error recalculating special formulas:', error);
                hideLoading();
                hideFloatingStatus();
                
                // Clear any remaining highlights on error
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load("formulas, rowCount, columnCount");
                        await context.sync();
                        
                        const formulas = usedRange.formulas;
                        for (let row = 0; row < usedRange.rowCount; row++) {
                            for (let col = 0; col < usedRange.columnCount; col++) {
                                const formula = formulas[row][col];
                                if (typeof formula === 'string' && 
                                    (formula.toUpperCase().includes('XAVI.RETAINEDEARNINGS') ||
                                     formula.toUpperCase().includes('XAVI.NETINCOME') ||
                                     formula.toUpperCase().includes('XAVI.CTA'))) {
                                    const cell = usedRange.getCell(row, col);
                                    cell.format.fill.clear();
                                }
                            }
                        }
                        await context.sync();
                    });
                } catch (e) {
                    // Ignore cleanup errors
                }
                
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Error</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
                
                setTimeout(() => { statusEl.textContent = ''; }, 8000);
            } finally {
                btn.disabled = false;
            }
        }

        // ============================================
        // BATCH REFRESH TYPE BALANCES
        // Pre-fetches ALL P&L account type totals (Income, COGS, Expense, OthIncome, OthExpense)
        // for the entire fiscal year in ONE query. Dramatically reduces NetSuite API calls
        // for reports using XAVI.TYPEBALANCE formulas.
        // ============================================
        async function batchRefreshTypeBalances() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                const start = Date.now();
                
                // Get the current year from any date cell or use current year
                const currentYear = new Date().getFullYear();
                
                // Check connection
                showLoading('Preload Type Balances', 'Verifying connection...', 5);
                const isConnected = await checkConnectionStatus(true);
                if (!isConnected) {
                    hideLoading();
                    btn.disabled = false;
                    statusEl.innerHTML = `
                        <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #dc2626;"> Not Connected</strong><br>
                            <span style="font-size: 12px; color: #991b1b;">Cannot reach NetSuite server. Please check your connection.</span>
                        </div>
                    `;
                    return;
                }
                
                updateLoading('Fetching all P&L type balances...', 30, 'This is a single optimized query');
                
                // Get current subsidiary from filter if set
                const subsidiaryValue = document.getElementById('subsidiaryFilter')?.value || '';
                
                // Call the batch endpoint
                const response = await fetch(`${SERVER_URL}/batch/typebalance_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: subsidiaryValue,
                        department: '',
                        location: '',
                        classId: '',
                        accountingBook: ''
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                const balances = data.balances || {};
                const typesLoaded = Object.keys(balances).length;
                
                updateLoading('Populating cache...', 70, `${typesLoaded} account types loaded`);
                
                // Populate the frontend cache using the Shared Runtime function
                if (typeof window.setTypeBalanceCache === 'function') {
                    window.setTypeBalanceCache(
                        balances,
                        currentYear,
                        subsidiaryValue, // subsidiary
                        '',              // department
                        '',              // location
                        '',              // classId
                        '',              // accountingBook
                        false            // useSpecial
                    );
                    console.log(` TypeBalance cache populated with ${typesLoaded} types  12 months`);
                } else {
                    console.warn(' window.setTypeBalanceCache not available (Shared Runtime may not be active)');
                }
                
                // Trigger recalculation of TYPEBALANCE formulas on the sheet
                updateLoading('Refreshing formulas...', 85);
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load('formulas, rowCount, columnCount');
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    let typebalanceCount = 0;
                    
                    for (let row = 0; row < usedRange.rowCount; row++) {
                        for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula === 'string' && formula.toUpperCase().includes('XAVI.TYPEBALANCE')) {
                                const cell = usedRange.getCell(row, col);
                                cell.calculate();
                                typebalanceCount++;
                            }
                        }
                    }
                    await context.sync();
                    
                    console.log(` Triggered recalculation of ${typebalanceCount} TYPEBALANCE formulas`);
                });
                
                const elapsed = ((Date.now() - start) / 1000).toFixed(1);
                
                hideLoading();
                
                // Show success message
                statusEl.innerHTML = `
                    <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #059669; font-size: 14px;"> Type Balances Preloaded!</strong><br>
                        <span style="font-size: 12px; color: #047857;">
                            ${typesLoaded} types  12 months cached in ${elapsed}s<br>
                            TYPEBALANCE formulas will now resolve instantly.
                        </span>
                    </div>
                `;
                
                setTimeout(() => { statusEl.textContent = ''; }, 10000);
                
            } catch (error) {
                console.error('Error in batch typebalance refresh:', error);
                hideLoading();
                
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Error</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
                
                setTimeout(() => { statusEl.textContent = ''; }, 8000);
            } finally {
                btn.disabled = false;
            }
        }

        async function refreshSelected() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                
                showLoading('Refresh Selected', 'Analyzing selected cells...', 10);
                
                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    // Load both formulas AND values - values give us the resolved cell references
                    range.load('address, formulas, values, rowCount, columnCount');
                    await context.sync();
                    
                    updateLoading(`Parsing ${range.address}...`, 20);
                    
                    // Strategy: We need to get the RESOLVED values (account numbers and periods)
                    // The formulas use cell references, so we need to evaluate them
                    // We'll use a different approach: look at each cell that has an XAVI.BALANCE formula
                    // and extract the account/period by evaluating the referenced cells
                    
                    const itemsToClear = [];
                    const formulas = range.formulas;
                    const values = range.values;
                    
                    // Check if any cell contains XAVI formulas (BALANCE, BUDGET, NETINCOME, RETAINEDEARNINGS, CTA)
                    let formulaCount = 0;
                    const cellsWithFormulas = [];
                    const specialFormulas = []; // NETINCOME, RETAINEDEARNINGS, CTA
                    
                    for (let r = 0; r < range.rowCount; r++) {
                        for (let c = 0; c < range.columnCount; c++) {
                            const formula = formulas[r][c];
                            if (formula && typeof formula === 'string') {
                                const upperFormula = formula.toUpperCase();
                                if (upperFormula.includes('XAVI.BALANCE') || upperFormula.includes('XAVI.BUDGET')) {
                                    const formulaType = upperFormula.includes('XAVI.BUDGET') ? 'budget' : 'balance';
                                    formulaCount++;
                                    cellsWithFormulas.push({ row: r, col: c, formula, formulaType });
                                } else if (upperFormula.includes('XAVI.NETINCOME') || 
                                           upperFormula.includes('XAVI.RETAINEDEARNINGS') || 
                                           upperFormula.includes('XAVI.CTA')) {
                                    // Special formulas - need different handling
                                    let formulaType = 'netincome';
                                    if (upperFormula.includes('RETAINEDEARNINGS')) formulaType = 'retainedearnings';
                                    if (upperFormula.includes('CTA')) formulaType = 'cta';
                                    formulaCount++;
                                    specialFormulas.push({ row: r, col: c, formula, formulaType });
                                }
                            }
                        }
                    }
                    
                    console.log(` Found ${formulaCount} XAVI formulas in selection (BALANCE: ${cellsWithFormulas.length}, Special: ${specialFormulas.length})`);
                    
                    if (formulaCount === 0) {
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #d97706;"> No XAVI.BALANCE or XAVI.BUDGET formulas found in selection</strong></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    updateLoading(`Resolving cell references for ${formulaCount} formulas...`, 30);
                    
                    // For each formula, we need to resolve the parameters
                    // Parse formula to extract BOTH quoted literals AND cell references
                    for (const cell of cellsWithFormulas) {
                        const formula = cell.formula;
                        
                        try {
                            // Parse XAVI.BALANCE/BUDGET formula: (account, fromPeriod, toPeriod, subsidiary, ...)
                            // Parameters can be: "literal", CellRef, or empty
                            const args = parseFormulaArgs(formula);
                            console.log(`    Parsed formula args:`, args);
                            
                            if (args.length < 1) continue;
                            
                            // Extract: account (arg 0), fromPeriod (arg 1), toPeriod (arg 2), subsidiary (arg 3)
                            let account = null;
                            let fromPeriod = null;
                            let toPeriod = null;
                            let subsidiary = null;
                            
                            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                            
                            // Helper to resolve a parameter (cell ref or literal)
                            async function resolveParam(param, context) {
                                if (!param || param === '') return null;
                                
                                // Quoted string literal
                                if (param.startsWith('"') && param.endsWith('"')) {
                                    return param.slice(1, -1); // Remove quotes
                                }
                                
                                // Cell reference - resolve it
                                const cellRefPattern = /^\$?[A-Z]+\$?\d+$/i;
                                if (cellRefPattern.test(param)) {
                                    const cellRange = context.workbook.worksheets.getActiveWorksheet().getRange(param);
                                    cellRange.load('values');
                                    await context.sync();
                                    return cellRange.values[0][0];
                                }
                                
                                // Literal number or text without quotes
                                return param;
                            }
                            
                            // Helper to convert value to "Mon YYYY" period format
                            function toPeriodFormat(value) {
                                if (!value && value !== 0) return null;
                                
                                // Excel serial number (> 1000, typically 40000+)
                                if (typeof value === 'number' && value > 40000) {
                                    const excelEpoch = new Date(1900, 0, 1);
                                    const d = new Date(excelEpoch.getTime() + (value - 2) * 24 * 60 * 60 * 1000);
                                    return `${months[d.getMonth()]} ${d.getFullYear()}`;
                                }
                                
                                // Year only (1900-2100)
                                if (typeof value === 'number' && value >= 1900 && value <= 2100) {
                                    return `Dec ${value}`; // Use Dec for toPeriod (cumulative through end of year)
                                }
                                
                                // String period like "Jan 2025" or "2025"
                                if (typeof value === 'string') {
                                    const v = value.trim();
                                    // Year only string
                                    if (/^\d{4}$/.test(v)) {
                                        return `Dec ${v}`;
                                    }
                                    return v;
                                }
                                
                                return String(value).trim();
                            }
                            
                            // Resolve parameters
                            account = await resolveParam(args[0], context);
                            if (args.length > 1) fromPeriod = await resolveParam(args[1], context);
                            if (args.length > 2) toPeriod = await resolveParam(args[2], context);
                            if (args.length > 3) subsidiary = await resolveParam(args[3], context);
                            
                            // For BS accounts with empty fromPeriod, use toPeriod
                            const period = toPeriodFormat(toPeriod || fromPeriod);
                            
                            console.log(`    Resolved: account="${account}", from="${fromPeriod}", to="${toPeriod}", period="${period}"`);
                            
                            if (account && period) {
                                // Include subsidiary in cache key if specified
                                const subsidiaryStr = subsidiary ? String(subsidiary).trim() : '';
                                itemsToClear.push({ account: String(account).trim(), period, formulaType: cell.formulaType, subsidiary: subsidiaryStr });
                                console.log(`    Will clear: ${account} / ${period} / sub="${subsidiaryStr}" (${cell.formulaType})`);
                            }
                        } catch (e) {
                            console.warn(`    Could not parse formula: ${formula}`, e);
                        }
                    }
                    
                    // Helper function to parse formula arguments (handles quotes, cell refs, empty args)
                    function parseFormulaArgs(formula) {
                        // Extract content between parentheses
                        const match = formula.match(/\((.+)\)/);
                        if (!match) return [];
                        
                        const content = match[1];
                        const args = [];
                        let current = '';
                        let inQuotes = false;
                        let depth = 0;
                        
                        for (let i = 0; i < content.length; i++) {
                            const char = content[i];
                            
                            if (char === '"' && content[i-1] !== '\\') {
                                inQuotes = !inQuotes;
                                current += char;
                            } else if (char === '(' && !inQuotes) {
                                depth++;
                                current += char;
                            } else if (char === ')' && !inQuotes) {
                                depth--;
                                current += char;
                            } else if (char === ',' && !inQuotes && depth === 0) {
                                args.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        args.push(current.trim());
                        
                        return args;
                    }
                    
                    console.log(`   Items to clear: ${itemsToClear.length}, Special formulas: ${specialFormulas.length}`);
                    
                    // Handle special formulas (NETINCOME, RETAINEDEARNINGS, CTA)
                    // These need to clear their specific caches in functions.js
                    if (specialFormulas.length > 0) {
                        console.log(` Found ${specialFormulas.length} special formulas to refresh`);
                        
                        // For each special formula, we need to extract the period and clear its cache
                        // Then trigger recalculation by invalidating
                        for (const cell of specialFormulas) {
                            try {
                                // Extract period reference from formula
                                const cellRefPattern = /\$?[A-Z]+\$?\d+/gi;
                                const refs = cell.formula.match(cellRefPattern);
                                
                                if (refs && refs.length >= 1) {
                                    const periodRef = refs[0]; // First param is period
                                const periodCell = context.workbook.worksheets.getActiveWorksheet().getRange(periodRef);
                                periodCell.load('values');
                                await context.sync();
                                
                                let period = periodCell.values[0][0];
                                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                
                                    // Convert date to period format
                                if (typeof period === 'number' && period > 1000) {
                                    const excelEpoch = new Date(1900, 0, 1);
                                    const d = new Date(excelEpoch.getTime() + (period - 2) * 24 * 60 * 60 * 1000);
                                    period = `${months[d.getMonth()]} ${d.getFullYear()}`;
                                    } else if (typeof period === 'number' && period >= 1900 && period <= 2100) {
                                        // Year only - for YTD formulas, use Dec
                                        period = `Dec ${period}`;
                                    }
                                    
                                    console.log(`    Special formula: ${cell.formulaType} for ${period}`);
                                    
                                    // Clear special formula cache using __CLEARCACHE__ command
                                    const specialClearKey = `SPECIAL:${cell.formulaType.toUpperCase()}:${period}`;
                                    
                                    const tempSheet = context.workbook.worksheets.getActiveWorksheet();
                                    const tempRange = tempSheet.getRange('XFD2');
                                    tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${specialClearKey}","")`]];
                                    await context.sync();
                                    
                                    // Wait briefly then clear
                                    await new Promise(r => setTimeout(r, 500));
                                    tempRange.clear();
                                    await context.sync();
                                }
                            } catch (e) {
                                console.warn(`    Could not clear special formula cache:`, e);
                            }
                        }
                    }
                    
                    if (itemsToClear.length === 0 && specialFormulas.length === 0) {
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #d97706;"> Could not resolve cell references</strong></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    // Skip balance/budget cache clearing if only special formulas
                    if (itemsToClear.length === 0) {
                        // Just special formulas - they've been handled above
                        // Trigger recalculation
                        updateLoading('Recalculating special formulas...', 70);
                        await context.workbook.application.calculate(Excel.CalculationType.full);
                        await context.sync();
                        
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #dcfce7; padding: 10px; border-radius: 6px;"><strong style="color: #166534;"> Refreshed ${specialFormulas.length} special formula(s)</strong></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    updateLoading(`Clearing cache for ${itemsToClear.length} items...`, 50);
                    
                    // SELECTIVE cache clear - clear from localStorage directly
                    // Also set invalidation signal for functions.js to check
                    let clearedCount = 0;
                    const balanceItems = itemsToClear.filter(i => i.formulaType === 'balance');
                    const budgetItems = itemsToClear.filter(i => i.formulaType === 'budget');
                    
                    try {
                        // Clear BALANCE cache
                        const BALANCE_STORAGE_KEY = 'netsuite_balance_cache';
                        const balanceStored = localStorage.getItem(BALANCE_STORAGE_KEY);
                        if (balanceStored && balanceItems.length > 0) {
                            const balanceData = JSON.parse(balanceStored);
                            let modified = false;
                            
                            for (const item of balanceItems) {
                                const acct = String(item.account);
                                if (balanceData[acct] && balanceData[acct][item.period] !== undefined) {
                                    delete balanceData[acct][item.period];
                                    clearedCount++;
                                    modified = true;
                                }
                            }
                            
                            if (modified) {
                                localStorage.setItem(BALANCE_STORAGE_KEY, JSON.stringify(balanceData));
                            }
                        }
                        
                        // Clear BUDGET cache
                        const BUDGET_STORAGE_KEY = 'netsuite_budget_cache';
                        const budgetStored = localStorage.getItem(BUDGET_STORAGE_KEY);
                        if (budgetStored && budgetItems.length > 0) {
                            const budgetData = JSON.parse(budgetStored);
                            let budgetCleared = 0;
                            let modified = false;
                            
                            for (const item of budgetItems) {
                                const acct = String(item.account);
                                if (budgetData[acct] && budgetData[acct][item.period] !== undefined) {
                                    delete budgetData[acct][item.period];
                                    budgetCleared++;
                                    modified = true;
                                }
                            }
                            
                            if (modified) {
                                localStorage.setItem(BUDGET_STORAGE_KEY, JSON.stringify(budgetData));
                                clearedCount += budgetCleared;
                            }
                        }
                        
                        // Set cache invalidation signal - functions.js will check this
                        // and clear its in-memory caches when it sees items to invalidate
                        const invalidateKey = 'netsuite_cache_invalidate';
                        // Include subsidiary if specified: "balance:111*:Dec 2025:Celigo Inc. (Consolidated)"
                        const invalidateItems = itemsToClear.map(i => 
                            i.subsidiary ? `${i.formulaType}:${i.account}:${i.period}:${i.subsidiary}` 
                                         : `${i.formulaType}:${i.account}:${i.period}`);
                        localStorage.setItem(invalidateKey, JSON.stringify({
                            items: invalidateItems,
                            timestamp: Date.now()
                        }));
                        console.log(`    Set invalidation signal for ${invalidateItems.length} items`);
                        
                    } catch (e) {
                        console.warn('Cache clear error:', e);
                    }
                    
                    
                    // CRITICAL: Call XAVI.BALANCE("__CLEARCACHE__", "items", "") in the custom functions runtime
                    // This clears cache in the SAME context as BALANCE/BUDGET (different from taskpane!)
                    // Pass specific items as "balance:60032:May 2025,budget:60032:Jun 2025" format
                    updateLoading('Clearing in-memory cache...', 60);
                    try {
                        // Build list with formula type prefix and subsidiary: "balance:111*:Dec 2025:Celigo Inc. (Consolidated)"
                        const itemsList = itemsToClear.map(i => 
                            i.subsidiary ? `${i.formulaType}:${i.account}:${i.period}:${i.subsidiary}` 
                                         : `${i.formulaType}:${i.account}:${i.period}`).join(',');
                        console.log(`   Items: ${itemsList}`);
                        
                        // Use a temporary cell to evaluate the BALANCE function with __CLEARCACHE__ command
                        const tempSheet = context.workbook.worksheets.getActiveWorksheet();
                        const tempRange = tempSheet.getRange('XFD1'); // Far corner, unlikely to be used
                        
                        // Pass specific items - this clears ONLY these items from functions' cache
                        tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${itemsList}","")`]];
                    await context.sync();
                    
                        // Wait for custom function to execute
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                        // Load and read the result
                        tempRange.load('values');
                        await context.sync();
                        
                        const result = tempRange.values[0][0];
                        
                        // Clear the temp cell
                        tempRange.clear();
                    await context.sync();
                    
                    } catch (clearError) {
                        console.warn('    __CLEARCACHE__ call failed:', clearError.message);
                        // Continue anyway - localStorage was cleared from taskpane context
                    }
                    
                    updateLoading(`Recalculating ${formulaCount} formulas...`, 70);
                    
                    // Trigger recalc by re-setting formulas
                    range.formulas = formulas;
                    await context.sync();
                    
                    updateLoading('Fetching from NetSuite...', 85);
                    
                    // Wait for batching to complete
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    updateLoading('Complete!', 100);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    hideLoading();
                    
                    statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Refreshed ${formulaCount} formulas from NetSuite!</strong></div>`;
                    
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 5000);
                });
                
            } catch (error) {
                console.error('Error refreshing selection:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 8000);
            } finally {
                btn.disabled = false;
            }
        }

        // ============================================================================
        // SHARE & EXPORT FUNCTIONS
        // ============================================================================
        
        async function exportReport() {
            const statusEl = document.getElementById('shareStatus');
            const scope = document.querySelector('input[name="exportScope"]:checked').value;
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            
            try {
                statusEl.textContent = 'Preparing export...';
                statusEl.style.color = '#0284c7';
                
                await Excel.run(async (context) => {
                    if (format === 'pdf') {
                        await exportToPDF(context, scope, statusEl);
                    } else {
                        await exportToExcel(context, scope, statusEl);
                    }
                });
                
            } catch (error) {
                console.error('Export error:', error);
                statusEl.textContent = ` Error: ${error.message}`;
                statusEl.style.color = '#dc2626';
                setTimeout(() => { statusEl.textContent = ''; }, 5000);
            }
        }
        
        async function exportToPDF(context, scope, statusEl) {
            statusEl.textContent = 'Reading worksheet data...';
            
            const sheets = [];
            
            if (scope === 'worksheet') {
                // Current worksheet only
                const sheet = context.workbook.worksheets.getActiveWorksheet();
                sheet.load('name');
                const usedRange = sheet.getUsedRange();
                usedRange.load(['values', 'text', 'columnCount', 'rowCount']);
                await context.sync();
                
                sheets.push({
                    name: sheet.name,
                    data: usedRange.text,  // Use text to get formatted values
                    rows: usedRange.rowCount,
                    cols: usedRange.columnCount
                });
            } else {
                // All worksheets
                const allSheets = context.workbook.worksheets;
                allSheets.load('items/name');
                await context.sync();
                
                for (const sheet of allSheets.items) {
                    const usedRange = sheet.getUsedRange();
                    usedRange.load(['text', 'columnCount', 'rowCount']);
                    await context.sync();
                    
                    sheets.push({
                        name: sheet.name,
                        data: usedRange.text,
                        rows: usedRange.rowCount,
                        cols: usedRange.columnCount
                    });
                }
            }
            
            statusEl.textContent = 'Generating PDF...';
            
            // Create PDF using jsPDF - use larger page for wide tables
            const { jsPDF } = window.jspdf;
            
            // Prepare all sheet data first to determine optimal page size
            const allSheetData = sheets.map(sheet => {
                const headers = sheet.data[0] || [];
                const body = sheet.data.slice(1);
                
                // Format currency values - remove .00 decimals
                const formatCurrency = (val) => {
                    if (typeof val !== 'string') return val;
                    const currencyMatch = val.match(/^[\(\-]?\$?([\d,]+)\.(\d{2})[\)]?$/);
                    if (currencyMatch && currencyMatch[2] === '00') {
                        return val.replace(/\.00/, '');
                    }
                    return val;
                };
                
                const formattedBody = body.map(row => row.map(cell => formatCurrency(cell)));
                return { name: sheet.name, headers, body: formattedBody, colCount: headers.length };
            });
            
            // Determine font size based on number of columns (more columns = smaller font)
            const maxCols = Math.max(...allSheetData.map(s => s.colCount));
            let fontSize = 8;
            let cellPadding = 2;
            if (maxCols > 10) { fontSize = 7; cellPadding = 1.5; }
            if (maxCols > 14) { fontSize = 6; cellPadding = 1; }
            if (maxCols > 18) { fontSize = 5; cellPadding = 0.8; }
            
            const doc = new jsPDF({
                orientation: 'landscape',
                unit: 'mm',
                format: 'a4'
            });
            
            let isFirstPage = true;
            
            for (const sheetData of allSheetData) {
                if (!isFirstPage) {
                    doc.addPage();
                }
                isFirstPage = false;
                
                // Add header
                doc.setFontSize(14);
                doc.setTextColor(9, 35, 92);
                doc.text(sheetData.name, 10, 12);
                
                // Add timestamp
                doc.setFontSize(7);
                doc.setTextColor(100);
                doc.text(`Generated: ${new Date().toLocaleString()}`, 10, 17);
                
                // Generate table - let autoTable handle column widths automatically
                doc.autoTable({
                    head: [sheetData.headers],
                    body: sheetData.body,
                    startY: 20,
                    theme: 'striped',
                    headStyles: {
                        fillColor: [9, 35, 92],
                        textColor: 255,
                        fontStyle: 'bold',
                        fontSize: fontSize,
                        halign: 'center',
                        cellPadding: cellPadding
                    },
                    bodyStyles: {
                        fontSize: fontSize,
                        cellPadding: cellPadding
                    },
                    alternateRowStyles: {
                        fillColor: [248, 250, 252]
                    },
                    margin: { left: 10, right: 10, top: 20, bottom: 15 },
                    styles: {
                        overflow: 'linebreak',  // Wrap text if needed, don't truncate
                        cellPadding: cellPadding,
                        fontSize: fontSize,
                        lineWidth: 0.1,
                        minCellWidth: 12  // Minimum column width
                    },
                    tableWidth: 'wrap',  // Auto-fit columns to content
                    didParseCell: function(data) {
                        const value = String(data.cell.raw || '');
                        // Right-align cells that look like currency or numbers
                        if (/^[\(\-]?\$?[\d,]+\.?\d*[\)]?$/.test(value.replace(/\s/g, ''))) {
                            data.cell.styles.halign = 'right';
                        }
                        // First column (row labels) left-aligned
                        if (data.column.index === 0 && data.section === 'body') {
                            data.cell.styles.halign = 'left';
                            data.cell.styles.fontStyle = 'normal';
                        }
                        // Highlight negative values in red
                        if (value.startsWith('(') || value.startsWith('-$') || value.startsWith('-')) {
                            data.cell.styles.textColor = [180, 0, 0];
                        }
                        // Bold for total/summary rows
                        const firstCol = String(data.row.raw[0] || '').toLowerCase();
                        if (firstCol.includes('total') || firstCol.includes('net income') || firstCol.includes('gross margin')) {
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                });
            }
            
            // Add footer to all pages
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(150);
                doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
                doc.text('Generated by XAVI for NetSuite', 14, doc.internal.pageSize.height - 10);
            }
            
            // Generate filename
            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = scope === 'worksheet' 
                ? `${sheets[0].name}_${timestamp}.pdf`
                : `Workbook_${timestamp}.pdf`;
            
            // Download
            doc.save(filename);
            
            statusEl.textContent = ` PDF downloaded: ${filename}`;
            statusEl.style.color = '#059669';
            setTimeout(() => { statusEl.textContent = ''; }, 5000);
        }
        
        // ================================================================
        // SAVE FOR DISTRIBUTION
        // Routes to PDF or Excel export based on format selection
        // ================================================================
        async function prepareForDistribution() {
            const statusEl = document.getElementById('shareStatus');
            const scope = document.querySelector('input[name="exportScope"]:checked').value;
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            
            // If PDF format selected, use the PDF export function
            if (format === 'pdf') {
                try {
                    statusEl.textContent = 'Generating PDF...';
                    statusEl.style.color = '#0284c7';
                    await Excel.run(async (context) => {
                        await exportToPDF(context, scope, statusEl);
                    });
                } catch (error) {
                    console.error('PDF export error:', error);
                    statusEl.innerHTML = `
                        <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px; border-left: 5px solid #dc2626; word-wrap: break-word;">
                            <strong style="color: #dc2626;"> Error:</strong> ${error.message}
                        </div>
                    `;
                }
                return;
            }
            
            // Excel format - use ExcelJS for full formatting preservation
            const exportCurrentSheetOnly = (scope === 'worksheet');
            
            try {
                statusEl.textContent = 'Getting workbook file...';
                statusEl.style.color = '#0284c7';
                
                // First, get the computed values for XAVI formulas from the live workbook
                let activeSheetName = '';
                let xaviCellMap = new Map(); // Map of "SheetName!A1" -> computed value
                let allSheetNames = [];
                
                await Excel.run(async (context) => {
                    const sheets = context.workbook.worksheets;
                    sheets.load('items/name');
                    const activeSheet = context.workbook.worksheets.getActiveWorksheet();
                    activeSheet.load('name');
                await context.sync();
                
                    activeSheetName = activeSheet.name;
                    allSheetNames = sheets.items.map(s => s.name);
                    
                    // Determine which sheets to process
                    const sheetsToProcess = exportCurrentSheetOnly 
                        ? [activeSheet] 
                        : sheets.items;
                    
                    // Process each sheet
                    for (const sheet of sheetsToProcess) {
                        sheet.load('name');
                    const usedRange = sheet.getUsedRange();
                        usedRange.load(['formulas', 'values', 'rowCount', 'columnCount', 'address']);
                    await context.sync();
                    
                        const sheetName = sheet.name;
                        const rowCount = usedRange.rowCount;
                        const colCount = usedRange.columnCount;
                        const formulas = usedRange.formulas;
                        const values = usedRange.values;
                        
                        // Get the starting cell address
                        const addressParts = usedRange.address.split('!');
                        const rangeRef = addressParts.length > 1 ? addressParts[1] : addressParts[0];
                        const startAddress = rangeRef.split(':')[0];
                        const startMatch = startAddress.match(/([A-Z]+)(\d+)/);
                        const startCol = startMatch ? columnLetterToNumber(startMatch[1]) : 1;
                        const startRow = startMatch ? parseInt(startMatch[2]) : 1;
                        
                        // Build map of XAVI cells to their computed values
                        for (let r = 0; r < rowCount; r++) {
                            for (let c = 0; c < colCount; c++) {
                                const formula = formulas[r][c];
                                if (typeof formula === 'string' && formula.toUpperCase().includes('XAVI.')) {
                                    const cellRef = numberToColumnLetter(startCol + c) + (startRow + r);
                                    xaviCellMap.set(`${sheetName}!${cellRef}`, values[r][c]);
                                }
                            }
                        }
                    }
                    
                    console.log(`Found ${xaviCellMap.size} XAVI formulas to replace`);
                });
                
                statusEl.textContent = `Reading workbook (${xaviCellMap.size} XAVI formulas)...`;
                
                // Get the actual workbook file bytes using Office.js getFileAsync
                const fileData = await new Promise((resolve, reject) => {
                    Office.context.document.getFileAsync(
                        Office.FileType.Compressed,
                        { sliceSize: 65536 },
                        async (result) => {
                            if (result.status === Office.AsyncResultStatus.Failed) {
                                reject(new Error(result.error.message));
                                return;
                            }
                            
                            const file = result.value;
                            const sliceCount = file.sliceCount;
                            const slices = [];
                            
                            // Read all slices
                            for (let i = 0; i < sliceCount; i++) {
                                const sliceData = await new Promise((resolveSlice, rejectSlice) => {
                                    file.getSliceAsync(i, (sliceResult) => {
                                        if (sliceResult.status === Office.AsyncResultStatus.Failed) {
                                            rejectSlice(new Error(sliceResult.error.message));
                                        } else {
                                            resolveSlice(sliceResult.value.data);
                                        }
                                    });
                                });
                                slices.push(sliceData);
                            }
                            
                            file.closeAsync();
                            
                            // Combine slices into single ArrayBuffer
                            const totalLength = slices.reduce((sum, slice) => sum + slice.length, 0);
                            const combined = new Uint8Array(totalLength);
                            let offset = 0;
                            for (const slice of slices) {
                                combined.set(new Uint8Array(slice), offset);
                                offset += slice.length;
                            }
                            
                            resolve(combined.buffer);
                        }
                    );
                });
                
                statusEl.textContent = 'Processing with ExcelJS...';
                
                // Load the workbook into ExcelJS - this preserves ALL formatting!
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(fileData);
                
                // If exporting current sheet only, remove all other sheets
                if (exportCurrentSheetOnly) {
                    const sheetsToRemove = [];
                    workbook.eachSheet((ws, id) => {
                        if (ws.name !== activeSheetName) {
                            sheetsToRemove.push(id);
                        }
                    });
                    // Remove sheets in reverse order to avoid index issues
                    sheetsToRemove.reverse().forEach(id => {
                        workbook.removeWorksheet(id);
                    });
                }
                
                statusEl.textContent = 'Replacing XAVI formulas...';
                
                let replacedCount = 0;
                
                // Replace XAVI formulas with their computed values
                for (const [fullRef, value] of xaviCellMap) {
                    const [sheetName, cellRef] = fullRef.split('!');
                    const worksheet = workbook.getWorksheet(sheetName);
                    if (worksheet) {
                        const cell = worksheet.getCell(cellRef);
                        cell.value = value;
                        replacedCount++;
                    }
                }
                
                statusEl.textContent = 'Downloading...';
                
                // Export the modified workbook
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], { 
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                });
                
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `${activeSheetName}_${timestamp}.xlsx`;
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                statusEl.innerHTML = `
                    <div style="background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); padding: 14px; border-radius: 8px; margin-top: 10px; border-left: 5px solid #10b981; word-wrap: break-word; overflow-wrap: break-word;">
                        <strong style="color: #059669; font-size: 13px;"> Downloaded</strong><br>
                        <span style="font-size: 11px; color: #047857; display: block; margin-top: 4px; word-break: break-all;">
                            ${filename}
                        </span>
                        <span style="font-size: 11px; color: #047857; display: block; margin-top: 4px;">
                            ${replacedCount} XAVI formula(s)  values
                        </span>
                    </div>
                `;
                
            } catch (error) {
                console.error('Save for distribution error:', error);
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px; border-left: 5px solid #dc2626;">
                        <strong style="color: #dc2626;"> Error:</strong> ${error.message}
                    </div>
                `;
            }
        }
        
        // Helper functions for cell reference conversion
        function columnLetterToNumber(letters) {
            let result = 0;
            for (let i = 0; i < letters.length; i++) {
                result = result * 26 + (letters.charCodeAt(i) - 64);
            }
            return result;
        }
        
        function numberToColumnLetter(num) {
            let result = '';
            while (num > 0) {
                num--;
                result = String.fromCharCode(65 + (num % 26)) + result;
                num = Math.floor(num / 26);
            }
            return result;
        }
        
        function showEmailComingSoon() {
            const statusEl = document.getElementById('shareStatus');
            statusEl.innerHTML = `
                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 14px; border-radius: 8px; margin-top: 10px; border-left: 5px solid #f59e0b;">
                    <strong style="color: #b45309; font-size: 13px;"> Email Feature Coming Soon</strong><br>
                    <span style="font-size: 12px; color: #92400e; display: block; margin-top: 6px;">
                        This feature is under development.<br>
                        For now, use "Save for Distribution" to download, then attach to your email.
                    </span>
                </div>
            `;
            setTimeout(() => { statusEl.innerHTML = ''; }, 6000);
        }

        // ================================================================
        // DRILL-DOWN STATUS HELPERS
        // ================================================================
        function showDrilldownStatus(message, detail = '', isProcessing = true) {
            const widget = document.getElementById('drilldownStatus');
            if (!widget) return;
            
            const msgEl = document.getElementById('drilldownMessage');
            const detailEl = document.getElementById('drilldownDetail');
            const iconEl = document.getElementById('drilldownIcon');
            const titleEl = document.getElementById('drilldownTitle');
            const dismissBtn = document.getElementById('drilldownDismiss');
            const spinnerEl = document.getElementById('drilldownSpinner');
            
            widget.className = 'drilldown-status';
            iconEl.textContent = '';
            titleEl.textContent = 'Transaction Drill-Down';
            msgEl.textContent = message;
            detailEl.textContent = detail;
            dismissBtn.style.display = 'none';
            spinnerEl.style.display = isProcessing ? 'block' : 'none';
            widget.style.display = 'block';
        }
        
        function showDrilldownSuccess(message, detail = '') {
            const widget = document.getElementById('drilldownStatus');
            if (!widget) return;
            
            const msgEl = document.getElementById('drilldownMessage');
            const detailEl = document.getElementById('drilldownDetail');
            const iconEl = document.getElementById('drilldownIcon');
            const titleEl = document.getElementById('drilldownTitle');
            const dismissBtn = document.getElementById('drilldownDismiss');
            
            widget.className = 'drilldown-status success';
            iconEl.textContent = '';
            titleEl.textContent = 'Drill-Down Complete';
            msgEl.textContent = message;
            detailEl.textContent = detail;
            dismissBtn.style.display = 'block';
            widget.style.display = 'block';
            
            // Auto-dismiss after 8 seconds
            setTimeout(() => hideDrilldownStatus(), 8000);
        }
        
        function showDrilldownError(message, detail = '') {
            const widget = document.getElementById('drilldownStatus');
            const msgEl = document.getElementById('drilldownMessage');
            const detailEl = document.getElementById('drilldownDetail');
            const iconEl = document.getElementById('drilldownIcon');
            const titleEl = document.getElementById('drilldownTitle');
            const dismissBtn = document.getElementById('drilldownDismiss');
            
            widget.className = 'drilldown-status error';
            iconEl.textContent = '';
            titleEl.textContent = 'Drill-Down Error';
            msgEl.textContent = message;
            detailEl.textContent = detail;
            dismissBtn.style.display = 'block';
            widget.style.display = 'block';
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => hideDrilldownStatus(), 10000);
        }
        
        function hideDrilldownStatus() {
            const widget = document.getElementById('drilldownStatus');
            if (widget) widget.style.display = 'none';
        }
        
        // ================================================================
        // QUICK ACTIONS HELP MODAL
        // ================================================================
        function showQuickActionsHelp() {
            document.getElementById('quickHelpModal').classList.add('active');
        }
        
        function hideQuickActionsHelp(event) {
            // If called from backdrop click, event is passed
            // If called from close button, just close
            document.getElementById('quickHelpModal').classList.remove('active');
        }

        async function drillDownTransactions() {
            const statusEl = document.getElementById('drillStatus');
            const btn = event?.target;
            const isQuickActionsBtn = btn?.id === 'quickDrillBtn';
            const originalBtnHTML = btn?.innerHTML; // Save original to restore later
            
            try {
                if (btn) {
                btn.disabled = true;
                btn.innerHTML = isQuickActionsBtn ? '<span></span> Loading...' : 'Loading...';
                }
                statusEl.textContent = '';
                showDrilldownStatus('Analyzing selected cell...', 'Detecting formula type');
                
                await Excel.run(async (context) => {
                    // Get the selected cell
                    const range = context.workbook.getSelectedRange();
                    range.load(['formulas', 'values', 'address']);
                    
                    await context.sync();
                    
                    const formula = range.formulas[0][0];
                    const address = range.address;
                    // Ensure formula is a string before calling toUpperCase (could be a number)
                    const upperFormula = String(formula || '').toUpperCase();
                    
                    // ================================================================
                    // CHECK FOR TYPEBALANCE DRILL-DOWN SHEET (static account numbers)
                    // ================================================================
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    sheet.load('name');
                    await context.sync();
                    
                    console.log(` Drill-down: checking sheet "${sheet.name}", address="${address}"`);
                    
                    if (sheet.name.startsWith('DrillDown_')) {
                        console.log(` On DrillDown_ sheet - checking for context`);
                        // Check for drill-down context in row 3
                        const contextCell = sheet.getRange('A3');
                        contextCell.load('values');
                        await context.sync();
                        
                        const contextValue = String(contextCell.values[0][0] || '');
                        console.log(` A3 context value: "${contextValue}"`);
                        
                        if (contextValue.startsWith('DRILLDOWN_CONTEXT:')) {
                            // This is a TYPEBALANCE drill-down sheet - get account from column A
                            const rowMatch = address.match(/\d+/);
                            const row = rowMatch ? parseInt(rowMatch[0]) : 0;
                            console.log(` Row from address: ${row}`);
                            
                            if (row >= 6) {
                                // Get account number from column A
                                const acctCell = sheet.getRange(`A${row}`);
                                acctCell.load('values');
                                await context.sync();
                                
                                const account = String(acctCell.values[0][0] || '');
                                console.log(` Account from column A: "${account}"`);
                                
                                if (account && account !== 'TOTAL') {
                                    // Parse context: DRILLDOWN_CONTEXT:period:subsidiary
                                    const parts = contextValue.split(':');
                                    const period = parts[1] || '';
                                    const subsidiary = parts[2] || '';
                                    
                                    console.log(` TYPEBALANCE drill-down: account=${account}, period=${period}, subsidiary=${subsidiary}`);
                                    
                                    showDrilldownStatus(`Fetching transactions for account ${account}...`, `Period: ${period}`);
                                    
                                    // Fetch transactions directly
                                    const queryParams = new URLSearchParams({ account, period });
                                    if (subsidiary) queryParams.append('subsidiary', subsidiary);
                                    
                                    const response = await fetch(`${SERVER_URL}/transactions?${queryParams}`);
                                    if (!response.ok) throw new Error(`API error: ${response.status}`);
                                    
                                    const data = await response.json();
                                    const transactions = data.transactions || [];
                                    
                                    console.log(` TYPEBALANCE transactions received:`, {
                                        count: transactions.length,
                                        sample: transactions.slice(0, 2).map(t => ({
                                            tranid: t.transaction_number,
                                            debit: t.debit,
                                            credit: t.credit,
                                            net: t.net_amount
                                        }))
                                    });
                                    
                                    if (transactions.length === 0) {
                                        showDrilldownSuccess('No transactions found', `Account ${account} has no activity for ${period}`);
                        return;
                    }
                    
                                    await createDrillDownSheet(context, transactions, { account, period, subsidiary });
                                    showDrilldownSuccess(`Found ${transactions.length} transaction(s)`, `Account ${account}  ${period}`);
                                    return;
                                }
                            }
                            
                            showDrilldownError('Invalid selection', 'Please select a row with an account number');
                            return;
                        }
                    }
                    
                    // ================================================================
                    // FORMULA TYPE DETECTION
                    // ================================================================
                    const hasBalance = upperFormula.includes('XAVI.BALANCE');
                    const hasTypeBalance = upperFormula.includes('XAVI.TYPEBALANCE');
                    const hasBudget = upperFormula.includes('XAVI.BUDGET');
                    const hasNetIncome = upperFormula.includes('XAVI.NETINCOME');
                    const hasRetainedEarnings = upperFormula.includes('XAVI.RETAINEDEARNINGS');
                    
                    // Check for unsupported formulas
                    if (hasBudget) {
                        showDrilldownError('Not available for BUDGET formulas', 'Drill-down is only supported for BALANCE and TYPEBALANCE');
                        return;
                    }
                    
                    if (hasNetIncome || hasRetainedEarnings) {
                        showDrilldownError('Not available for this formula type', 'NETINCOME and RETAINEDEARNINGS formulas aggregate multiple accounts');
                        return;
                    }
                    
                    // Check for supported formulas
                    if (!hasBalance && !hasTypeBalance) {
                        showDrilldownError('No XAVI formula found', 'Select a cell with XAVI.BALANCE or XAVI.TYPEBALANCE');
                        return;
                    }
                    
                    // ================================================================
                    // TYPEBALANCE: Two-step drill-down (show accounts first)
                    // ================================================================
                    if (hasTypeBalance) {
                        await handleTypeBalanceDrillDown(context, formula, statusEl);
                        return;
                    }
                    
                    // ================================================================
                    // BALANCE: Handle single or multiple formulas
                    // ================================================================
                    // Find ALL XAVI.BALANCE formulas in the cell (for formulas like A + B)
                    const balanceMatches = formula.match(/XAVI\.BALANCE\s*\([^)]+\)/gi) || [];
                    
                    if (balanceMatches.length === 0) {
                        showDrilldownError('Could not parse BALANCE formula', 'The formula structure was not recognized');
                        return;
                    }
                    
                    console.log(` Found ${balanceMatches.length} BALANCE formula(s) in cell`);
                    showDrilldownStatus('Parsing formula parameters...', `Found ${balanceMatches.length} BALANCE formula(s)`);
                    
                    // Parse each formula and collect all accounts
                    const allAccounts = [];
                    let commonParams = null;
                    
                    for (const balanceFormula of balanceMatches) {
                        const cellRefs = parseFormulaCellRefs(balanceFormula);
                    const params = await resolveFormulaParams(context, cellRefs);
                    
                        if (params && params.account) {
                            allAccounts.push(params.account);
                            // Use first formula's params as common params (period, subsidiary, etc.)
                            if (!commonParams) {
                                commonParams = params;
                            }
                        }
                    }
                    
                    if (allAccounts.length === 0 || !commonParams || !commonParams.period) {
                        showDrilldownError('Could not parse formula parameters', 'Check that account and period values are set');
                        return;
                    }
                    
                    console.log(` Drilling down for accounts: ${allAccounts.join(', ')}`);
                    showDrilldownStatus(`Fetching transactions...`, `${allAccounts.length} account(s)  ${commonParams.period}`);
                    
                    // Fetch transactions for ALL accounts
                    let allTransactions = [];
                    
                    for (const account of allAccounts) {
                    const queryParams = new URLSearchParams({
                            account: account,
                            period: commonParams.period
                        });
                        
                        if (commonParams.subsidiary) queryParams.append('subsidiary', commonParams.subsidiary);
                        if (commonParams.department) queryParams.append('department', commonParams.department);
                        if (commonParams.location) queryParams.append('location', commonParams.location);
                        if (commonParams.class) queryParams.append('class', commonParams.class);
                    
                    const fetchUrl = `${SERVER_URL}/transactions?${queryParams}`;
                    
                        try {
                    const response = await fetch(fetchUrl);
                    
                            if (response.ok) {
                                const data = await response.json();
                                if (data.transactions && data.transactions.length > 0) {
                                    // Add account number to each transaction for multi-account view
                                    data.transactions.forEach(txn => {
                                        txn.account_number = txn.account_number || account;
                                    });
                                    allTransactions = allTransactions.concat(data.transactions);
                                }
                            }
                        } catch (e) {
                            console.warn(`Could not fetch transactions for ${account}:`, e);
                        }
                    }
                    
                    if (allTransactions.length === 0) {
                        showDrilldownSuccess('No transactions found', `${commonParams.period}  ${allAccounts.join(', ')}`);
                        return;
                    }
                    
                    console.log(`Drill-down: ${allTransactions.length} total transactions for ${allAccounts.length} account(s)`);
                    showDrilldownStatus('Creating transaction sheet...', `${allTransactions.length} transactions found`);
                    
                    // Create drill-down sheet with all transactions
                    const multiAccountParams = {
                        ...commonParams,
                        account: allAccounts.length > 1 ? allAccounts.join(', ') : allAccounts[0],
                        isMultiAccount: allAccounts.length > 1
                    };
                    
                    await createDrillDownSheet(context, allTransactions, multiAccountParams);
                    
                    const accountLabel = allAccounts.length > 1 ? `${allAccounts.length} accounts` : allAccounts[0];
                    showDrilldownSuccess(`Found ${allTransactions.length} transaction(s)`, `${accountLabel}  ${commonParams.period}`);
                });
                
            } catch (error) {
                console.error('Drill-down error:', error.message);
                showDrilldownError(error.message, 'Check console for details');
            } finally {
                if (btn) {
                btn.disabled = false;
                btn.innerHTML = originalBtnHTML || (isQuickActionsBtn ? '<span></span> Drill Down' : 'View Transactions');
                }
            }
        }
        
        // ================================================================
        // TYPEBALANCE DRILL-DOWN: Two-step process
        // Step 1: Show all accounts of that type with balances
        // Step 2: User clicks an account to see transactions
        // ================================================================
        async function handleTypeBalanceDrillDown(context, formula, statusEl) {
            try {
                // Parse TYPEBALANCE formula parameters
                const match = formula.match(/XAVI\.TYPEBALANCE\s*\((.*)\)/i);
                if (!match) {
                    showDrilldownError('Could not parse TYPEBALANCE formula', 'The formula structure was not recognized');
                    return;
                }
                
                const paramsStr = match[1];
                const params = parseTypeBalanceParams(paramsStr);
                
                // Resolve cell references to actual values
                showDrilldownStatus('Parsing formula parameters...', 'Resolving cell references');
                const resolvedParams = await resolveTypeBalanceParams(context, params);
                
                if (!resolvedParams.accountType) {
                    showDrilldownError('Could not determine account type', 'Check the first parameter of the formula');
                    return;
                }
                
                showDrilldownStatus(`Fetching ${resolvedParams.accountType} accounts...`, 'Querying NetSuite');
                
                // Query backend for all accounts of this type with their balances
                const queryParams = new URLSearchParams({
                    account_type: resolvedParams.accountType,
                    to_period: resolvedParams.toPeriod || '',
                    subsidiary: resolvedParams.subsidiary || '',
                    use_special: resolvedParams.useSpecialAccountType ? '1' : '0'
                });
                
                const response = await fetch(`${SERVER_URL}/accounts/by-type?${queryParams}`);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const accounts = data.accounts || [];
                
                if (accounts.length === 0) {
                    showDrilldownSuccess(`No accounts found`, `Account type "${resolvedParams.accountType}" has no accounts`);
                    return;
                }
                
                showDrilldownStatus('Creating accounts sheet...', `${accounts.length} accounts found`);
                
                // Create drill-down sheet showing accounts (Step 1)
                await createTypeBalanceAccountsSheet(context, accounts, resolvedParams);
                
                showDrilldownSuccess(`Found ${accounts.length} ${resolvedParams.accountType} account(s)`, 'Click any account row to drill into transactions');
                
            } catch (error) {
                console.error('TYPEBALANCE drill-down error:', error);
                showDrilldownError(error.message, 'Check console for details');
            }
        }
        
        function parseTypeBalanceParams(paramsStr) {
            const params = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < paramsStr.length; i++) {
                const char = paramsStr[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                    current += char;
                } else if (char === ',' && !inQuotes) {
                    params.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            if (current.trim()) params.push(current.trim());
            
            return {
                accountTypeRef: params[0] || '',
                fromPeriodRef: params[1] || '',
                toPeriodRef: params[2] || '',
                subsidiaryRef: params[3] || '',
                departmentRef: params[4] || '',
                locationRef: params[5] || '',
                classRef: params[6] || '',
                accountingBookRef: params[7] || '',
                useSpecialRef: params[8] || ''
            };
        }
        
        async function resolveTypeBalanceParams(context, refs) {
            const cleanParam = (p) => {
                if (!p || p === '""' || p === '') return '';
                return p.replace(/^["']|["']$/g, '');
            };
            
            const isCellRef = (str) => /^[\$]?[A-Z]+[\$]?\d+$/.test(str);
            
            // Convert Excel date serial number to "mmm yyyy" format
            const excelDateToMonthYear = (serial) => {
                // Excel dates are days since Dec 30, 1899 (with 1900 leap year bug)
                const excelEpoch = new Date(1899, 11, 30);
                const date = new Date(excelEpoch.getTime() + serial * 86400000);
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${months[date.getMonth()]} ${date.getFullYear()}`;
            };
            
            const getValue = async (ref, isDateParam = false) => {
                if (!ref || ref === '""' || ref === '') return '';
                const cleaned = cleanParam(ref);
                
                if (isCellRef(cleaned)) {
                    try {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const refRange = sheet.getRange(cleaned);
                        refRange.load('values');
                        await context.sync();
                        const rawValue = refRange.values[0][0];
                        
                        // Check if this is a date parameter and the value is a number (Excel date serial)
                        if (isDateParam && typeof rawValue === 'number' && rawValue > 1000) {
                            return excelDateToMonthYear(rawValue);
                        }
                        
                        // Also check if it's a string that looks like a date serial
                        if (isDateParam && typeof rawValue === 'string') {
                            // First check if it's already in "Mon YYYY" format
                            if (/^[A-Z][a-z]{2}\s\d{4}$/.test(rawValue)) {
                                return rawValue;
                            }
                            // Check if it's a numeric string (date serial)
                            const numValue = parseFloat(rawValue);
                            if (!isNaN(numValue) && numValue > 1000) {
                                return excelDateToMonthYear(numValue);
                            }
                        }
                        
                        return String(rawValue || '');
                    } catch (e) {
                        return '';
                    }
                }
                return cleaned;
            };
            
            // Mark fromPeriod and toPeriod as date parameters that may need conversion
            const resolvedParams = {
                accountType: await getValue(refs.accountTypeRef, false),
                fromPeriod: await getValue(refs.fromPeriodRef, true),  // isDateParam = true
                toPeriod: await getValue(refs.toPeriodRef, true),      // isDateParam = true
                subsidiary: await getValue(refs.subsidiaryRef, false),
                department: await getValue(refs.departmentRef, false),
                location: await getValue(refs.locationRef, false),
                classId: await getValue(refs.classRef, false),
                accountingBook: await getValue(refs.accountingBookRef, false),
                useSpecialAccountType: (await getValue(refs.useSpecialRef, false)) === '1'
            };
            
            console.log(' Resolved TYPEBALANCE params:', resolvedParams);
            return resolvedParams;
        }
        
        async function createTypeBalanceAccountsSheet(context, accounts, params) {
            const sheetName = `DrillDown_${params.accountType}`;
            
            // Delete existing sheet if present
            try {
                const existingSheet = context.workbook.worksheets.getItem(sheetName);
                existingSheet.delete();
                await context.sync();
            } catch (e) { /* Sheet doesn't exist */ }
            
            const drillSheet = context.workbook.worksheets.add(sheetName);
            drillSheet.activate();
            
            // Header
            drillSheet.getRange('A1').values = [['TYPEBALANCE DRILL-DOWN']];
            drillSheet.getRange('A1').format.font.bold = true;
            drillSheet.getRange('A1').format.font.size = 14;
            
            const useSpecialLabel = params.useSpecialAccountType ? ' (Special Account Type)' : '';
            drillSheet.getRange('A2').values = [[`Account Type: ${params.accountType}${useSpecialLabel} | Period: ${params.toPeriod || 'All Time'}`]];
            drillSheet.getRange('A2').format.font.bold = true;
            
            drillSheet.getRange('A3').values = [[' To drill into an account: Select the Account Number cell, then click "Drill Down" in the Quick Actions bar.']];
            drillSheet.getRange('A3').format.font.italic = true;
            drillSheet.getRange('A3').format.font.color = '#6b7280';
            
            // Column headers - Account, Name, Balance
            // Store period/subsidiary info in sheet for drill-down
            const headers = [['Account', 'Account Name', 'Balance']];
            drillSheet.getRange('A5:C5').values = headers;
            drillSheet.getRange('A5:C5').format.font.bold = true;
            drillSheet.getRange('A5:C5').format.fill.color = '#667eea';
            drillSheet.getRange('A5:C5').format.font.color = 'white';
            
            // Store drill-down context in row 3 (hidden) for drill-down function to use
            // Format: DRILLDOWN_CONTEXT:toPeriod:subsidiary:fromPeriod
            // We extract the year from toPeriod for the drill-down (to get all YTD transactions)
            const yearMatch = (params.toPeriod || '').match(/\d{4}/);
            const drilldownPeriod = yearMatch ? yearMatch[0] : params.toPeriod || '';
            drillSheet.getRange('A3').values = [[`DRILLDOWN_CONTEXT:${drilldownPeriod}:${params.subsidiary || ''}`]];
            drillSheet.getRange('A3').format.font.color = 'white'; // Hide it visually
            
            if (accounts.length > 0) {
                // Use PRE-FETCHED balances as static values (INSTANT display - no API calls!)
                const dataRows = accounts.map(acc => [
                    acc.account_number || acc.acctnumber || '',
                    acc.account_name || acc.accountname || '',
                    acc.balance || 0
                ]);
                drillSheet.getRange(`A6:C${5 + accounts.length}`).values = dataRows;
                
                // Format balance column as currency
                drillSheet.getRange(`C6:C${5 + accounts.length}`).numberFormat = [['$#,##0.00']];
                
                // Make account numbers blue (clickable visual cue)
                drillSheet.getRange(`A6:A${5 + accounts.length}`).format.font.color = '#0ea5e9';
                
                // Add total row
                const totalRow = 6 + accounts.length;
                drillSheet.getRange(`A${totalRow}`).values = [['TOTAL']];
                drillSheet.getRange(`A${totalRow}`).format.font.bold = true;
                drillSheet.getRange(`C${totalRow}`).formulas = [[`=SUM(C6:C${totalRow - 1})`]];
                drillSheet.getRange(`C${totalRow}`).format.font.bold = true;
                drillSheet.getRange(`C${totalRow}`).numberFormat = [['$#,##0.00']];
                
                // Add instructions row
                const infoRow = totalRow + 2;
                drillSheet.getRange(`A${infoRow}`).values = [[`${accounts.length} accounts | Click any row, then "Drill Down" in Quick Actions to see transactions`]];
                drillSheet.getRange(`A${infoRow}`).format.font.italic = true;
                drillSheet.getRange(`A${infoRow}`).format.font.color = '#6b7280';
            }
            
            // Auto-fit columns
            drillSheet.getUsedRange().format.autofitColumns();
            
            await context.sync();
        }

        function parseFormulaCellRefs(formula) {
            try {
                // Extract content between parentheses
                const match = formula.match(/XAVI\.BALANCE\s*\((.*)\)/i);
                if (!match) return null;
                
                const paramsStr = match[1];
                
                // Split by comma, but be careful with quotes and nested functions
                const params = [];
                let current = '';
                let inQuotes = false;
                let parenDepth = 0;
                
                for (let i = 0; i < paramsStr.length; i++) {
                    const char = paramsStr[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                        current += char;
                    } else if (char === '(' && !inQuotes) {
                        parenDepth++;
                        current += char;
                    } else if (char === ')' && !inQuotes) {
                        parenDepth--;
                        current += char;
                    } else if (char === ',' && !inQuotes && parenDepth === 0) {
                        // ALWAYS push the parameter, even if empty (for skipped params like ",,")
                        params.push(current.trim());
                        current = '';
                } else {
                        current += char;
                    }
                }
                
                // Always push the last parameter (even if empty)
                    params.push(current.trim());
                
                // Return cell references or literal values as-is
                return {
                    accountRef: params[0] || '',
                    fromPeriodRef: params[1] || '',
                    toPeriodRef: params[2] || '',
                    subsidiaryRef: params[3] || '',
                    departmentRef: params[4] || '',
                    locationRef: params[5] || '',
                    classRef: params[6] || ''
                };
                
            } catch (error) {
                console.error('Error parsing formula:', error);
                return null;
            }
        }

        async function resolveFormulaParams(context, cellRefs) {
            try {
                // Helper to clean up a parameter (remove quotes, handle empty)
                const cleanParam = (p) => {
                    if (!p || p === '""' || p === '') return '';
                    // Remove surrounding quotes
                    return p.replace(/^["']|["']$/g, '');
                };
                
                // Helper to check if a string is a cell reference (like A1, $A$1, H$3, etc.)
                const isCellRef = (str) => {
                    return /^[\$]?[A-Z]+[\$]?\d+$/.test(str);
                };
                
                // Helper to get value from cell reference or return literal value
                const getValue = async (ref) => {
                    if (!ref || ref === '""' || ref === '') return '';
                    
                    const cleaned = cleanParam(ref);
                    
                    // Check if it's a TEXT() formula - extract the cell reference from it
                    const textMatch = cleaned.match(/^TEXT\s*\(\s*([\$]?[A-Z]+[\$]?\d+)\s*,/i);
                    if (textMatch) {
                        const cellRef = textMatch[1];
                        try {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const refRange = sheet.getRange(cellRef);
                            refRange.load('values');
                            await context.sync();
                            
                            const value = refRange.values[0][0];
                            console.log(`  Resolved ${cellRef} to:`, value);
                            return String(value || '');
                        } catch (e) {
                            console.warn(`Could not resolve TEXT formula cell reference ${cellRef}:`, e);
                            return '';
                        }
                    }
                    
                    // If it's a cell reference, get the value from that cell
                    if (isCellRef(cleaned)) {
                        try {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const refRange = sheet.getRange(cleaned);
                            refRange.load('values');
                            await context.sync();
                            
                            const value = refRange.values[0][0];
                            console.log(`  Resolved ${cleaned} to:`, value);
                            return String(value || '');
                        } catch (e) {
                            console.warn(`Could not resolve cell reference ${cleaned}:`, e);
                            return '';
                        }
                    }
                    
                    // Otherwise return the literal value
                    return cleaned;
                };
                
                // Helper to convert Excel date serial to period name
                const convertToPeriodName = (value) => {
                    if (!value) return '';
                    
                    // If it's already a string like "Jan 2024", return as-is
                    if (typeof value === 'string' && /^[A-Za-z]{3}\s+\d{4}$/.test(value.trim())) {
                        return value.trim();
                    }
                    
                    // If it's a number, it might be an Excel date serial
                    const num = Number(value);
                    if (!isNaN(num) && num > 40000 && num < 60000) {
                        // Excel date serial: convert to JS Date
                        // Excel epoch is Dec 30, 1899 (with the 1900 leap year bug)
                        const excelEpoch = new Date(1899, 11, 30);
                        const jsDate = new Date(excelEpoch.getTime() + num * 24 * 60 * 60 * 1000);
                        
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        const periodName = `${monthNames[jsDate.getMonth()]} ${jsDate.getFullYear()}`;
                        console.log(`   Converted Excel date ${value} to period: ${periodName}`);
                        return periodName;
                    }
                    
                    // Otherwise return as-is
                    return String(value);
                };
                
                // Resolve all parameters
                const account = await getValue(cellRefs.accountRef);
                const fromPeriodRaw = await getValue(cellRefs.fromPeriodRef);
                const toPeriodRaw = await getValue(cellRefs.toPeriodRef);
                const subsidiary = await getValue(cellRefs.subsidiaryRef);
                const department = await getValue(cellRefs.departmentRef);
                const location = await getValue(cellRefs.locationRef);
                const classId = await getValue(cellRefs.classRef);
                
                // Convert periods if they're Excel date serials
                const fromPeriod = convertToPeriodName(fromPeriodRaw);
                const toPeriod = convertToPeriodName(toPeriodRaw);
                
                // For Balance Sheet accounts, fromPeriod may be empty (cumulative from inception)
                // Use toPeriod for drill-down in that case
                const drillDownPeriod = fromPeriod || toPeriod;
                
                return {
                    account: account,
                    period: drillDownPeriod, // Use fromPeriod if set, otherwise toPeriod
                    fromPeriod: fromPeriod,
                    toPeriod: toPeriod,
                    subsidiary: subsidiary,
                    department: department,
                    location: location,
                    class: classId
                };
                
            } catch (error) {
                console.error('Error resolving formula params:', error);
                return null;
            }
        }

        async function createDrillDownSheet(context, transactions, params) {
            // Create or get drill-down sheet
            // Sanitize account name for sheet name (Excel doesn't allow * in sheet names)
            const sanitizedAccount = params.account.replace(/\*/g, 'ALL').replace(/,\s*/g, '_').substring(0, 20);
            const sheetName = `DrillDown_${sanitizedAccount}`;
            // Show account column if wildcard OR multiple accounts in the cell
            const isWildcard = params.account.includes('*') || params.isMultiAccount;
            
            let drillSheet;
            try {
                drillSheet = context.workbook.worksheets.getItem(sheetName);
                drillSheet.delete();
                await context.sync();
            } catch (e) {
                // Sheet doesn't exist, that's fine
            }
            
            drillSheet = context.workbook.worksheets.add(sheetName);
            drillSheet.activate();
            
            // Add header
            drillSheet.getRange('A1').values = [['TRANSACTION DRILL-DOWN']];
            drillSheet.getRange('A1').format.font.bold = true;
            drillSheet.getRange('A1').format.font.size = 14;
            
            let accountLabel;
            if (params.isMultiAccount) {
                accountLabel = `Multiple Accounts: ${params.account}`;
            } else if (params.account.includes('*')) {
                accountLabel = `Accounts: ${params.account} (wildcard)`;
            } else {
                accountLabel = `Account: ${params.account}`;
            }
            drillSheet.getRange('A2').values = [[`${accountLabel} | Period: ${params.period}`]];
            drillSheet.getRange('A2').format.font.bold = true;
            
            // Add column headers - include Account column for wildcard drill-downs
            const headers = isWildcard
                ? [['Account', 'Date', 'Type', 'Number', 'Entity', 'Memo', 'Debit', 'Credit', 'Net Amount']]
                : [['Date', 'Type', 'Number', 'Entity', 'Memo', 'Debit', 'Credit', 'Net Amount']];
            
            const headerRange = isWildcard ? 'A4:I4' : 'A4:H4';
            drillSheet.getRange(headerRange).values = headers;
            drillSheet.getRange(headerRange).format.font.bold = true;
            drillSheet.getRange(headerRange).format.fill.color = '#667eea';
            drillSheet.getRange(headerRange).format.font.color = 'white';
            
            // Add transaction data - include Account column for wildcard drill-downs
            const dataRows = isWildcard
                ? transactions.map(txn => [
                    txn.account_number || '',
                    txn.transaction_date || '',
                    txn.transaction_type || '',
                    txn.transaction_number || '',
                    txn.entity_name || '',
                    txn.memo || '',
                    txn.debit ? parseFloat(txn.debit) : 0,
                    txn.credit ? parseFloat(txn.credit) : 0,
                    txn.net_amount ? parseFloat(txn.net_amount) : 0
                ])
                : transactions.map(txn => [
                    txn.transaction_date || '',
                    txn.transaction_type || '',
                    txn.transaction_number || '',
                    txn.entity_name || '',
                    txn.memo || '',
                    txn.debit ? parseFloat(txn.debit) : 0,
                    txn.credit ? parseFloat(txn.credit) : 0,
                    txn.net_amount ? parseFloat(txn.net_amount) : 0
                ]);
            
            const lastCol = isWildcard ? 'I' : 'H';
            const debitCol = isWildcard ? 'G' : 'F';
            const linkCol = isWildcard ? 'D' : 'C';
            
            const dataRange = drillSheet.getRange(`A5:${lastCol}${4 + dataRows.length}`);
            dataRange.values = dataRows;
            
            // Format numbers as currency
            drillSheet.getRange(`${debitCol}5:${lastCol}${4 + dataRows.length}`).numberFormat = [['#,##0.00']];
            
            // Add hyperlinks to NetSuite URLs
            for (let i = 0; i < transactions.length; i++) {
                const txn = transactions[i];
                const row = 5 + i;
                
                // Add hyperlink for transaction number (column varies based on wildcard)
                const linkCell = drillSheet.getRange(`${linkCol}${row}`);
                const hyperlink = {
                    address: txn.netsuite_url,
                    textToDisplay: txn.transaction_number
                };
                linkCell.hyperlink = hyperlink;
                linkCell.format.font.color = '#0ea5e9';
                linkCell.format.font.underline = 'Single';
            }
            
            // Auto-fit columns
            const autoFitRange = isWildcard ? 'A:I' : 'A:H';
            drillSheet.getRange(autoFitRange).format.autofitColumns();
            
            // Add summary at bottom
            const summaryRow = 5 + dataRows.length + 2;
            drillSheet.getRange(`A${summaryRow}`).values = [[`Total Transactions: ${transactions.length}`]];
            drillSheet.getRange(`A${summaryRow}`).format.font.bold = true;
            
            // Column indices vary based on wildcard (wildcard adds Account column at start)
            const debitIdx = isWildcard ? 6 : 5;
            const creditIdx = isWildcard ? 7 : 6;
            const netIdx = isWildcard ? 8 : 7;
            const totalsLabelCol = isWildcard ? 'F' : 'E';
            const totalsDebitCol = isWildcard ? 'G' : 'F';
            const totalsCreditCol = isWildcard ? 'H' : 'G';
            const totalsNetCol = isWildcard ? 'I' : 'H';
            
            const totalDebit = dataRows.reduce((sum, row) => sum + row[debitIdx], 0);
            const totalCredit = dataRows.reduce((sum, row) => sum + row[creditIdx], 0);
            const totalNet = dataRows.reduce((sum, row) => sum + row[netIdx], 0);
            
            drillSheet.getRange(`${totalsLabelCol}${summaryRow}`).values = [['Totals:']];
            drillSheet.getRange(`${totalsDebitCol}${summaryRow}`).values = [[totalDebit]];
            drillSheet.getRange(`${totalsCreditCol}${summaryRow}`).values = [[totalCredit]];
            drillSheet.getRange(`${totalsNetCol}${summaryRow}`).values = [[totalNet]];
            drillSheet.getRange(`${totalsLabelCol}${summaryRow}:${totalsNetCol}${summaryRow}`).format.font.bold = true;
            drillSheet.getRange(`${totalsDebitCol}${summaryRow}:${totalsNetCol}${summaryRow}`).numberFormat = [['#,##0.00']];
            
            await context.sync();
        }

        // ==========================================================================
        // CONTEXT MENU HANDLER (called when right-clicking and selecting "View Transactions")
        // ==========================================================================
        async function searchAccounts() {
            const statusEl = document.getElementById('searchStatus');
            const inputEl = document.getElementById('accountSearchInput');
            const btn = event.target;
            
            try {
                const pattern = inputEl.value.trim();
                
                if (!pattern) {
                    statusEl.textContent = ' Please enter a search pattern (e.g., 4* or 42*)';
                    statusEl.style.color = '#dc2626';
                    setTimeout(() => { statusEl.textContent = ''; }, 3000);
                    return;
                }
                
                btn.disabled = true;
                btn.textContent = 'Searching...';
                
                showLoading('Account Search', `Searching for "${pattern}"...`, 20);
                
                console.log('=== ACCOUNT SEARCH START ===');
                console.log('Pattern:', pattern);
                
                // Call backend API
                const url = `${SERVER_URL}/accounts/search?pattern=${encodeURIComponent(pattern)}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error:', errorText);
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Search results:', data);
                
                const accounts = data.accounts || [];
                
                if (accounts.length === 0) {
                    hideLoading();
                    statusEl.textContent = ` No accounts found matching "${pattern}"`;
                    statusEl.style.color = '#059669';
                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    return;
                }
                
                
                updateLoading(`Inserting ${accounts.length} accounts...`, 70);
                
                // Create results sheet
                await Excel.run(async (context) => {
                    await createAccountSearchSheet(context, accounts, pattern);
                });
                
                updateLoading('Complete!', 100);
                await new Promise(resolve => setTimeout(resolve, 500));
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Inserted ${accounts.length} accounts!</strong></div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
                
                console.log('=== ACCOUNT SEARCH COMPLETE ===');
                
            } catch (error) {
                console.error('=== ACCOUNT SEARCH ERROR ===');
                console.error('Error:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 8000);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Bulk Add GL Accounts';
            }
        }

        async function createAccountSearchSheet(context, accounts, pattern) {
            // INSERT AT CURSOR POSITION (not new sheet!)
            const sheet = context.workbook.worksheets.getActiveWorksheet();
            const range = context.workbook.getSelectedRange();
            range.load(['address', 'rowIndex', 'columnIndex']);
            await context.sync();
            
            console.log(`Inserting ${accounts.length} accounts at ${range.address}`);
            
            // Headers row
            const headers = ['Account Type', 'Spec Acct Type', 'Account Number', 'Account Name'];
            
            // Prepare data rows
            // Order: Type, Special Account Type, Number, Name
            const dataRows = accounts.map(acc => [
                acc.accttype || '',
                acc.sspecacct || '',  // Special Account Type (e.g., Retained Earnings)
                acc.accountnumber || '',
                acc.accountname || ''
            ]);
            
            // Combine headers + data
            const allRows = [headers, ...dataRows];
            
            // Get the range starting at cursor position (headers + data)
            const targetRange = sheet.getRangeByIndexes(
                range.rowIndex,
                range.columnIndex,
                allRows.length,
                4  // 4 columns
            );
            
            // Insert data
            targetRange.values = allRows;
            
            // Style the header row
            const headerRange = sheet.getRangeByIndexes(
                range.rowIndex,
                range.columnIndex,
                1,
                4
            );
            headerRange.format.font.bold = true;
            headerRange.format.fill.color = '#f3f4f6';
            
            await context.sync();
            
            console.log(`Inserted ${accounts.length} accounts with headers at cursor position`);
        }

        // NOTE: drillDownFromContextMenu is defined at the TOP of the script
        // so it's available immediately for ExecuteFunction actions
    </script>
</body>
</html>
